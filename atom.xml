<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  <subtitle>空谷无人，水流花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangjie2.github.io/"/>
  <updated>2018-08-09T02:46:44.782Z</updated>
  <id>https://yangjie2.github.io/</id>
  
  <author>
    <name>Yang Jie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用cocoapods插件打包静态库——适用于项目依赖私有库、开源库，私有库又依赖静态库等复杂场景</title>
    <link href="https://yangjie2.github.io/2018/08/07/%E4%BD%BF%E7%94%A8cocoapods%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E5%BA%93%E2%80%94%E2%80%94%E9%80%82%E7%94%A8%E4%BA%8E%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%A7%81%E6%9C%89%E5%BA%93%E3%80%81%E5%BC%80%E6%BA%90%E5%BA%93%EF%BC%8C%E7%A7%81%E6%9C%89%E5%BA%93%E5%8F%88%E4%BE%9D%E8%B5%96%E9%9D%99%E6%80%81%E5%BA%93%E7%AD%89%E5%A4%8D%E6%9D%82%E5%9C%BA%E6%99%AF/"/>
    <id>https://yangjie2.github.io/2018/08/07/使用cocoapods插件打包静态库——适用于项目依赖私有库、开源库，私有库又依赖静态库等复杂场景/</id>
    <published>2018-08-07T02:00:34.000Z</published>
    <updated>2018-08-09T02:46:44.782Z</updated>
    
    <content type="html"><![CDATA[<p>我们小组需要持续向其他公司或部门提供一套IM（即时通讯）SDK，为了隐藏源码实现，就需要将它打包为静态库（.a/.framework）的形式。该项目使用cocoapods管理，依赖许多私有库，并且私有库又依赖私有库、开源库等，这些私有库又会涉及频繁更新，每次打包静态库时都需要保证是最新的代码，并且还要解决各个库的依赖问题。在这种情况下，怎么才能方便快速的打包静态库呢？幸好 cocoapods 已经给我们提供了一个打包插件:<a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">Cocoapods-package</a>，这让打包静态库的任务变得简单许多。</p><a id="more"></a><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h4 id="xcode中的-workspace-project-target-scheme概念"><a href="#xcode中的-workspace-project-target-scheme概念" class="headerlink" title="xcode中的 workspace, project, target, scheme概念"></a>xcode中的 workspace, project, target, scheme概念</h4><p><strong>wrokspace</strong></p><blockquote><p>A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets.</p></blockquote><p>workspace 是最大的集合，包含一个或多个 project，同时 workspace 可以管理它所包含的 project 之间隐式或显式的关系。workspace 是以 xcworkspace 的文件形式存在的（这点和 project 一致）。workspace 的存在是为了解决不同 project 之间引用和调用困难的问题.</p><blockquote><p>By default, all the Xcode projects in a workspace are built in the same directory, referred to as the workspace build directory. Each workspace has its own build directory. Because all of the files in all of the projects in a workspace are in the same build directory, all of these files are visible to each project. Therefore, if two or more projects use the same libraries, you don’t need to copy them into each project folder separately.</p></blockquote><p> 同一个 workspace 下的所有 project 共用同一个编译路径。</p><p><strong>project</strong></p><blockquote><p>An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings).</p></blockquote><p>一个 xcode project 包含了这个项目所有的文件、资源以及构建一个或多个 product 所需的信息。project 包含了构建你的应用所需要的所有元素，并维护这些元素之间的关系。project 包含一个或者多个 target，target 描述了怎样去构建 product。project 定义了其包含的所有 project 的 target 的默认编译设置，每个 target 都可以自定义编译选项，自定义配置会覆盖掉 project 的默认配置。</p><p>一个 project 可以是独立存在的，也可以被包含到 workspace 中。一个 xcode project 文件包含如下信息：</p><ul><li><p>References to source files:</p><ol><li>Source code, including header files and implementation files</li><li>Libraries and frameworks, internal and external</li><li>Resource files</li><li>Image files</li><li>Interface Builder (nib) files</li></ol></li><li><p>Groups used to organize the source files in the structure navigator</p></li><li>Project-level build configurations.<br>You can specify more than one build configuration for a project; for example, you might have debug and release build settings for a project.</li><li>Targets, where each target specifies:<ol><li>A reference to one product built by the project</li><li>References to the source files needed to build that product</li><li>The build configurations that can be used to build that product, including dependencies on other targets and other settings; the project-level build settings are used when the targets’ build configurations do not override them  </li></ol></li><li>The executable environments that can be used to debug or test the program, where each executable environment specifies:<ol><li>What executable to launch when you run or debug from Xcode</li><li>Command-line arguments to be passed to the executable, if any</li><li>Environmental variables to be set when the program runs, if any</li></ol></li></ul><p>You use Xcode schemes to specify which target, build configuration, and executable configuration is active at a given time.</p><p><strong>target</strong></p><blockquote><p>A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.</p></blockquote><p>字面意思是“目标”，target 指定了如何编译 product ，它负责向编译系统提供”输入”(源文件以及编译这些源文件的配置说明)。</p><p>如果你现在有一个产品，你要做不同的环境出来，包括线上、预发、日常等等。这个时候你就可以来建立多个Target来实现。你先选中Targets里面的默认的第一个，然后右击弹出一个小列表：（Duplicate、Delete、Project Editor Help），顾名思义，Duplicate就是复制的意思，你可以选择一个Target进行复制，然后通过修改其General、Build Settings以及Build Phases来进行定制化修改，在Build Settings里面有一个Preprocessor Macros的选项，你可以直接设置定义宏的方式来对不同的Target进行区分。</p><p><strong>scheme</strong></p><blockquote><p>An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.You can have as many schemes as you want, but only one can be active at a time. You can specify whether a scheme should be stored in a project—in which case it’s available in every workspace that includes that project, or in the workspace—in which case it’s available only in that workspace. When you select an active scheme, you also select a run destination (that is, the architecture of the hardware for which the products are built).</p></blockquote><h4 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h4><p>库（library）是共享程序代码的方式，一般分为静态库和动态库。</p><p><strong>静态库</strong>: 即静态链接库，是一系列从源码编译得到的目标文件的集合，是你的源码的实现所对应的二进制。链接时，静态库会被完整地复制到目标程序中，被多次使用就有多份冗余拷贝。</p><p>在 iOS 8 之前，iOS 只支持以静态库的方式来使用第三方的代码。</p><p>静态库的优点是，编译完成之后，原始静态库实际上就没有作用了，应用程序没有外部依赖(因为依赖的静态库已经被完整的拷贝进来)，直接就可以运行。当然其缺点也很明显，就是会使用应用程序的体积增大。</p><p>不同平台下的静态库文件格式如下表：</p><table><thead><tr><th>系统</th><th>静态库文件</th></tr></thead><tbody><tr><td>Windows</td><td>.lib</td></tr><tr><td>Linux</td><td>.a</td></tr><tr><td>MacOS／iOS</td><td>.a</td></tr></tbody></table><p></p><p><strong>动态库</strong>: 一个没有main函数的可执行文件。动态库在链接时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进内存，这也是叫做动态库的原因。</p><p>动态库的优点是，不影响目标程序的体积，可以随时对库进行升级替换而不需要重新编译。</p><p>不同平台下的动态库文件格式如下表：</p><table><thead><tr><th>系统</th><th>动态库文件</th></tr></thead><tbody><tr><td>Windows</td><td>.dll</td></tr><tr><td>Linux</td><td>.so</td></tr><tr><td>MacOS／iOS</td><td>.dylib</td></tr></tbody></table><img src="/2018/08/07/使用cocoapods插件打包静态库——适用于项目依赖私有库、开源库，私有库又依赖静态库等复杂场景/静态库.png" title="动态库和静态库加载方式"><p>–<br><strong>MacOS/iOS 里的 Framework</strong></p><p>除了上面提到的 .a 和 .dylib/.tbd 之外，Mac OS/iOS 平台还可以使用 Framework。Framework 是一种特殊的文件夹，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。</p><p>系统的 framework 是存在于系统内部，而不会打包进 app 中。app 的启动的时候会检查所需要的动态框架是否已经加载。像 UIKit 之类的常用系统框架一般已经在内存中，就不需要再次加载，这可以保证 app 启动速度。相比静态库，framework 是自包含的，你不需要关心头文件位置等，使用起来很方便。</p><p>在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。</p><p>iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 App Extension 的出现,可以为一个应用创建插件。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 沙盒中（App 和 App Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。</p><p>由于 iOS 的沙盒机制，自己创建的 Framework 和系统 Framework 不同，App 中使用的 Framework 运行在沙盒里，而不是系统中。每个 App 都只能用自己对应签名的动态库，做不到多个 App 使用一个动态库。也就是说，如果不同的 App 使用了同一个动态库 Framework，那该 Framework 会被分别签名、打包和加载。所以，iOS 上我们自己创建的动态库只能是私有的，无法将动态库放置在除了自身沙盒以外的地方。</p><p><strong>swift 项目支持静态库</strong></p><p>Xcode9 之前 Swift 项目不支持静态库。所以如果你使用的依赖中包含 Swift 代码，又想使用 CocoaPods 来管理的话，必须选择开启 <code>user_frameworks!</code>。<code>use_frameworks!</code> 会把项目的依赖全部改为 framework。也就是说这是一个 none or all 的更改。你无法指定某几个框架编译为动态，某几个编译为静态。</p><p>终于在 Xcode 9 版本，swift 带来对静态库的原生支持。并且，<a href="https://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a> 在前一段时间发布了 1.5 版本，其中有一个对于使用了 Swift 的项目非常重要的 feature，那就是<a href="http://blog.cocoapods.org/CocoaPods-1.5.0/" target="_blank" rel="noopener">支持了 Swift 的 Static Library</a>。</p><blockquote><p>With CocoaPods 1.5.0, developers are no longer restricted into specifying <code>use_frameworks!</code> in their Podfile in order to install pods that use Swift. Interop with Objective-C should just work. However, if your Swift pod depends on an Objective-C, pod you will need to enable <code>modular headers</code> (see below) for that Objective-C pod.</p><p>As a pod author, you can add <code>DEFINES_MODULE =&gt; &#39;YES&#39;</code> to your pod_target_xcconfig. Alternatively, in your Podfile you can add <code>use_modular_headers!</code> to enable the stricter search paths and module map generation for all of your pods, or you can add <code>:modular_headers =&gt; true</code> to a single pod declaration to enable for only that pod.</p></blockquote><p>以上补充了几点基础知识，能够让你对xcode文件结构和各个文件的作用有了比较清晰的了解，也知道了静态库、动态库，以及为什么之前需要在 podfile 中添加那句 <code>use_frameworks!</code>。现在可以开始打包静态库的工作了。</p><h2 id="打包静态库"><a href="#打包静态库" class="headerlink" title="打包静态库"></a>打包静态库</h2><h4 id="创建一个-pod"><a href="#创建一个-pod" class="headerlink" title="创建一个 pod"></a>创建一个 pod</h4><p>如果当前已经存在一个 project，创建pod也非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pod spec create [POD_NAME]]</span><br><span class="line">$ edit POD_NAME.podspec</span><br><span class="line">$ pod spec lint POD_NAME.podspec</span><br></pre></td></tr></table></figure><p>然而创建并配置工程这种费力的活交给 cocoapods 会更好。</p><blockquote><p>Running pod lib create [pod name] will set you up with a well thought out library structure allowing you to easily include your files and get started quickly.</p></blockquote><p>所以我们这里使用 pod lib create [pod name] 去创建一个pod，过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib create YJDemoSDK</span><br><span class="line">  Cloning `https://github.com/CocoaPods/pod-template.git` into `YJDemoSDK`.</span><br><span class="line">  Configuring YJDemoSDK template.</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide: </span><br><span class="line"> - https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line"> ( hold cmd and double click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS</span><br><span class="line"></span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; Objc</span><br><span class="line"></span><br><span class="line"> Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; Yes</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line"> &gt; None</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line"> &gt; No</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; YJ</span><br><span class="line"></span><br><span class="line">Running pod install on your new library.</span><br><span class="line"></span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `YJDemoSDK` from `../`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing YJDemoSDK (0.1.0)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] Please close any current Xcode sessions and use `YJDemoSDK.xcworkspace` for this project from now on.</span><br><span class="line">Sending stats</span><br><span class="line">Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.</span><br><span class="line"></span><br><span class="line">[!] Automatically assigning platform ios with version 9.3 on target YJDemoSDK_Example because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`.</span><br><span class="line"></span><br><span class="line"> Ace! you&apos;re ready to go!</span><br><span class="line"> We will start you off by opening your project in Xcode</span><br><span class="line">  open &apos;YJDemoSDK/Example/YJDemoSDK.xcworkspace&apos;</span><br><span class="line"></span><br><span class="line">To learn more about the template see `https://github.com/CocoaPods/pod-template.git`.</span><br><span class="line">To learn more about creating a new pod, see `http://guides.cocoapods.org/making/making-a-cocoapod`.</span><br></pre></td></tr></table></figure><p>创建完成之后，会自动打开这个pod工程，文件结构如下图所示：</p><img src="/2018/08/07/使用cocoapods插件打包静态库——适用于项目依赖私有库、开源库，私有库又依赖静态库等复杂场景/pod库文件结构.png" title="[pod库文件结构]"><p><strong>podspec</strong></p><p>.podspec 文件描述了一个 pod 库的版本。它详细说明了这个 pod 库中源码应该从哪里取出、应用怎样的构建设置以及其他基本的信息，比如名称、版本、描述等。</p><p>podspec 文件的内容如下，并做了简要注释，不过还是强烈建议阅读下<a href="https://guides.cocoapods.org/" target="_blank" rel="noopener">官方文档</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name          = &apos;YJDemoSDK&apos; #项目名</span><br><span class="line">s.version       = &apos;0.1.0&apos; #相应的版本号</span><br><span class="line">s.summary       = &apos;A short description of YJDemoSDK.&apos; #简述</span><br><span class="line">s.description   = &lt;&lt;‐ DESC #详细描述</span><br><span class="line">TODO: Add long description of the pod here.</span><br><span class="line">DESC</span><br><span class="line"></span><br><span class="line">s.homepage      = &apos;https://github.com/yangjie2/YJDemoSDK&apos; #项目主页</span><br><span class="line">s.license       = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; #开源协议</span><br><span class="line">s.author        = &#123; &apos;yangjie2&apos; =&gt; &apos;yangjie2107@hotmail.com&apos; &#125; #作者</span><br><span class="line">s.platform      = :ios, &apos;8.0&apos; #支持的平台</span><br><span class="line">s.requires_arc  = true #arc和mrc选项</span><br><span class="line">spec.compiler_flags = &apos;-DOS_OBJECT_USE_OBJC=0&apos;, &apos;-Wno-format&apos;  #A list of flags which should be passed to the compiler.</span><br><span class="line"></span><br><span class="line">s.libraries     = &apos;z&apos;, &apos;sqlite3&apos; #表示依赖的系统类库，比如libz.dylib等</span><br><span class="line">s.frameworks    = &apos;UIKit&apos;,&apos;AVFoundation&apos; #表示依赖的系统framework</span><br><span class="line">s.ios.vendored_frameworks = &apos;YJDemoSDK/Classes/YJKit.framework&apos; # 依赖的第三方/自己的framework</span><br><span class="line">s.vendored_libraries = &apos;YJDemoSDK/Classes/libWeChatSDK.a&apos; #表示依赖第三方/自己的 .a 库</span><br><span class="line">#依赖的第三方的或者自己的静态库文件必须以lib为前缀进行命名，否则会出现找不到的情况，这一点非常重要</span><br><span class="line"></span><br><span class="line">s.preserve_paths = &quot;IMPORTANT.txt&quot;,&quot;Frameworks/*.framework&quot;  #Any file that should not be removed after being downloaded.</span><br><span class="line"></span><br><span class="line">#平台信息</span><br><span class="line">s.platform      = :ios, &apos;7.0&apos; </span><br><span class="line">s.ios.deployment_target = &apos;7.0&apos;</span><br><span class="line"></span><br><span class="line">#文件配置项</span><br><span class="line">s.source        = &#123; :git =&gt; &apos;https://github.com/yangjie2/YJDemoSDK.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line"> #配置项目的目标路径，如果不是本地开发，pod init/update会从这个路去拉去代码</span><br><span class="line"></span><br><span class="line">s.source_files = &apos;YJDemoSDK/Classes/**/*.&#123;h,m&#125;&apos; #你的源码位置</span><br><span class="line"></span><br><span class="line"># cocoapods 官方强烈推荐使用 resource_bundles，因为 resources  指定的资源会被直接拷贝到目标应用中，因此不会被 Xcode 优化，在编译生成 product 时，与目标应用的图片资源以及其他同样使用 resources 的 Pod 的图片一起打包为一个 Assets.car 文件。这样全部混杂在一起，就使得资源文件容易产生命名冲突。而 resource_bundles 指定的资源，会被编译到独立的 bundle 中，bundle 名就是你的 pod 名，</span><br><span class="line">这样就很大程度上减小了资源名冲突问题，并且 Xcode 会对 bundle 进行优化。一个 bundle 包含一个 Assets.car，获取图片的时候要严格指定 bundle 的位置，很好的隔离了各个库或者一个库下的资源文件。</span><br><span class="line"># s.resources     = [&apos;YJDemoSDK/Assets/*.png&apos;] #资源，比如图片，音频文件，xib等资源</span><br><span class="line">s.resource_bundles = &#123;</span><br><span class="line">    &apos;WYAVChatKit&apos; =&gt; [&apos;YJDemoSDK/Assets/*.png&apos;,&apos;WYAVChatKit/Assets/Audio.wav&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">s.public_header_files = &apos;YJDemoSDK/Classes/YJDemoSDK.h&apos;   #需要对外开放的头文件</span><br><span class="line"></span><br><span class="line">#依赖的项目内容 可以多个</span><br><span class="line">s.dependency &apos;YYModel&apos;</span><br><span class="line">s.dependency &apos;AFNetworking&apos; &apos;2.3&apos;</span><br></pre></td></tr></table></figure><p><strong>Development Pods</strong></p><blockquote><p>Development Pods are different from normal CocoaPods in that they are symlinked files, so making edits to them will change the original files, so you can work on your library from inside Xcode. Your demo &amp; tests will need to include references to headers using the #import &lt;MyLib/XYZ.h&gt; format.</p><p>Note: Due to a Development Pods implementation detail, when you add new/existing files to Pod/Classes or Pod/Assets or update your podspec, you should run pod install or pod update. </p></blockquote><p>Development Pods 是符号链接文件，所以对它的编辑也会改变原始文件。这样就能在xcode内开发你的pod库。当你向 Pod/Classes 或 Pod/Assets 添加新的/已经存在的文件，或者更新你的 .podspec 时，需要再次运行 pod install 或者 pod update。</p><p>配置完 podspec 之后，需要对它进行验证，没有错误和警告就能通过验证了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint ***.podspec  //仅本地验证</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">pod spec lint [NAME.podspec|DIRECTORY|http://PATH/NAME.podspec ...] //使用网络验证远端</span><br></pre></td></tr></table></figure><p>在实际使用中，我们的pod库依赖私有库，开源库，并且依赖静态库，所以验证时需要指定 sources ，私有Repo地址和cocoapods官方的 Repo 地址，并且默认是 master 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint PODNAME.podspec --sources=git@*******:yangjie2/snowRepo.git,https://github.com/CocoaPods/Specs.git --use-libraries --allow-warnings</span><br></pre></td></tr></table></figure><p>–use-libraries表示依赖了静态库，–allow-warnings忽略警告。</p><p>验证过程也许会比较艰难，因为总会出现各种 errors，不过基本上 google 下都能解决，这里简单记录下我遇到的两个问题: </p><ol><li>pod本地缓存引起的 build error，明明 xcode 都能编译通过，并且远端服务器上的代码也同步了最新的，但就是执行 pod spec lint 时出现一堆 <code>- ERROR | xcodebuild:</code>。仔细分析下发现，出错的地方依旧是是老版本的代码导致，所以确定是由 pod 缓存引起的。执行 pod cache clean 清除缓存，就可以了。</li><li>一个特别奇怪的 error，<code>error: cannot synthesize weak property in file using manual reference counting</code>. 这到底是什么鬼？分析了半天，终于找到原因，<code>s.requires_arc  = true</code>这句话，我把 <code>true</code>写成了<code>&#39;true&#39;</code>,记得这里一定不要加单引号，否则 cocoapods 认为你的 pod 库是非 ARC 的。</li></ol><p>刚才说到，pod lib lint 和 pod spec lint 的区别：</p><blockquote><p>The difference between them is that pod lib lint does not access the network, whereas pod spec lint checks the external repo and associated tag.</p></blockquote><p>上面使用的是 pod lib lint 验证本地pod，其实只要保证本地和远端服务器的代码是一致的，使用 pod spec lint 肯定可以验证通过。只不过有一点需要注意，在使用 pod spec lint 时，验证的是远端,也许你会遇到这种 error：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone git@*********/WYAVTencentSDK.git /var/folders/8v/jks4fgp55897h3tpp65jp9680000gn/T/d20180808-84364-vuvr0v --template= --single-branch --depth 1 --branch 0.1.0</span><br><span class="line"></span><br><span class="line">Cloning into &apos;/var/folders/8v/jks4fgp55897h3tpp65jp9680000gn/T/d20180808-84364-vuvr0v&apos;...</span><br><span class="line">warning: Could not find remote branch 0.1.0 to clone.</span><br><span class="line">fatal: Remote branch 0.1.0 not found in upstream origin</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br></pre></td></tr></table></figure></p><p>它提示你找不到 0.1.0 这个分支（因为在 podspec 文件中我们指定了 s.version = ‘0.1.0’），当然找不到了，因为确实没有这个分支。因为我们暂时还没有打 0.1.0 这个tag。当我打了 0.1.0 tag 后，再次使用 pod spec lint 验证，就顺利通过了。</p><p>到现在为止，我们完成了对 pod 库的配置，并且打了tag。接下来就开始打包静态库！</p><h4 id="打包静态库-1"><a href="#打包静态库-1" class="headerlink" title="打包静态库"></a>打包静态库</h4><p>需要安装一个 CocoaPods 打包插件 <code>cocoapods-packager</code>。终端执行安装命令：<code>sudo gem install cocoapods-packager</code>，等待安装完成。</p><blockquote><p>cocoapods-packager allows you to generate a framework or static library from a podspec.</p></blockquote><p>执行以下命令，开始打包静态库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod package YJDemoSDK.podspec --library --force --no-mangle --spec-sources=http://*******/yangjie2/snowRepo.git,https://github.com/CocoaPods/Specs.git</span><br><span class="line"># --library 表示打包成.a文件。--force 表示强制覆盖之前存在的文件</span><br><span class="line"></span><br><span class="line">pod package YJDemoSDK.podspec --force --no-mangle --spec-sources=http:*****/yangjie2/snowRepo.git,https://github.com/CocoaPods/Specs.git</span><br><span class="line"># 没有--library，则打包成.framework文件</span><br></pre></td></tr></table></figure><p>–no-mangle，表示Do not mangle symbols of depedendant Pods，当你的项目依赖包含静态库时，不加上这句，就会打包失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] podspec has binary-only depedencies,mangling not possible.</span><br></pre></td></tr></table></figure></p><p>打包完成，生成的静态库放在 pod 库路径下 PODNAME-0.1.0 文件夹中。若是 .a 类型的静态库，是没有头文件的，需要手动将头文件拷贝过来才能正常使用。而 framework 则可以直接放在项目中使用。</p><p><strong>使用含有category的静态库时, selector not recognized的解决方案</strong></p><p>在 iOS/Mac 平台下，包含 Category 的静态库无法被正常加载，原因在于 Category 是 Objective-C 语言的特性，编译器并不会为它生成链接符号，在链接过程中便无法找到该对象文件的引用关系，链接器将会直接忽略掉 Category 对应的对象文件，从而在运行时无法找到相应的 selector。解决该问题的目标就是让链接器加载 Category 对应的对象文件，一种方法是添加编译参数让编译器加载所有的对象文件或是加载指定的对象文件；另一种方法是在 Category 的对象文件中添加 Fake symbol ，当 Fake symbol 被加载时 Category 的对象文件便一同被加载。</p><p>解决方法：</p><p>在编译选项 Other Linker Flags 中添加 -all_load，用于会告诉编译器 对于所有静态库中的所有对象文件，不管里面的符号有没有被用到，全部都载入，这种方法可以解决问题，但是会产生比较大的二进制文件。<br>在编译选项 Other Linker Flags 中添加 -force_load 并指定路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-force_load $(BUILT_PRODUCTS_DIR)/&lt;library_name.a&gt;`</span><br></pre></td></tr></table></figure></p><p>这种方法和 -all_load 类似，不同的是它只载入指定的静态库。</p><p>在编译选项 <code>Other Linker Flags</code> 中添加 <code>-ObjC</code>，这个标识告诉编译器 如果在静态库的对象文件中发现了 Objective-C 代码，就把它载入，Category 中肯定会存在 Objective-C 代码。该方法与前两张类似，只是将加载的范围减少了。<br>另一种解决方法是新版本 Xcode 里 build setting 中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件 master object file）被添加到静态库中。现在如果主对象文件中的任何符号被认为是在使用，整个主对象文件都会被认为在使用，这样它里面的 Objective-C 部分就会被载入了，当然也包括 Category 对应的对象文件。<br>最后一种解决方法是在 Category 的源文件里添加 Fake symbol，并确保以某种方法在编译时引用了该 Fake symbol，这会使得 Fake symbol 对象文件被加载时它里面 Category 代码也会被载入。该方法可以控制哪些 Category 可以被正常加载，同时也不需要添加编译参数做特殊处理。<br>建议使用第五种方法解决问题，因为前 4 种都会增加二进制文件的体积，在第三方集成你的 SDK 时需要手动设置编译参数，会给第三方带来不好的使用体验。为了使用方便可定义一下宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define FIX_CATEGORY_BUG_H(name) \</span><br><span class="line">@interface FIX_CATEGORY_BUG_##name : NSObject \</span><br><span class="line">+(void)print; \</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#define FIX_CATEGORY_BUG_M(name) \</span><br><span class="line">@implementation FIX_CATEGORY_BUG_##name \</span><br><span class="line">+ (void)print &#123;&#125; \</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#define ENABLE_CATEGORY(name) [FIX_CATEGORY_BUG_##name print]</span><br></pre></td></tr></table></figure></p><p>在 Category 的头文件中使用 <code>FIX_CATEGORY_BUG_H()</code> 宏来声明一个 Fake symbol ，在 Category 的实现文件中使用 <code>FIX_CATEGORY_BUG_M()</code> 宏来实现该 Fake symbol。最后在找一处运行 <code>ENABLE_CATEGORY()</code> 宏，可以是初始化方法中，也可以是其他任何地方，只要确保它能被正常调用，目的在于该 Fake symbol 确保编译器能正常加载它。</p><p>在 64 位的 Mac 系统或者 iOS 系统下，链接器有一个 bug，会导致只包含有 Category 的静态库无法使用 -ObjC 标志来加载 Objective-C 对象文件。</p><p>以上就是使用 cocoapods 打包静态库的所有内容了，也许你跟着这个步骤一步步做的时候，会出现意外的错误，不要灰心，用好 google 比什么都重要。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>cocoapods <a href="https://guides.cocoapods.org/" target="_blank" rel="noopener">https://guides.cocoapods.org/</a></p><p>组件化-动态库实战 <a href="http://www.cocoachina.com/ios/20170427/19136.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20170427/19136.html</a></p><p>组件化-动态库实战续 <a href="https://www.valiantcat.cn/index.php/2017/05/15/47.html" target="_blank" rel="noopener">https://www.valiantcat.cn/index.php/2017/05/15/47.html</a></p><p>动态库和静态库的区别 <a href="https://www.zybuluo.com/qidiandasheng/note/603907" target="_blank" rel="noopener">https://www.zybuluo.com/qidiandasheng/note/603907</a></p><p>Pod二进制化 <a href="https://www.zybuluo.com/qidiandasheng/note/595740" target="_blank" rel="noopener">https://www.zybuluo.com/qidiandasheng/note/595740</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们小组需要持续向其他公司或部门提供一套IM（即时通讯）SDK，为了隐藏源码实现，就需要将它打包为静态库（.a/.framework）的形式。该项目使用cocoapods管理，依赖许多私有库，并且私有库又依赖私有库、开源库等，这些私有库又会涉及频繁更新，每次打包静态库时都需要保证是最新的代码，并且还要解决各个库的依赖问题。在这种情况下，怎么才能方便快速的打包静态库呢？幸好 cocoapods 已经给我们提供了一个打包插件:&lt;a href=&quot;https://github.com/CocoaPods/cocoapods-packager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cocoapods-package&lt;/a&gt;，这让打包静态库的任务变得简单许多。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS dev" scheme="https://yangjie2.github.io/categories/iOS-dev/"/>
    
    
      <category term="静态库" scheme="https://yangjie2.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="cocoapods" scheme="https://yangjie2.github.io/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>[C++]虚函数,纯虚函数</title>
    <link href="https://yangjie2.github.io/2018/08/04/C-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://yangjie2.github.io/2018/08/04/C-虚函数-纯虚函数/</id>
    <published>2018-08-04T08:59:23.000Z</published>
    <updated>2018-08-04T09:08:52.074Z</updated>
    
    <content type="html"><![CDATA[<p>参考来源：<a href="https://www.zhihu.com/question/23971699/answer/69592611" target="_blank" rel="noopener">知乎</a></p><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>定义一个函数为虚函数，不代表函数为不被实现的函数。<br>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。<br>定义一个函数为纯虚函数，才代表函数没有被实现。<br>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。举个栗子：</p><a id="more"></a><p>假设我们有下面的类层次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;  </span><br><span class="line">    public:  </span><br><span class="line">        virtual void eat()  </span><br><span class="line">        &#123;  </span><br><span class="line">            cout&lt;&lt;&quot;i eat like animals.&quot;&lt;&lt;endl;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">class Dog:public Animal  </span><br><span class="line">&#123;  </span><br><span class="line">    public:  </span><br><span class="line">        void eat()  </span><br><span class="line">        &#123;  </span><br><span class="line">            cout&lt;&lt;&quot;i eat like a dog.&quot;&lt;&lt;endl;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    Animal *a = new Dog();  </span><br><span class="line">    a-&gt;eat();   // 在这里，a虽然是指向Animal的指针，但是被调函数`eat()`却是`Dog`的! 。</span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。</p><p>它虚就虚在所谓“推迟联编”或者“动态联编”上，函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。虚函数只能借助于指针或者引用来达到多态的效果。</p><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>定义: 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。将函数定义为纯虚函数的方式如下（后面多了个 ＝0 ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual ReturnType Function() = 0;</span><br></pre></td></tr></table></figure><p>引入原因　　<br>1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。　　<br>2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p><p>为了解决上述问题，引入了纯虚函数的概念，<br>只要在基类中定义了纯虚函数，则编译器要求在其派生类中必须予以重写以实现多态性。含有纯虚函数的类称为抽象类，抽象类它不能生成对象。</p><p>这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。纯虚函数最显著的特征是：它们必须在子类中重新声明（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中没有定义。</p><p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。<br>抽象类的定义： 称带有纯虚函数的类为抽象类。<br>抽象类的作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p><p>使用抽象类时注意：<br>• 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。<br>• 抽象类是不能定义对象的。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、纯虚函数声明如下： <code>virtual void funtion1()=0;</code> 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</p><p>2、虚函数声明如下：<code>virtual ReturnType FunctionName(Parameter)；</code> 虚函数必须实现，如果不实现，编译器将报错，错误提示为：<code>error LNK****: unresolved external symbol &quot;public: virtual void __thiscall ClassName::virtualFunctionName(void)&quot;</code></p><p>3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</p><p>4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</p><p>5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。</p><p>6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p><p>7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</p><p>8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。定义纯虚函数就是为了让基类不可实例化化因为实例化这样的抽象数据结构本身并没有意义。或者给出实现也没有意义。实际上我个人认为纯虚函数的引入，是出于两个目的1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。2、为了效率，不是程序执行的效率，而是为了编码的效率。</p><p>最后引用别人的一段生动形象的解释：</p><blockquote><p>上帝是一个程序员，创造了动物(基类)，给予了动物吃饭，睡觉，叫唤等通用功能。(封装)只指定了平均睡觉八小时(虚函数)，其中没有指定具体的吃饭，叫唤的行为。(纯虚函数)然后细分一下，动物有猫狗羊和人。(继承)人类明确它们物种的时候(明确类型的派生类指针)猫吃鱼 狗吃肉 羊吃草猫喵喵 狗汪汪 羊咩咩(多态 同名覆盖)一切都如此顺理成章。突然人发现一只动物！这只是什么呢？诶？这货不知道是啥！只能用”动物”来称呼他！(基类指针指向子类对象)当没有虚函数的时候，人类发现这只动物不会叫也不会吃！因为他根本没有这样的实现！(注意 真正编程上如果派生类不对纯虚函数进行实现将无法通过编译)有了虚函数，让那只动物”吃”，发现他吃草！于是捅一下这只动物，发现它会 哞哞叫！于是得知这是一头牛！可以吃！于是人类就把它吃掉了。总结:虚函数目的是在用基类指针指向派生类的时候还能正确调用派生的实现。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考来源：&lt;a href=&quot;https://www.zhihu.com/question/23971699/answer/69592611&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h4&gt;&lt;p&gt;定义一个函数为虚函数，不代表函数为不被实现的函数。&lt;br&gt;定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。&lt;br&gt;定义一个函数为纯虚函数，才代表函数没有被实现。&lt;br&gt;定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。举个栗子：&lt;/p&gt;
    
    </summary>
    
      <category term="C++ dev" scheme="https://yangjie2.github.io/categories/C-dev/"/>
    
    
      <category term="C++" scheme="https://yangjie2.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从MVVM到ReactiveCocoa</title>
    <link href="https://yangjie2.github.io/2018/08/03/%E4%BB%8EMVVM%E5%88%B0ReactiveCocoa/"/>
    <id>https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/</id>
    <published>2018-08-03T10:28:46.000Z</published>
    <updated>2018-08-04T06:43:52.877Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自 <a href="http://twitter.com/sprynmr" target="_blank" rel="noopener">Bob Spryn</a> 的 <a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/" target="_blank" rel="noopener">ReactiveCocoa and MVVM, an Introduction</a><br>这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>任何有经验的软件开发者都会熟悉 <strong>MVC</strong> 这个概念。它表示 <strong>Model</strong> <strong>View</strong> <strong>Controller</strong> ，是在复杂应用设计中一种久经考验的代码组织方式。在IOS开发中，MVC也被证实具有第二种含义：<strong>Massive View Controller</strong> (笨重的视图控制器) ，这让许多开发者困惑于如何优雅地对代码进行组织和解耦。IOS开发者需要给 view controller 瘦身，这是他们的共识。然而，怎么做呢？</p><a id="more"></a><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>为了解决上面的问题，<strong>MVVM</strong> 应运而生。它表示 <strong>Model</strong> <strong>View</strong> <strong>View-Model</strong> ，它帮助我们创建更易管理、具有良好设计的代码。<br>某些情况下违背Apple建议的编码方式没有多大意义，我不是说不赞成这么做，而是觉得这么做弊大于利。比如我不建议你去实现一个 View Controller 基类并试图自己处理VIew的生命周期。<br>带着这种思想，我不禁提出这样一个问题：使用Apple推荐的MVC之外的设计模式是不明智的吗？<br>不！原因有两点：<br>Apple 没有真正给出解决 <strong>Massive View Controller</strong> 问题的任何指导，他们将更多空间留给我们。MVVM 就是一种很酷的解决方式。</p><p>MVVM 能够与 MVC 很好的兼容，并将 MVC 延展到另一个层次。</p><p>关于 MVC/MVVM 的历史这里不做介绍了，我会更关注它在 iOS 开发中的应用。</p><h2 id="Defining-MVVM"><a href="#Defining-MVVM" class="headerlink" title="Defining MVVM"></a>Defining MVVM</h2><p><strong>Model</strong> - 在 MVVM 中，model 的作用并没有什么特别变化，我们仅把它当做存放数据-模型对象信息的结构体，而在单独的管理类中保留创建/管理model的统一逻辑。</p><p><strong>View</strong> - view中包含真正的UI本身(不管是 UIView 代码，还是 storyboard 和 Xib )、任何与视图有关的特定逻辑以及对用户输入的响应。这包括了许多由 UIViewController 负责处理的工作，不仅仅是UIView代码和文件。</p><p><strong>View-Model</strong> - 这个术语本身就会给我们带来困惑，它由两个我们熟悉的术语组合而成，但完全是不同的东西。它不是传统意义上 data-model 结构中 model 的作用。它的职责之一是作为一个静态模型，为视图展示自身提供必要的数据，但它也有收集、解释、转换这些数据的责任。这留给 View(Controller) 一个更加清晰明确的任务：将 View-Model 提供的数据呈现出来。</p><h2 id="More-about-the-view-model"><a href="#More-about-the-view-model" class="headerlink" title="More about the view-model"></a>More about the view-model</h2><p><strong>view-model</strong> 这个术语不足以描述我们的意图，一个更合适的名字可能是 “<strong>View Coordinator (视图协调器)</strong>”。它从<strong>资源</strong>(database，web service calls，etc)中收集原始数据，应用某种逻辑去处理修改造这些数据，加工成供 view(controller) 界面展示所需的数据。view-model (通常通过属性)仅仅暴露出来 view(controller) 显示所需的信息 (理想情况下不要暴露你的 data-model 对象)。它还负责处理上游数据的修改，比如更新模型/数据库, API POST 调用。</p><p><strong>MVVM in a MVC world</strong><br>在iOS开发中，我觉得 MVVM 这个首字母缩写像 view-model 一样词不达意，让我们再看下它是怎么适应MVC模式的。</p><p><strong>Here is a simple mapping of how these two patterns fit together in iOS:</strong> </p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image1.png" title="[]"><p>说明：</p><ul><li><p>使用图形块的大小粗略的表示它负责的工作量的多少</p></li><li><p>注意看 view controller 部分有多大？</p></li><li><p>巨大的 view controller 和 view-model 之间有大块工作上的重合</p></li><li><p>view controller 和 MVVM 中的 view 也有一大部分的工作是重合的</p></li></ul><p>我们并不是要去除 view controller 这个概念，或者丢掉 “controller” 去匹配 MVVM，我们仅仅是将这部分重合的任务划分到 view-model 中，让 view controller 变得更加简单清晰。</p><p>最终得到的结果用图表示如下：</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image2.png" title="[]"><p>现在，view controller 仅涉及配置和管理各种视图，这些视图的数据都来自 view-model，view controller 也负责在用户有输入动作发生时通知 view-model ，让 view-model 去修改上游数据。view controller 不需要知道有关web service calls, Core Data, model objects 等的一些东西。</p><p>view-model 也是一个对象，它会以一个属性的方式存在于 view controller 中，视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知。你或许已经感觉到这种设计好多了，因为在这里我们对相关工作做了很好的分离。</p><p>下图展示了这种 MVVM 模式下新的应用设计结构：</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image3.png" title="[]"><p>这张图或许能更好的帮助你理解。</p><h2 id="View-Model-and-View-Controller-together-but-separate"><a href="#View-Model-and-View-Controller-together-but-separate" class="headerlink" title="View-Model and View Controller, together but separate"></a>View-Model and View Controller, together but separate</h2><p>举个栗子：为了情节简单, 让我们构建一个简化的twitter客户端，任何使用推特的用户，只要输入用户名，就可以查阅最近的回复。 我们的例子交互和界面如下:</p><ul><li>有一个 <code>UITextField</code>，让用户可以输入名字，一个 “Go” <code>UIbutton</code></li><li>有一个 <code>UIImageView</code>和一个 <code>UILabel</code> ，用于显示当前被查看的用户的头像和姓名</li><li>下面有一个 <code>UITableView</code>，显示最近的推文回复。</li><li>允许无限滚动</li></ul><img src="/2018/08/03/从MVVM到ReactiveCocoa/image4.png" title="[]"><h4 id="The-Example-View-Model"><a href="#The-Example-View-Model" class="headerlink" title="The Example View-Model"></a>The Example View-Model</h4><p>view-model 的头文件如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface MYTwitterLookupViewModel: NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly, getter=isUsernameValid) BOOL usernameValid;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *userFullName;</span><br><span class="line">@property (nonatomic, strong, readonly) UIImage *userAvatarImage;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *tweets;</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL allTweetsLoaded;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readwrite) NSString *username;</span><br><span class="line"></span><br><span class="line">- (void) getTweetsForCurrentUsername;</span><br><span class="line">- (void) loadMoreTweets;</span><br></pre></td></tr></table></figure></p><p>头文件很简单。注意到所有这些壮观的 <strong>readonly</strong>属性了吗？view-model 仅暴露我们的 view controller 需要的最少的信息，而且 view conreoller 不关心 view-model 是怎么得到这些信息的。</p><h4 id="view-model-不做的事情"><a href="#view-model-不做的事情" class="headerlink" title="view-model 不做的事情"></a>view-model 不做的事情</h4><ul><li>通过任何形式直接作用于 view controller，或者直接通知控制器关于自己的一些变化。</li></ul><h4 id="The-Example-View-Controller"><a href="#The-Example-View-Controller" class="headerlink" title="The Example View Controller"></a>The Example View Controller</h4><p>视图控制器使用从 view-model 获取的数据去做:</p><ul><li>当<code>usernameValid</code>值变化时，触发“Go”按钮的<code>enabled</code>属性</li><li>当 <code>usernameValid</code> 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为1.0)</li><li>使用 <code>userFullName</code>更新 UILabel 的文本内容</li><li>使用 <code>userAvatarImage</code>更新 UIImageView 的 image</li><li>使用数组 <code>tweets</code>配置 table view 的 cells</li><li>当滑动到 table view 的底部时，如果 <code>allTweetsLoaded</code>为 NO，提供一个显示“loading”的 cell </li></ul><h4 id="View-Controller将通过如下方式作用于-view-model-："><a href="#View-Controller将通过如下方式作用于-view-model-：" class="headerlink" title="View Controller将通过如下方式作用于 view-model ："></a>View Controller将通过如下方式作用于 view-model ：</h4><ul><li>每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username</li><li>当 “Go” 按钮被按下时，调用 view-model 上的 getTweetsForCurrentUsername 方法</li><li>当到达表格中的 “loading” cell 时，调用 view-model 上的 loadMoreTweets 方法</li></ul><h4 id="view-controller-不做的事情"><a href="#view-controller-不做的事情" class="headerlink" title="view controller 不做的事情"></a>view controller 不做的事情</h4><ul><li>发起网络服务调用</li><li>管理 tweets 数组</li><li>判定 username 内容是否有效</li><li>将用户的姓和名格式化为全名</li><li>下载用户头像并转成 UIImage</li><li>挥洒汗水</li></ul><p><strong>再次注意，视图控制器的总责任是如何处理 view-model 中的变化</strong></p><p>#####Child View-Models<br>上面提到，我们使用 view-model 的 tweets 数组配置表格中的cell。通常你期望用来展示 tweets 的是这些 data-model 对象。但是上面提到，MVVM 模式下，不会暴露 data-model 对象，这时候你正感受到深深的恶意。。。</p><p><strong>不需要仅使用一个 view-model 代表屏幕上展示的所有东西！</strong> 你可以使用 child view-model 表示更小的、潜在的更具封装性的部分：如果某一小块视图(比如 cell)在你的app中可以复用，或者它表示多个 data-model 对象，这么做将会十分有益。</p><p>你并不总是需要 child view-models。比如，我可以使用一个 table header view 来渲染我们的app “tweetboat plus”顶部部分，它不是一个可复用组件，所以我仅需要传入 view controller 使用的那个相同的 view-model 给这个自定义 header view 就可以了。它从那个 veiw-model 中获取自己需要的信息而忽略其他的。这是一个让你的子视图保持同步的特别棒的方法，因为它们都可以有效地使用相同的信息上下文，并观察与更新相同的属性。</p><p>在我们示例app中，<code>tweets</code>数组内放置的是 <strong>子view-model</strong>，大概长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface MYTweetCellViewModel: NSObject</span><br><span class="line"> </span><br><span class="line">@property (nonatomic, strong, readonly) NSString *tweetAuthorFullName;</span><br><span class="line">@property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *tweetContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>你可能会觉得，这个子view-model也太像通常意义的 data-mode 对象了吧？为什么要把它转换成 view-model ？ 尽管很相似，但是 view-model 让我们能够限制信息，仅暴露出我们需要的部分；提供可能转换数据的其他属性；或者为特定视图计算数据 (再说下，一种很好的设计方式是尽可能不要暴露可变的 data-model 对象，因为我们希望 view-model 自己负责修改更新他们，而不是 view 或者 view controler)。</p><h2 id="View-Model-从哪来"><a href="#View-Model-从哪来" class="headerlink" title="View-Model 从哪来?"></a>View-Model 从哪来?</h2><p>那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么?</p><h4 id="View-Model-产生-View-Model"><a href="#View-Model-产生-View-Model" class="headerlink" title="View-Model 产生 View-Model"></a>View-Model 产生 View-Model</h4><p>严格来讲，你应该在 app delegate 中为顶级视图控制器创建一个 view-model。当展示一个新的 view controller 或者一个很小的视图(这个小的视图使用 view-model 表示)时，要让当前的这个 view-model 为你创建需要的 child view-model 。</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image5.png" title="[]"><p>假如我们想要在用户点击应用顶部的头像时，添加一个资料视图控制器，我们可以为当前主 view-model 添加一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser;</span><br></pre></td></tr></table></figure><p>在我们的主控制器中，可以像这样使用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction) didTapPrimaryUserAvatar</span><br><span class="line">&#123;</span><br><span class="line">    MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser];</span><br><span class="line">    </span><br><span class="line">    MYTwitterUserProfileViewController *profileViewController = </span><br><span class="line">        [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel];</span><br><span class="line">    [self.navigationController pushViewController: profileViewController animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我想弹出一个用户资料视图控制器，但是这个控制器需要一个 view-model。我的主控制器并不知道关于这个用户的数据信息，无法创建这个view-model(也不应该要它创建)，所以，我的主控制器让它的 view-model 去做这项苦差事。</p><h4 id="view-model-列表"><a href="#view-model-列表" class="headerlink" title="view-model 列表"></a>view-model 列表</h4><p>回到推特例子中 table view 的 cell，当数据通过网络请求被拿到后，我会特意提前将对应cell的所有view-model创建好。所以在我们这里，主view-model的<code>tweets</code>数组内是<code>MYTweetCellViewModel</code>对象。在 table view 的 <code>cellForRowAtIndexPath</code>方法中，我会简单地在正确的索引位置从<code>tweets</code>数组中抓取子view-model，将它赋值给 cell 的 view-model 属性。</p><h2 id="Functional-Core-Imperative-Shell-函数式内核，命令式外壳"><a href="#Functional-Core-Imperative-Shell-函数式内核，命令式外壳" class="headerlink" title="Functional Core, Imperative Shell (函数式内核，命令式外壳)"></a>Functional Core, Imperative Shell (函数式内核，命令式外壳)</h2><h4 id="Functional-Core-函数式内核"><a href="#Functional-Core-函数式内核" class="headerlink" title="Functional Core(函数式内核)"></a>Functional Core(函数式内核)</h4><p>view-model 就是我们的函数式内核 <a href="http://www.smashingmagazine.com/2014/07/02/dont-be-scared-of-functional-programming/" target="_blank" rel="noopener">“functional core”</a>”，尽管实际上在 iOS/Objective-C 中达到纯函数级别是很棘手的(Swift 提供了一些附加的函数性, 这会让我们更接近)。一般的想法是让 view-model 尽可能少地依赖和影响应用程序的其它部分。这是什么意思？回想一下你刚开始学编程时遇到的简单的函数，它们接受一两个输入参数，并输出一个结果值。<strong>Data in, data out</strong>。也许这个函数做了一些数学计算或者字符串拼接。不管应用程序中发生了什么，相同的输入，就会得到相同的输出。这就是 <font color="#0099ff">函数式 </font>。</p><p>我们使用 view-model ，就是想得到函数式结果。view-model 内部包含逻辑与功能，将数据转换并存储在它的属性中。理想情况下，相同的输入将导致相同的输出结果。这意味着可以尽可能多的消除应用程序的其它部分对输出结果的影响，比如使用大量的状态值。<strong>我们要做的第一步就是在你的view-model的头文件中不要包含UIKit.h</strong>（这是一个很好的原则，但也有一些灰色区域：比如，你可能会将UIImage看作数据，而不是视图（我喜欢这样）。在这种情况下，你需要UIKit.h来获得UIImage类）。UIKit 的性质就决定了它会严重影响应用程序的许多地方，它含有很多副作用，更改一个值或调用一个方法将触发许多间接(甚至不可知)的更改。</p><p><strong>update：</strong>  需要理解你的 view-model 仍然是一个 object，并且的确需要维持一些状态(否则它对你的视图来说就不是一个非常有用的模型了)。但你仍然应该努力将尽可能多的逻辑转移到无状态函数的“值”中(swift 在这方面比 Objective-C 更可行)。</p><h4 id="Imperative-Declarative-Shell（命令式（声明式？）外壳）"><a href="#Imperative-Declarative-Shell（命令式（声明式？）外壳）" class="headerlink" title="Imperative (Declarative?) Shell（命令式（声明式？）外壳）"></a>Imperative (Declarative?) Shell（命令式（声明式？）外壳）</h4><p>我们将 view-model 数据转换成屏幕所显示的东西，需要做一系列工作，比如所有的状态改变，应用内其它部分的改变，命令式外壳就是我们做这些脏活儿累活儿的地方。这就是我们的 view (controller)，我们处理 UIKit 的地方。我依然特别注意尽可能的减少状态变量，将这一系列工作用声明式的方式完成，例如使用ReactiveCocoa。但本质上，iOS和UIKit是命令式的。</p><h4 id="Testable-Core"><a href="#Testable-Core" class="headerlink" title="Testable Core"></a>Testable Core</h4><p>iOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注: mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法)</p><p>这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是变得非常能够进行单元测试. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 现在我们将数据的获取/逻辑/转换从 view controller 中提取出来, 避免了视图控制器的复杂性. 那意味着测试时不需要用疯狂的 mock 对象, method swizzling, 或其他疯癫的变通方法(希望能有)了。</p><h2 id="Connecting-Everything"><a href="#Connecting-Everything" class="headerlink" title="Connecting Everything"></a>Connecting Everything</h2><p>那么，当 view-model 上的公开属性值变化时，我们怎么更新视图呢？</p><p>大多时候，我们使用相应的 view-model 去初始化 view controller，类似在上文见到的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MYTwitterUserProfileViewController *profileViewController =</span><br><span class="line">[[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel];</span><br></pre></td></tr></table></figure></p><p>有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在该 view (controller) 中暴露一个公有可写的 view-model 属性.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYTwitterUserCell *cell =</span><br><span class="line">    [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath];</span><br><span class="line">// grab the cell view-model from the vc view-model and assign it</span><br><span class="line">cell.viewModel = self.viewModel.tweets[indexPath.row];</span><br></pre></td></tr></table></figure></p><p>有时候可以在钩子程序执行前传入 view-model，比如 <code>init</code>或者 <code>viewDidLoad</code>，这样，我们可以使用 view-model 提供的属性值初始化所有UI部件的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">    _viewModel = viewModel;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _goButton.enabled = viewModel.isUsernameValid;</span><br><span class="line">    _goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5;</span><br><span class="line">    // etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很棒！我们已经配置好了初始值。当 view-model 中的数据变化时，怎么更新UI部件的状态？怎么将按钮变为不可用？我们的用户名label和头像将如何被网络请求的结果所填充?</p><p>将 viewcontroller 设置为 view-model 的代理？数据变化时，view-model 发送通知？ 不不不。。</p><p>我们的视图控制器能够知道一些变化的发生。可以使用 <code>UITextfield</code> 的代理方法，通过每次有输入字符变动时检查 view-model ，来更新<code>button</code>的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)textFieldDidChange:(UITextField *)sender &#123;</span><br><span class="line">    // update the view-model</span><br><span class="line">    self.viewModel.username = sender.text;</span><br><span class="line">    // check if things are now valid</span><br><span class="line">    self.goButton.enabled = self.viewModel.isUsernameValid;</span><br><span class="line">    self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 isUsernameValid 值. 假使还有其他变量/动作改变 isUsernameValid 的状态将会怎么样? 对于 view-model 中的网络请求又如何呢?或许我们该为 view-model 中的方法加一个完成后回调处理, 这样我们在那个节点就可以更新 有关UI 的一切东西了?使用古老而笨重的KVO方法？</p><p>最终，我们可以使用我们所熟悉的各种机制来连接 view-model 和 view (controller) 中的所有接触点，但是你知道标题上可不是这么写的。这种方式在代码中创建了大量的入口点，就算是简单的UI更新，也必须完全重新创建应用程序状态的上下文。</p><h2 id="Enter-ReactiveCocoa"><a href="#Enter-ReactiveCocoa" class="headerlink" title="Enter ReactiveCocoa"></a>Enter ReactiveCocoa</h2><p>ReactiveCocoa (RAC) 是来拯救我们的。让我们看看它是怎么做的。</p><p>考虑通过一个新的用户界面来控制信息的流动：该界面在表单有效时更新提交按钮的状态。以下是你目前的工作方式:</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image6.png" title="[]"><p>最终，通过使用状态，谨小慎微地将自己简单的逻辑穿插在众多不同且无关的代码上下文中。看一下信息流中所有不同的入口点，是不是感觉乱糟糟的？(这还仅仅是一个UI元素的逻辑线) 。 我们在编程中使用的这些抽象还不够聪明，不能追踪所有这些事情的联系，所以最终还得自己做这些事儿。</p><h4 id="让我们看下“陈述式”的版本："><a href="#让我们看下“陈述式”的版本：" class="headerlink" title="让我们看下“陈述式”的版本："></a>让我们看下“陈述式”的版本：</h4><img src="/2018/08/03/从MVVM到ReactiveCocoa/image7.png" title="[]"><p>这张图谱记录了我们应用程序的流程。通过这种陈述式编程，我们使用了一种更高级别的抽象，它让我们在实际的编程中，能够更接近我们自己脑海中的思维流。我们让电脑做更多的工作。现在实际的代码与这张图谱显得很接近了。</p><h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p>ReactiveCocoa核心就是 RACSignal。RACSignal (信号)对于 RAC 来说是构造单元。它是一个我们最终将会接收到的承载着信息的对象。<strong>当你有了一个在某个时间点将会收到的信息的具体表示形式时，那就开干吧！运用必要逻辑并预先构建你的信息流(声明式)</strong>，而不是必须等到事件发生时才这么做(响应式)。</p><p><strong>信号会捕获所有的异步方法(委托, 回调 block, 通知, KVO, target/action事件观察者，etc)来控制通过应用程序的信息流，并将他们统一在一个接口下。</strong>不仅如此，它还能够让你轻松的<strong>转换/分解/合并/过滤</strong> 流经你app的信息。</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image8.png" title="[]"><p><strong>那么什么是信号呢，这就是一个信号：</strong></p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image9.png" title="[]"><p>信号是一个发送一连串值的物体。但我们这里的信号什么都没做，因为它还没有任何订阅者。一个RAC信号仅当有订阅者去监听它时，它才会发出信息。它将向订阅者发送0或者载有数值的“next”事件，后面紧跟着一个 “complete” 事件或者一个 “error” 事件。信号不仅限于一次只向它的订阅者发送一个返回值。</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image10.png" title="[]"><p>就像我前面提到的，如果需要的话你可以过滤, 转换, 分解，合并那些值。不同的订阅者可能需要由信号发出的这些数值的不同形式。</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image11.png" title="[]"><h4 id="信号从哪里得到它们发送的值？"><a href="#信号从哪里得到它们发送的值？" class="headerlink" title="信号从哪里得到它们发送的值？"></a>信号从哪里得到它们发送的值？</h4><p>Signals 是一些等待事件发生的异步代码，当事件发生时就向它们的订阅者发送结果值。你可以使用 RACSignal 类中的类方法<br> <code>createSignal:</code> 手动创建这些信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;];</span><br><span class="line">        [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123;</span><br><span class="line">            [subscriber sendNext:result];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure></p><p>上面我创建了一个信号，我使用 RACSignal 提供的 <code>subscriber</code> 对象调用 <code>sendNext:</code> 和 <code>sendCompleted:</code> 方法(请求成功时)，或者调用 <code>sendError:</code>(请求失败时)。现在我可以订阅这个信号并在网络请求返回时接收到 json 值或是 error。</p><p>RAC 为我们提供了丰富的机制来从我们常用的现有异步模式中提取信号。如果你有一个异步任务没有覆盖在内置的信号中，你可以很容易地用 createSignal: 或类似方法来创建信号。</p><p>RAC提供的一个机制就是使用宏 <code>RACObserve()</code>，这个宏是对 KVO 中那些糟透的 API 的替代。你只需要传入一个对象以及在这个对象中你想要监听的属性的名称。给出这些参数后，<code>RACObserve ()</code>会生成一个信号，并立即向它的监听者发送这个属性的当前值，以及未来关于这个属性的任何变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid);</span><br></pre></td></tr></table></figure><img src="/2018/08/03/从MVVM到ReactiveCocoa/image12.png" title="[]"><p>上面仅是创建信号的一种方式，下面有几种现成的从控制流机制中获得信号的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc)</span><br><span class="line">    // subscribeNext:^(UIButton *button) &#123; NSLog(@&quot;%@&quot;, button); // UIButton instance &#125;</span><br><span class="line"></span><br><span class="line">RACSignal *textChange = [myTextField rac_textSignal];</span><br><span class="line">    // some special methods are provided for commonly needed control event values off certain controls</span><br><span class="line">    // subscribeNext:^(UITextField *textfield) &#123; NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; &#125;</span><br><span class="line"></span><br><span class="line">RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal];</span><br><span class="line">    // signals for some delegate methods send the delegate params as the value</span><br><span class="line">    // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc</span><br><span class="line">    // (limited to methods that return void)</span><br><span class="line">    // subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; &#125;</span><br><span class="line"></span><br><span class="line">RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)];</span><br><span class="line">    // signals for arbitrary selectors that return void, send the method params as the value</span><br><span class="line">    // works for built in or your own methods</span><br><span class="line">    // subscribeNext:^(NSNumber *animated) &#123; NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear 1&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>你也能轻松创建自己的信号, 包括<a href="http://spin.atomicobject.com/2014/02/03/objective-c-delegate-pattern/" target="_blank" rel="noopener">替代那些没有内置支持的其他委托</a>。我们现在可以将所有这些断了联系的异步/控制流工具中获得信号，将也可以将它们组合在一起，想想这是多么酷的事情！这些信号会成为上面看到的陈述式图谱中的nodes节点，开心吧。</p><h4 id="什么是订阅者？"><a href="#什么是订阅者？" class="headerlink" title="什么是订阅者？"></a>什么是订阅者？</h4><p>简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了(它也可以作用于 “complete” 和 “error” 事件)。<br><strong>再次注意，订阅者就是一段代码，而不是一个具体的对象。</strong></p><p>下面是一个简单的 subscriber，通过向信号的实例方法 <code>subscribeNext :</code> 传入一个 block 创建的。这里我们正在通过 RACObserve() 宏创建的这个信号，观察一个对象的某个属性的当前值, 并把这个属性值赋给一个内部属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">  // ...</span><br><span class="line">  // create and get a reference to the signal</span><br><span class="line">  RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid);</span><br><span class="line">  // update the local property when this value changes</span><br><span class="line">  [usernameValidSignal subscribeNext:^(NSNumber *isValidNumber) &#123;</span><br><span class="line">          self.usernameIsValid = isValidNumber.boolValue</span><br><span class="line">      &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意 ：RAC 只处理对象, 而不处理像 BOOL 这样的原始值。 不过不用担心, RAC 通常会帮你处理这些转换。</p><p>RAC 作者也意识到这种绑定行为的普遍必要性。所以他们提供了另一个宏定义：<code>RAC()</code>。与 <code>RACObserve()</code> 类似，你提供一个对象和这个对象的属性名参数，传入的值就会绑定到这个对象的这个参数上。这个宏定义在内部就是做了上面 viewDidLoad 方法中的工作：创建订阅者，更新属性值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    //...</span><br><span class="line">    RAC(self, usernameIsValid) = RACObserve(self.viewModel, isUsernameValid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但考虑到我们的目的，这样做有点傻冒。我们并不真的需要将信号中的值存储到一个属性中(也会因此创建状态)，我们真正想做的是用从这个值中收集的信息来更新UI。</p><h4 id="转换数据流"><a href="#转换数据流" class="headerlink" title="转换数据流"></a>转换数据流</h4><p>现在我们开始看 RAC 为我们提供的转换数据流的值的方法。我们会用到 <code>RACSignal</code> 类提供的 <code>map</code> 实例方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    //...</span><br><span class="line">    RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);</span><br><span class="line">    RAC(self.goButton, enabled) = usernameIsValidSignal;</span><br><span class="line">    RAC(self.goButton, alpha) = [usernameIsValidSignal</span><br><span class="line">        map:^id(NSNumber *usernameIsValid) &#123;</span><br><span class="line">            return usernameIsValid.boolValue ? @1.0 : @0.5;</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们将 view-model 上的 <code>isUsernameValid</code> 属性所发生的更改直接绑定到 goButton 上的 <code>enabled</code>属性上。绑定 goButton 按钮的 <code>alpha</code> 属性显得更让人兴奋，因为我们使用 <code>map</code> 方法将信号的值转换成 <code>alpha</code> 属性的值。</p><h4 id="多个订阅者-副作用-昂贵的操作"><a href="#多个订阅者-副作用-昂贵的操作" class="headerlink" title="多个订阅者, 副作用, 昂贵的操作"></a>多个订阅者, 副作用, 昂贵的操作</h4><p>在订阅信号链时，你应当认识到这样一件非常重要的事，<strong>每当一个新值通过该信号链发送时，它实际上是每一个订阅者都会发送一次。</strong> 比如新增了一个订阅者去监听一个信号，那么信号会立即向订阅者发送信息，注意是所有订阅者！而不仅仅是你刚才新增的那个。信号发送出的信息(值)不会存储在任何地方(除了RAC的内部实现部分)，认识到这一点对我们来说是有意义的。当信号需要发送一个新的值时，它会遍历所有的订阅者，并给每个订阅者发送那个值。</p><p>这就意味着在你信号链的某处产生的任何副作用，任何影响应用程序世界的转换，都会多次发生。对于刚开始使用RAC的用户来说，这是意料之外的(这也违背了“函数式”思想—相同的输入，产生相同的输出)。</p><p>举个蹩脚的例子：有一个按钮点击事件信号，它会在信号链的某个地方更新一个计数属性，如果有多个订阅者监听了这个信号链，这个计数属性的增长比你想象的还要多。你需要从信号链中尽可能的剔除副作用，当副作用不可避免时, 你可以使用一些恰当的预防机制，我将会在另一篇文章中讨论。</p><p>除了副作用以外，你需要特别注意带有代价昂贵的操作和可变数据的信号链。网络请求是一个兼有以下三点的例子：</p><ol><li>网络请求影响你的 app 的网络层(副作用).</li><li>网络请求给信号链带来了可变数据. (两个完全一样请求可能返回了不同的数据)</li><li>网络请求反应慢</li></ol><p>例如，你有一个信号，每次点击按钮，信号就会发送一个值，你想转换这个值，并用转换结果进行网络请求从而得到请求结果。如果有多个订阅者要处理这个信号链返回的值，你将会发起多次网络请求。</p><img src="/2018/08/03/从MVVM到ReactiveCocoa/image13.png" title="[]"><p>显然网络请求是经常需要的，如你所想，RAC 为这种情况提供了解决方案：RACCommand 和多点广播。我将在下一篇文章中深入讨论。</p><h2 id="Tweetboat-Plus"><a href="#Tweetboat-Plus" class="headerlink" title="Tweetboat Plus"></a>Tweetboat Plus</h2><p>简短的介绍之后，现在我们着手怎么将 view-model 和 view controller 使用 ReactiveCocoa 联系起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// View Controller</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    RAC(self.viewModel, username) = [myTextfield rac_textSignal];</span><br><span class="line"></span><br><span class="line">    RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid);</span><br><span class="line"></span><br><span class="line">    RAC(self.goButton, alpha) = [usernameIsValidSignal</span><br><span class="line">        map: ^(NSNumber *valid) &#123;</span><br><span class="line">            return valid.boolValue ? @1 : @0.5;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    RAC(self.goButton, enabled) = usernameIsValidSignal;</span><br><span class="line"></span><br><span class="line">    RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage);</span><br><span class="line">    </span><br><span class="line">    RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName);</span><br><span class="line"></span><br><span class="line">    @weakify(self);</span><br><span class="line">    [[[RACSignal merge:@[RACObserve(self.viewModel, tweets),</span><br><span class="line">                        RACObserve(self.viewModel, allTweetsLoaded)]]</span><br><span class="line">        bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]]</span><br><span class="line">        subscribeNext:^(id value) &#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            [self.tableView reloadData];</span><br><span class="line">        &#125;];</span><br><span class="line">    </span><br><span class="line">    [[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">        subscribeNext: ^(id value) &#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            [self.viewModel getTweetsForCurrentUsername];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    // if table section is the tweets section</span><br><span class="line">    if (indexPath.section == 0) &#123;</span><br><span class="line">        MYTwitterUserCell *cell =</span><br><span class="line">        [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath];</span><br><span class="line">        </span><br><span class="line">        // grab the cell view model from the vc view model and assign it</span><br><span class="line">        cell.viewModel = self.viewModel.tweets[indexPath.row];</span><br><span class="line">        return cell;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // else if the section is our loading cell</span><br><span class="line">        MYLoadingCell *cell =</span><br><span class="line">        [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath];</span><br><span class="line">        [self.viewModel loadMoreTweets];</span><br><span class="line">        return cell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// MYTwitterUserCell</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// this could also be in cell init</span><br><span class="line">- (void) awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">    </span><br><span class="line">    RAC(self.avatarImageView, image) = RACObserve(self, viewModel.tweetAuthorAvatarImage);</span><br><span class="line">    RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName);</span><br><span class="line">    RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让我们来分析下上面的这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.viewModel, username) = [myTextfield rac_textSignal];</span><br></pre></td></tr></table></figure><p>这里使用RAC提供的方法，从 <code>UITextField</code> 中得到一个信号。上面这行代码将 view-model 的可读写属性 <code>username</code> 绑定到 textfield 的任何更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid);</span><br><span class="line"></span><br><span class="line">RAC(self.goButton, alpha) = [usernameIsValidSignal</span><br><span class="line">    map: ^(NSNumber *valid) &#123;</span><br><span class="line">        return valid.boolValue ? @1 : @0.5;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RAC(self.goButton, enabled) = usernameIsValidSignal;</span><br></pre></td></tr></table></figure><p> 这里我们使用宏 <code>RACObserve()</code> 在 view-model 的 <code>usernameValid</code> 属性上创建一个信号 <code>usernameIsValidSignal</code>，不管什么时候只要这个属性值有变化，这个信号就会沿着管道(pipe)发送一个新的 @YES 或 @NO 值。我们将这个值绑定到 <code>goButton</code> 的两个属性上。</p><p>接着，通过使用宏 <code>RACObserve</code> 在对应的 view-model 属性上创建信号，为 table view 表头的 image view 和 user label 创建绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage);</span><br><span class="line"></span><br><span class="line">RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName);</span><br></pre></td></tr></table></figure></p><p>下面这段代码看起来有点棘手，所以让我们多花点时间在这里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[[[RACSignal merge:@[RACObserve(self.viewModel, tweets),</span><br><span class="line">                     RACObserve(self.viewModel, allTweetsLoaded)]]</span><br><span class="line">    bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]]</span><br><span class="line">    subscribeNext:^(id value) &#123;</span><br><span class="line">        @strongify(self);</span><br><span class="line">        [self.tableView reloadData];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p><p> 我们希望在 view-model 里的 <code>tweets</code> 数组和 <code>allTweetsLoaded</code> 属性发生变化时就能立刻更新 table view。所以我们将观察这两个属性的信号两个信号合并成一个“大信号”，这样，当这两个属性有任何一个变化时，这个合并后的大信号就会发送一个值 (通常你希望信号的值是同类型的，而不是像这个信号那样混合着其他类型值。这可能会在 RAC swift 强制执行，但这里我们不关心发送的实际值，我们只是用它来触发 table view 的重新加载)。</p><p>所以这里有点吓人的部分可能是 <code>bufferWithTime:onScheduler:</code> 方法，这么做是为了解决 UIKit 中的一个问题。我们需要同时追踪 <code>tweets</code> 和 <code>allTweetsLoaded</code> 这两个属性，目的是为了防止其中一个发生变化而另一个没有变(有一个属性变化，就需要更新 table view)。问题是，有时这两个属性碰巧会在同一时间点发生变化，这意味着，合并产生的大信号中的两个小信号都将发送一个值，那么<code>reloadData</code> 将在同一个 run loop 中被连续调用两次。UIKit 不喜欢这样。<code>bufferWithTime:</code> 捕获任何在给定时间内发送过来的下一个值，当这段时间过去以后，再将这些值一并发送给订阅者。通过传入参数 0 ，<code>bufferWithTime:</code>方法将捕获在一个 run-loop 时间内由“大信号”发出的所有值，然后再将这些值一起发出去。别担心，就把它当做需要将这些值必须在主线程上传递。现在我们能够确保 <code>reloadData</code> 方法在每个run-loop 内只执行一次。<br><strong>注意</strong>：我们用到了 <code>@weakify/@strongify</code> 宏，这对打破循block引起的环引用非常重要。</p><p>下面这段代码展示出 <code>RACCommand</code> 将会发挥作用的地方，将在下一篇文章中介绍。就目前来说，当按钮被点击时，我们只是手动调用 view-model 的 <code>getTweetsForCurrentUsername</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">    subscribeNext: ^(id value) &#123;</span><br><span class="line">        @strongify(self);</span><br><span class="line">        [self.viewModel getTweetsForCurrentUsername];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p><p>我们已经介绍了<code>cellForRowAtIndexPath</code> 的第一部分，所以这里只说下 loading cell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYLoadingCell *cell =</span><br><span class="line">[self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath];</span><br><span class="line">[self.tableView loadMoreTweets];</span><br><span class="line">return cell;</span><br></pre></td></tr></table></figure></p><p>这是将来我们使用 <code>RACCommand</code> 的另一个领域。现在我们只是调用 view-model 中的 <code>loadMoreTweets</code>方法。我们相信，如果 cell 隐藏并显示了多次，view-model 可以在内部避免多次调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void) awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line"></span><br><span class="line">    RAC(self.avatarImageView, image) = RACObserve(self, viewModel.userAvatarImage);</span><br><span class="line">    RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName);</span><br><span class="line">    RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This should be fairly straightforward now, aside from one thing I want to point out. We are binding an image and strings to the appropriate properties on our UI, but note that viewModel is on the right side of the comma in the RACObserve macro. These cells will end up getting reused and new view-models will be assigned. Instead of listening for the viewModel property to change and then re-setting up our bindings everytime, if we put viewModel on the right side of the comma, RACObserve is going to take care of that for us. So we only set up this binding ONCE and let Reactive Cocoa do the rest. This is a good thing to keep in mind for performance with bindings on table cells. In practice I’ve had no issues even with lots of table cells screaming around.</p><h4 id="额外的好处——消除更多的状态"><a href="#额外的好处——消除更多的状态" class="headerlink" title="额外的好处——消除更多的状态"></a>额外的好处——消除更多的状态</h4><p>有时候你在 view-model 中暴露出 <code>RACSignal</code> 而不是一些属性值会帮你消除 view-model 上更多的状态。这样，你的 view (controller) 就可以直接使用这些信号，而不必使用 <code>RACObserve</code>创建它自己的信号了。<strong>注意：如果在 UI 订阅/绑定这个信号之前，它就已经发送了一个值，那么你就会错过这个“初始”的值。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这是一种不同的编程风格，它为你提供了另一种与“命令式”完全不同的思路。即使你一开始并不会经常使用这种方式，但它仍然告诉你，有这样一位姑娘(RAC) 可以用她特有的方式为你解决困惑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自 &lt;a href=&quot;http://twitter.com/sprynmr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bob Spryn&lt;/a&gt; 的 &lt;a href=&quot;http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReactiveCocoa and MVVM, an Introduction&lt;/a&gt;&lt;br&gt;这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。&lt;/p&gt;
&lt;h2 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h2&gt;&lt;p&gt;任何有经验的软件开发者都会熟悉 &lt;strong&gt;MVC&lt;/strong&gt; 这个概念。它表示 &lt;strong&gt;Model&lt;/strong&gt; &lt;strong&gt;View&lt;/strong&gt; &lt;strong&gt;Controller&lt;/strong&gt; ，是在复杂应用设计中一种久经考验的代码组织方式。在IOS开发中，MVC也被证实具有第二种含义：&lt;strong&gt;Massive View Controller&lt;/strong&gt; (笨重的视图控制器) ，这让许多开发者困惑于如何优雅地对代码进行组织和解耦。IOS开发者需要给 view controller 瘦身，这是他们的共识。然而，怎么做呢？&lt;/p&gt;
    
    </summary>
    
      <category term="iOS dev" scheme="https://yangjie2.github.io/categories/iOS-dev/"/>
    
    
      <category term="ReactiveCocoa" scheme="https://yangjie2.github.io/tags/ReactiveCocoa/"/>
    
      <category term="MVVM" scheme="https://yangjie2.github.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>IM消息的可靠投递</title>
    <link href="https://yangjie2.github.io/2018/07/06/IM%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92/"/>
    <id>https://yangjie2.github.io/2018/07/06/IM消息的可靠投递/</id>
    <published>2018-07-06T11:33:22.000Z</published>
    <updated>2018-07-10T04:05:56.461Z</updated>
    
    <content type="html"><![CDATA[<h4 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h4><p>im的客户端与服务器通过发送报文（也就是网络包）来完成消息的传递，报文分为三种：<br>请求报文（request，后简称为为R）<br>应答报文（acknowledge，后简称为A）<br>通知报文（notify，后简称为N），这三种报文的解释如下：</p><img src="/2018/07/06/IM消息的可靠投递/image1.png"><p>R：客户端主动发送给服务器的报文<br>A：服务器被动应答客户端的报文，一个A对应一个R<br>N：服务器主动发送给客户端的报文</p><a id="more"></a><h4 id="普通消息投递流程"><a href="#普通消息投递流程" class="headerlink" title="普通消息投递流程"></a>普通消息投递流程</h4><p>用户A给用户B发送一个“你好”，流程如下：</p><img src="/2018/07/06/IM消息的可靠投递/image2.png" title="[]"><p>1）client-A向im-server发送一个消息请求包，即msg:R<br>2）im-server在成功处理后，回复client-A一个消息响应包，即msg:A<br>3）如果此时client-B在线，则im-server主动向client-B发送一个消息通知包，即msg:N（当然，如果client-B不在线，则消息会存储离线）</p><h4 id="上述消息投递流程出现的问题"><a href="#上述消息投递流程出现的问题" class="headerlink" title="上述消息投递流程出现的问题"></a>上述消息投递流程出现的问题</h4><p>从流程图中容易看到，发送方client-A收到msg:A后，只能说明im-server成功接收到了消息，并不能说明client-B接收到了消息。在若干场景下，可能出现msg:N包丢失，且发送方client-A完全不知道，例如：<br>1）服务器崩溃，msg:N包未发出<br>2）网络抖动，msg:N包被网络设备丢弃<br>3）client-B崩溃，msg:N包未接收结论是悲观的：接收方client-B是否有收到msg:N，发送方client-A完全不可控，那怎么办呢？</p><h4 id="应用层确认-im消息可靠投递的六个报文"><a href="#应用层确认-im消息可靠投递的六个报文" class="headerlink" title="应用层确认+im消息可靠投递的六个报文"></a>应用层确认+im消息可靠投递的六个报文</h4><p>upd是一种不可靠的传输层协议，tcp是一种可靠的传输层协议，tcp是如何做到可靠的？<br>答案是：超时、重传、确认<br>要想实现应用层的消息可靠投递，必须加入应用层的确认机制，即：<br>要想让发送方client-A确保接收方client-B收到了消息，必须让接收方client-B给一个消息的确认，这个应用层的确认的流程，与消息的发送流程类似：</p><img src="/2018/07/06/IM消息的可靠投递/image3.png" title="[]"><p>4）client-B向im-server发送一个ack请求包，即ack:R<br>5）im-server在成功处理后，回复client-B一个ack响应包，即ack:A<br>6）则im-server主动向client-A发送一个ack通知包，即ack:N<br>至此，发送“你好”的client-A，在收到了ack:N报文后，才能确认client-B真正接收到了“你好”。</p><p>会发现，一条消息的发送，分别包含（上）（下）两个半场，即msg的R/A/N三个报文，ack的R/A/N三个报文，一个应用层即时通讯消息的可靠投递，共涉及6个报文，这就是im系统中消息投递的最核心技术。</p><h4 id="可靠消息投递存在什么问题"><a href="#可靠消息投递存在什么问题" class="headerlink" title="可靠消息投递存在什么问题"></a>可靠消息投递存在什么问题</h4><p>期望六个报文完成消息的可靠投递，但实际情况，msg:N，ack:N这两个报文都可能丢失（原因如第二章所述，可能是服务器奔溃、网络抖动、或者客户端奔溃），此时client-A都收不到期待的ack:N报文，即client-A不能确认client-B是否收到“你好”，但这两个报文的丢失对应的业务影响又大有不同：<br>1）msg:N包丢失，业务结果是client-B没有收到消息<br>2）ack:N包丢失，业务结果是client-B收到了消息，只是client-A不知道而已<br>那怎么办呢？</p><h4 id="消息的超时与重传"><a href="#消息的超时与重传" class="headerlink" title="消息的超时与重传"></a>消息的超时与重传</h4><p>client-A发出了msg:R，收到了msg:A之后，在一个期待的时间内，如果没有收到ack:N，client-A会尝试将msg:R重发。可能client-A同时发出了很多消息，故client-A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到ack:N，以定时重发。</p><img src="/2018/07/06/IM消息的可靠投递/image4.png" title="[]"><p>一旦收到了ack:N，说明client-B收到了“你好”消息，对应的消息将从“等待ack队列”中移除。</p><h4 id="消息的重传存在什么问题"><a href="#消息的重传存在什么问题" class="headerlink" title="消息的重传存在什么问题"></a>消息的重传存在什么问题</h4><p>上面第五部分提到过，msg:N，ack:N都有可能丢失：<br>1）msg:N报文丢失，说明client-B之前压根没有收到“你好”报文，超时与重传机制十分有效<br>2）ack:N报文丢失，说明client-B之前已经收到了“你好”报文（只是client-A不知道而已），超时与重传机制将导致client-B收到重复的消息，那就需要进行消息的去重。</p><h4 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h4><p>解决方法也很简单，由发送方client-A生成一个消息去重的msgid，保存在“等待ack队列”里，同一条消息使用相同的msgid来重传，供client-B去重，而不影响用户体验。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>1）上述设计理念，由客户端重传，可以保证服务端无状态性（架构设计基本准则）<br>2）如果client-B不在线，im-server保存了离线消息后，要伪造ack:N发送给client-A</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1）im系统是通过超时、重传、确认、去重的机制来保证消息的可靠投递，不丢不重<br>2）一个“你好”的发送，包含上半场 msg:R/A/N 与下半场 ack:R/A/N 的6个报文<br>3）im系统难以做到系统层面的不丢不重，只能做到业务层面的不丢不重</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;报文类型&quot;&gt;&lt;a href=&quot;#报文类型&quot; class=&quot;headerlink&quot; title=&quot;报文类型&quot;&gt;&lt;/a&gt;报文类型&lt;/h4&gt;&lt;p&gt;im的客户端与服务器通过发送报文（也就是网络包）来完成消息的传递，报文分为三种：&lt;br&gt;请求报文（request，后简称为为R）&lt;br&gt;应答报文（acknowledge，后简称为A）&lt;br&gt;通知报文（notify，后简称为N），这三种报文的解释如下：&lt;/p&gt;
&lt;img src=&quot;/2018/07/06/IM消息的可靠投递/image1.png&quot;&gt;
&lt;p&gt;R：客户端主动发送给服务器的报文&lt;br&gt;A：服务器被动应答客户端的报文，一个A对应一个R&lt;br&gt;N：服务器主动发送给客户端的报文&lt;/p&gt;
    
    </summary>
    
      <category term="IM" scheme="https://yangjie2.github.io/categories/IM/"/>
    
    
      <category term="IM" scheme="https://yangjie2.github.io/tags/IM/"/>
    
      <category term="消息" scheme="https://yangjie2.github.io/tags/%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>Masonry布局控件frame为0的问题</title>
    <link href="https://yangjie2.github.io/2018/07/06/Masonry%E5%B8%83%E5%B1%80%E6%8E%A7%E4%BB%B6frame%E4%B8%BA0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yangjie2.github.io/2018/07/06/Masonry布局控件frame为0的问题/</id>
    <published>2018-07-06T11:12:22.000Z</published>
    <updated>2018-07-06T11:29:46.035Z</updated>
    
    <content type="html"><![CDATA[<p>Masonry 是对 autolayout 的封装，优雅的链式语法和简洁易用的接口让我们在做UI开发时节省了不少时间。然而在初次使用它时，由于还对 autolayout 理解不够深，就遇到了一些问题，比如使用 Masonry 对控件添加约束后，并不会立即生效，frame 仍然是 0。如果此时我们需要这个 frame，应该怎么做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIView *parent = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">UIImageView *child = [UIView alloc] init];</span><br><span class="line">[parent addSubview:child];</span><br><span class="line">[child mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(20,20));</span><br><span class="line">        make.top.left.mas_equalTo(50);</span><br><span class="line">    &#125;];</span><br><span class="line">NSLog(@&quot;%@&quot;,redView);</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">** &lt;UIImageView: 0x7fb222605550; frame = (0 0; 0 0); layer = &lt;CALayer: 0x7fb22260b3a0&gt;&gt;**</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用 Masonry 添加约束后，如果有要设置 child 的形状为圆形，就得知道它的 frame，像下面这样写肯定不会设置成功的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[child mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(20,20));</span><br><span class="line">        make.top.left.mas_equalTo(50);</span><br><span class="line">    &#125;];</span><br><span class="line"> child.layer.cornerRadius = child.bounds.size.width/2;</span><br><span class="line"> child.layer.masksToBounds = YES; //设置头像为圆形</span><br></pre></td></tr></table></figure><p>因为这时候的 frame 还是 0。曾天真的想，会不会是因为 block 中的处理是在异步线程进行的，不会等待 block 执行完就已经走到了下面使用frame的代码，(一阵狂喜，好聪明。。。)，所以马上把代码改写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[child mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(20,20));</span><br><span class="line">        make.top.left.mas_equalTo(50);</span><br><span class="line">        child.layer.cornerRadius = child.bounds.size.width/2;</span><br><span class="line">        child.layer.masksToBounds = YES; //设置头像为圆形</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>然而并没有什么卵用。</p><p>想不通的时候，就只能请教 goole 了，然后找到了 Masonry 约束下获取 frame 的方法</p><p>masonry 本就是对 autolayout 的封装，使用 Masonry 就等于使用了苹果的 autolayout。使用 masonry 布局完之后，系统会在某个时间点调用各个 view 的 <code>layoutSubViews</code> 方法，从而更新各个控件的<code>frame</code>。遗憾的是，frame 的更新并不会在刚执行完 Masonry 布局代码时立即进行，在布局代码的下一行，你所获取到的 frame 仍然是0。</p><p>想要在布局代码结束就立即获取当前某个控件正确的 frame，需要调用layoutIfNeeded函数立即刷新布局，各个控件才会按照约束条件，生成当前布局相应的frame和bounds。而调用layoutIfNeeded的目的是让系统调用layoutSubviews方法，我们也可以直接在这个方法里获取frame，因为这时候开始layout subviews，Masonry已经计算出了真实的frame。</p><p>下面附上关于autolayout更新几个方法的区别：</p><ol><li><p>setNeedsLayout：标记页面需要更新，但是什么时候才会调用<br>layoutSubviews 去刷新布局，就不一定了。</p></li><li><p>layoutIfNeeded：告知页面如果需要，就立刻更新布局。这里的“如果需要”什么意思呢？有什么条件吗？是的，只有满足如下某一个或几个条件，调用 layoutIfNeeded 才会立即刷新frame：</p></li></ol><ul><li>有 addSubview 操作</li><li>设置了view的 frame，当然前提是设置前后 frame 的值发生了变化</li><li>滚动一个UIScrollView</li><li>旋转 Screen</li><li>改变一个UIView大小的时候</li></ul><p>如果不满足，就算是调用了 layoutIfNeeded 也不会立刻执行 layoutSubViews 进行 frame 更新。</p><p>如果我们想不管什么情况，都强制执行 layoutSubViews 进行 frame 更新怎么办呢？那就是同时调用下面这两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self setNeedsLayout];</span><br><span class="line">[self layoutIfNeeded];</span><br></pre></td></tr></table></figure></p><p>这样必然会调用 layoutSubViews 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Masonry 是对 autolayout 的封装，优雅的链式语法和简洁易用的接口让我们在做UI开发时节省了不少时间。然而在初次使用它时，由于还对 autolayout 理解不够深，就遇到了一些问题，比如使用 Masonry 对控件添加约束后，并不会立即生效，frame 仍然是 0。如果此时我们需要这个 frame，应该怎么做呢？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIView *parent = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIImageView *child = [UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[parent addSubview:child];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[child mas_makeConstraints:^(MASConstraintMaker *make) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.size.mas_equalTo(CGSizeMake(20,20));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.top.left.mas_equalTo(50);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;,redView);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;打印结果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;** &amp;lt;UIImageView: 0x7fb222605550; frame = (0 0; 0 0); layer = &amp;lt;CALayer: 0x7fb22260b3a0&amp;gt;&amp;gt;**&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS dev" scheme="https://yangjie2.github.io/categories/iOS-dev/"/>
    
    
      <category term="iOS" scheme="https://yangjie2.github.io/tags/iOS/"/>
    
      <category term="Masonry" scheme="https://yangjie2.github.io/tags/Masonry/"/>
    
      <category term="auto layout" scheme="https://yangjie2.github.io/tags/auto-layout/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发琐碎知识点</title>
    <link href="https://yangjie2.github.io/2018/07/06/iOS%E5%BC%80%E5%8F%91%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yangjie2.github.io/2018/07/06/iOS开发琐碎知识点/</id>
    <published>2018-07-06T10:12:09.000Z</published>
    <updated>2018-08-06T04:18:27.161Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个半路出家的小白、一个为了生活不断积累技术知识的俗人，本着急功近利的的精神把工作中遇到的小问题、琐碎知识点总结下来留给我闺女。<br>…<br>…</p><a id="more"></a><h4 id="1-bringSubViewToFront-不起作用的问题"><a href="#1-bringSubViewToFront-不起作用的问题" class="headerlink" title="1. bringSubViewToFront 不起作用的问题"></a>1. bringSubViewToFront 不起作用的问题</h4><img src="/2018/07/06/iOS开发琐碎知识点/issue1_1.png" title="[bringSubViewToFront 不起作用]"><p>bringSubViewToFront方法只对该view的childView起作用，而对grandView不起作用，可以用上面的方法，把grandView前置。</p><p>最近项目中遇到一个坑，有一个父view，该父view中添加了第三方SDK中的view，所以没有准确判断view的层级关系，导致我添加的一个label无论怎样调用bringSubViewToFront都无法显示在最前面。后来发现原因是，我的label添加后，调用bringSubViewToFront过早，因为这个时候第三方view还没加载上去，所以调用bringSubViewToFront也不会将label显示在第三方veiw的前面。要在第三方view加载完成后，才会起作用。</p><p>总结：bringSubViewToFront方法只会将某个view放在其父view的所有已存在的子view的前面。后来添加的view依然有可能遮挡住这个view.</p><h4 id="2-强制某个-viewController-横屏竖屏"><a href="#2-强制某个-viewController-横屏竖屏" class="headerlink" title="2. 强制某个 viewController 横屏竖屏"></a>2. 强制某个 viewController 横屏竖屏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*方法*/</span><br><span class="line">- (void)interfaceOrientation:(UIInterfaceOrientation)orientation</span><br><span class="line">&#123;</span><br><span class="line">  if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)])  &#123;</span><br><span class="line"></span><br><span class="line">      SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;);</span><br><span class="line"></span><br><span class="line">      NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class="line"></span><br><span class="line">      [invocation setSelector:selector];</span><br><span class="line"></span><br><span class="line">      [invocation setTarget:[UIDevice currentDevice]];</span><br><span class="line"></span><br><span class="line">      int val  = orientation;</span><br><span class="line"></span><br><span class="line">      [invocation setArgument:&amp;val atIndex:2];</span><br><span class="line"></span><br><span class="line">      [invocation invoke];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 横屏</span><br><span class="line">- (IBAction)landscapAction:(id)sender &#123;</span><br><span class="line">    [self interfaceOrientation:UIInterfaceOrientationLandscapeRight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 竖屏</span><br><span class="line">- (IBAction)portraitAction:(id)sender &#123;</span><br><span class="line">    [self interfaceOrientation:UIInterfaceOrientationPortrait];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-nib-文件加载过程"><a href="#3-nib-文件加载过程" class="headerlink" title="3. nib 文件加载过程"></a>3. nib 文件加载过程</h4><blockquote><p>Outlets are set after -init and before -awakeFromNib. If you want to access outlets, you need to do that in -awakeFromNib or another method that’s executed after the outlets are set (e.g. -[NSWindowController windowDidLoad]).</p></blockquote><p>When a nib file is loaded:</p><ol><li>Objects in the nib file are allocated/initialised, receiving either -init, -initWithFrame:, or -initWithCoder:</li><li>All connections are reestablished. This includes actions, outlets, and bindings.</li><li>-awakeFromNib is sent to interface objects, file’s owner, and proxy objects.</li></ol><h4 id="4-table-view-优化"><a href="#4-table-view-优化" class="headerlink" title="4. table view 优化"></a>4. table view 优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. cell 复用</span><br><span class="line">2. view 的opaque属性尽可能设置为 YES</span><br><span class="line">3. 避免渐变、图像伸缩、离屏渲染</span><br><span class="line">4. 如果cell高度不变，缓存计算出的高度</span><br><span class="line">5. 如果cell展示的内容包含网络请求的内容，缓存并且异步加载</span><br><span class="line">6. 阴影用shadow path</span><br><span class="line">7. 尽可能减少cell的subviews数量</span><br><span class="line">8. 在cellForRowAtIndexPath回调中尽可能少做事，如果必须，尽可能缓存耗时操作的结果</span><br><span class="line">9. 抽象出合理的数据结构来展示信息</span><br><span class="line">10.直接设置rowHeight、sectionFooterHeight、sectionHeaderHeight的值，不要在相应的代理中设置</span><br></pre></td></tr></table></figure><h4 id="5-xib-中使用-autolayout-布局"><a href="#5-xib-中使用-autolayout-布局" class="headerlink" title="5. xib 中使用 autolayout 布局"></a>5. xib 中使用 autolayout 布局</h4><p>关于 xib 中使用 autolayout 布局的问题，下面两张图应该说明的很明白了。</p><img src="/2018/07/06/iOS开发琐碎知识点/issue5_1.png" title="[]"><img src="/2018/07/06/iOS开发琐碎知识点/issue5_2.png" title="[]"><h4 id="6-使用-setValue-forKey-设置对象属性值"><a href="#6-使用-setValue-forKey-设置对象属性值" class="headerlink" title="6. 使用 setValue:forKey:设置对象属性值"></a>6. 使用 setValue:forKey:设置对象属性值</h4><p>在使用 setValue:forKey: 设置对象属性值时，不管该属性是否为只读的、不管在 .h 或者 .m 文件中，都能够成功设置！ 果如你重写了这个属性的 setter 方法，那么也会走该属性的 setter 方法。</p><h4 id="7-Class-id-objc-object"><a href="#7-Class-id-objc-object" class="headerlink" title="7. Class / id / objc_object"></a>7. Class / id / objc_object</h4><p>Objective-C类是由 Class 类型来表示的，它实际上是一个指向<br>objc_class 结构体的指针。Class 的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure></p><p>查看 objc/runtime.h 中 objc_class 结构体的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>由 objc_class 结构体可知，在 objective-C 中，所有的类自身也是一个对象，里面有一个 Class 类型的 isa 指针，指向 metaClass(元类)。</p><p>super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。</p><p>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，提高了调用效率。</p><p>objc_object 是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure></p><p>id 类型是一个指向 objc_object 结构体类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。</p><p>在 Objective-C，一个对象的类由它的 isa 指针决定。isa 指针指向这个对象的 Class。在 Objective-C 中，对象的一个重要的特性是，你可以向它们发送消息：</p><ol><li>当你向一个对象发送消息，就在那个对象的方法列表中查找那个消息。</li><li>当你想一个类发送消息，就再那个类的 meta-class 中查找那个消息。</li></ol><p><strong>meta-class 是一个类对象的类</strong></p><p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p><p>meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class ，因为每个类的类方法基本不可能完全相同。</p><p>meta-class 是必须的，因为它为一个 Class 存储类方法。每个类都必须有一个唯一的 meta-class，因为每个 Class 都有一个可能不一样的类方法。</p><p>meta-class，如之前的 Class，同样是个对象。这就意味着你也可以在它上面调用方法。自然的，这就意味着它也必须有一个类</p><p>所有的 meta-class 使用它们基类的 meta-class （继承层次中最顶层的 Class 的 meta-class）作为它们自己的类。这就是说所有继承自 NSObject 的类（大部分的类），以 NSObject 的 meta-class 作为自己的 meta-class 的类。</p><p>遵循这个规则，所有的 meta-class 使用基类的 meta-class 作为他们的类，任何基类的 meta-class 将会是他们自己（它们的 isa 指向他们自己）。这就是说 NSObject 的 meta-class 的 isa 指针指向它们自己（是自己的一个实例）。</p><h4 id="8-nullable、-nullable、-Nullable-究竟有什么区别"><a href="#8-nullable、-nullable、-Nullable-究竟有什么区别" class="headerlink" title="8. nullable、__nullable、_Nullable 究竟有什么区别"></a>8. nullable、__nullable、_Nullable 究竟有什么区别</h4><ol><li><p>对于属性、方法返回值、方法参数的修饰，使用： nonnull/nullable</p></li><li><p>对于 C 函数的参数、Block 的参数、Block 返回值的修饰，使用： _Nonnull/_Nullable ， 建议弃用 <strong>nonnull/</strong>nullable</p></li></ol><p>如果需要每个属性或每个方法都去指定 nonnull 和 nullable ，将是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END 。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull ，因此我们只需要去指定那些 nullable 指针对象即可。</p><p>疑问：为什么已经有了 nonnull/nullable ，为什么还要增加 _Nonnull/_Nullable ？</p><h4 id="9-使用pathForResource获取不到-bundle-里的资源，返回nil的问题"><a href="#9-使用pathForResource获取不到-bundle-里的资源，返回nil的问题" class="headerlink" title="9. 使用pathForResource获取不到 bundle 里的资源，返回nil的问题"></a>9. 使用pathForResource获取不到 bundle 里的资源，返回nil的问题</h4><p>通过 右键-&gt;add files to 的方式将 Bundle 添加到工程里面，但是使用[[NSBundle mainBundle] pathForResource:@”name” ofType:@”type”]时，无论如何都找不到文件，经过了重启工程 、clear工程以及重启电脑等方式都无法解决问题。经过思考和测试，感觉这可能是xcode的一个bug。</p><p>解决办法及原理是这样的，[NSBundle mainBundle]其获取的路径是你程序的安装路径下的资源文件位置。 在xcode中采用add file to 方式添加文件时，一般情况下xcode会自动将文件添加到你的资源文件，而且，这些文件在你工程的 build Phases 中的 copy Bundle Resources 中可以查看到。但是有时候，由于xcode的问题，采用add files to 不能自动添加到你的资源文件中，这时，可以采用copy Bundle Resources下面的“+”号，手动将文件添加到你的资源文件中，这样就可以解决问题了。</p><h4 id="10-新建-window-并设置它的-rootViewController-遇到的状态栏问题"><a href="#10-新建-window-并设置它的-rootViewController-遇到的状态栏问题" class="headerlink" title="10. 新建 window 并设置它的 rootViewController 遇到的状态栏问题"></a>10. 新建 window 并设置它的 rootViewController 遇到的状态栏问题</h4><p>新建 window 并设置它的 rootViewController ，在 rootViewController 中想要自定义状态栏样式或者隐藏状态栏，遇到的问题是，如果该 window 的 frame 不等于 [UIScreen mainScreen].bounds ，那么在 rootViewController 中想要使用下面两个方法设置状态栏时，是无效的，因为此时这两个方法不会调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UIStatusBarStyle)preferredStatusBarStyle;</span><br><span class="line">- (BOOL)prefersStatusBarHidden</span><br></pre></td></tr></table></figure><p>Apple 这样做是有理由的，比如新建 window 不能覆盖整个屏幕，只是一个很小的悬浮框，此时的 rootViewController 不需要控制状态栏样式。</p><p>当不设置 window 的 frame 或者设置 window 的 frame 为 [UIScreen mainScreen].bounds 时，在 rootViewController 中才能够设置状态栏样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//能够正确设置状态栏的代码：</span><br><span class="line"></span><br><span class="line">UIWindow *delegateWindow = [UIApplication sharedApplication].delegate.window;</span><br><span class="line">CGRect rect = [UIScreen mainScreen].bounds;</span><br><span class="line">self.window = [[UIWindow alloc] init];</span><br><span class="line">self.window.rootViewController = self.rootVC;</span><br><span class="line">[self.window makeKeyAndVisible];</span><br><span class="line">self.window.frame = CGRectMake(0, -rect.size.height, rect.size.width, rect.size.height);</span><br><span class="line">// 保持原先的keyWindow，避免一些奇怪的bug</span><br><span class="line">[delegateWindow makeKeyWindow];</span><br><span class="line">[UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">    self.window.frame = rect;</span><br><span class="line">&#125; completion:NULL];</span><br></pre></td></tr></table></figure><h4 id="11-当-present-一个viewController并且设置这个viewController背景透明度时，背景色变黑的问题"><a href="#11-当-present-一个viewController并且设置这个viewController背景透明度时，背景色变黑的问题" class="headerlink" title="11. 当 present 一个viewController并且设置这个viewController背景透明度时，背景色变黑的问题"></a>11. 当 present 一个viewController并且设置这个viewController背景透明度时，背景色变黑的问题</h4><p>想模态展示一个VC窗口，设置它的背景透明度为0.5，却发觉prsent后的背景色变为黑色。</p><img src="/2018/07/06/iOS开发琐碎知识点/issue11_1.gif" title="[]"><p>原因是：</p><blockquote><p>NavigationController and the View Controllers are designed in such a way that only one view controller may show at a time. When a new view controller is pushed/presented the previous view controller will be hidden by the system. So when you reduce the modal view’s alpha you will possibly see the window’s backgroundColor (the black color you see now).</p><p>If you want a translucent view to slide-in over the main view, you can add the view as the subView of main view and animate it using UIView Animations.</p></blockquote><p>解决方法可以是 ：直接动画添加view<br>或者 设置模态VC的属性 modalPresentationStyle 为<br>UIModalPresentationCustom</p><h4 id="12-App支持从4种来源去打开一个VC页面"><a href="#12-App支持从4种来源去打开一个VC页面" class="headerlink" title="12. App支持从4种来源去打开一个VC页面"></a>12. App支持从4种来源去打开一个VC页面</h4><ul><li>Push推送</li><li>App外部网页打开</li><li>App内部网页打开</li><li>应用内点击打开</li></ul><img src="/2018/07/06/iOS开发琐碎知识点/issue12_1.png" title="[]"><p>这四种方式均跳转到 DetailViewController 界面。普通的跳转依然可以满足该场景, 最简单的解决方案是在四个不同的地方都写一个独立的界面打开逻辑。作为一名有追求的开发者, 这么冗余的四份入口代码显然不合适。</p><p>一种解决方案是采用 URL 协议统一跳转。每个 viewController 页面定义与之对应的 URL，在各个入口只需要调用打开该URL的方法即可完成页面的创建以及跳转。</p><p>基于URL的路由方案：</p><p>SNMediator 是用于 iOS 应用进行模块化拆分的中间件框架，它不依赖任何第三方库，基于 URL 协议实现三端(iOS, Android, H5)统一的页面跳转方式。</p><p>例如：你的 APP DetailViewController 界面对应URL定义为：<br>myapp://businessModule/goodsdetails/?id=100<br>其中，scheme为 myapp，host为 businessModule，path为 goodsdetails，携带参数 id=100.</p><p>使用 SNMediator 跳转页面方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)routeURL:(nonnull NSURL *)URL withParams:(nullable NSDictionary *)params completion:(void(^ _Nullable)(id _Nullable result))completion;</span><br><span class="line"></span><br><span class="line">[SNMediator routeURL:@&quot;myapp://businessModule/goodsdetails/?id=100&quot; params:nil completion:NULL];</span><br></pre></td></tr></table></figure><p>SNMediator 支持通过字典传递额外的自定义复杂对象，也支持URL自身携带参数。所以4种入口都可以通过这一句代码调用完成页面跳转，保持了不同入口跳转同一界面的代码一致性。</p><h4 id="13-iOS-中一个viewController只能-present-出来唯一一个其他viewController"><a href="#13-iOS-中一个viewController只能-present-出来唯一一个其他viewController" class="headerlink" title="13. iOS 中一个viewController只能 present 出来唯一一个其他viewController"></a>13. iOS 中一个viewController只能 present 出来唯一一个其他viewController</h4><p>如果你要在同一个 viewController 中上同时 present 两个viewController，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SNViewControllerOne *oneVC = [[SNViewControllerOne alloc] init];</span><br><span class="line">    [self presentViewController:oneVC animated:YES completion:^&#123;</span><br><span class="line">        SNViewControllerTwo *twoVC = [[SNViewControllerTwo alloc] init];</span><br><span class="line">        [self presentViewController:twoVC animated:YES completion:NULL];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p><p>此时界面上只会显示 oneVC 的视图，不会显示 twoVC 并且 twoVC 也不存在于视图栈中。这是因为当一个新的 viewController 被 push/present 时，先前的那个 viewController 就会被系统隐藏，所以不会出现在视图栈中。</p><blockquote><p>When a new view controller is pushed/presented the previous view controller will be hidden by the system.</p></blockquote><p>并且在控制台还会给出警告：</p><p><code>Warning: Attempt to present &lt; SNViewControllerTwo: 0x7ff813c5c760&gt; on &lt;SNRootViewController: 0x7ff813e307c0&gt; whose view is not in the window hierarchy!</code></p><p>告诉你当 SNRootViewController present 出来 SNViewControllerOne 后，再试图 present SNViewControllerTwo 时，SNRootViewController 已经被隐藏，不再存在于 window 的视图层级中，所以也就无法在 SNRootViewController 基础上继续 present 另一个视图。</p><h4 id="14-UIGestureRecognizerState-各个状态的变化"><a href="#14-UIGestureRecognizerState-各个状态的变化" class="headerlink" title="14. UIGestureRecognizerState 各个状态的变化"></a>14. UIGestureRecognizerState 各个状态的变化</h4><p>UIGestureRecognizerState的定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123;</span><br><span class="line">    UIGestureRecognizerStatePossible,  </span><br><span class="line">    UIGestureRecognizerStateBegan,    </span><br><span class="line">    UIGestureRecognizerStateChanged,    </span><br><span class="line">    UIGestureRecognizerStateEnded,   </span><br><span class="line">    UIGestureRecognizerStateCancelled, </span><br><span class="line">    UIGestureRecognizerStateFailed,    </span><br><span class="line">    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Remarks:<br>This describes the state of a UIGestureRecognizer. All of UIGestureRecognizers start in the Possible state. Once one or more touches has been received, the recognizers transition to the Began state. For one-shot patterns (like Tap), this will either transition into the Recognized state or the Failed state. For continuous gestures (like panning, pinching, rotating) the recognizer will transition to the Changed state and emit multiple calls back to the action and finally transition to either the Ended or Cancelled states.</p><h4 id="15-NULL-nil-Nil-NSNull"><a href="#15-NULL-nil-Nil-NSNull" class="headerlink" title="15. NULL / nil / Nil / NSNull"></a>15. NULL / nil / Nil / NSNull</h4><p>C 用 0 来作为不存在的原始值，而NULL作为指针，这在指针环境中相当于 0。</p><p>Objective-C 在 C 的表达不存在的基础上增加了nil。nil 是一个指向不存在的对象指针。虽然它在语义上与NULL 不同，但它们在技术上是相等的。</p><p>在框架层面，Foundation 定义了 NSNull，即一个类方法 +null，它返回一个单独的 NSNull 对象。NSNull 与 nil 以及 NULL 不同，因为它是一个实际的对象，而不是一个零值。、</p><p>在 Foundation/NSObjCRuntime.h 中，Nil 被定义为指向零的类指针。它并不常常出现，但至少值得注意。</p><img src="/2018/07/06/iOS开发琐碎知识点/issue15_1.png" title="[]"><h4 id="16-CGGeometry"><a href="#16-CGGeometry" class="headerlink" title="16. CGGeometry"></a>16. CGGeometry</h4><p>GRect 用于表示屏幕上绘制的所有视图的 frame，一个程序员操作矩形几何体的能力决定着他在图形编程上的成功。</p><h5 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h5><p>几何变换，这些函数返回在传入的矩形中做某些特定操作后的 CGRect</p><ul><li>CGRectOffset: 返回一个原点在源矩形基础上进行了偏移的矩形</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect CGRectOffset(</span><br><span class="line">  CGRect rect,</span><br><span class="line">  CGFloat dx,</span><br><span class="line">  CGFloat dy</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意，用这个你只改变了矩形的原点。它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。</p><ul><li>CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect CGRectOffset(</span><br><span class="line">  CGRect rect,</span><br><span class="line">  CGFloat dx,</span><br><span class="line">  CGFloat dy</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意，用这个你只改变了矩形的原点。它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。</p><ul><li>CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect CGRectInset(</span><br><span class="line">  CGRect rect,</span><br><span class="line">  CGFloat dx,</span><br><span class="line">  CGFloat dy</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>想一个视图中的视图更好看吗？用CGRectInset给它设置一个 10pt 的边距吧。需要记住的是，矩形将围绕它的中心点进行缩放，左右分别增减dx（总共2 x dx），上下分别增减 dy（总共 2 x dy）。</p><p>如果你用 CGRectInset 作为缩放矩形的快捷方法，一般通用的做法是嵌套调用CGRectOffset，把CGRectInset的返回值作为CGRectOffset的参数。</p><ul><li>CGRectIntegral: 返回包围源矩形的最小整数矩形</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGRect CGRectIntegral (</span><br><span class="line">  CGRect rect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将CGRect 取整到最近的完整点是非常重要的。小数值会让边框画在像素边界处。因为像素已经是最小单元（不能再细分），小数值会使绘制时取周围几个像素的平均值，这样看起来就模糊了。</p><p>CGRectIntegral 将表示原点的值向下取整，表示大小的值向上取整，这样就保证了你的绘制代码平整地对齐到像素边界。</p><p>作为一个经验性的原则，如果你在执行任何一个可能产生小数值的操作（例如除法，CGGetMid[X|Y]，或是 CGRectDivide），在把一矩形作为视图的边框之前应该用CGRectIntegral正则化它。</p><blockquote><p>从技术上讲，坐标系讲的是点，而视网膜屏一个点中有四个像素，所以它在奇数像素± 0.5f处绘制也不会产生模糊。</p></blockquote><h5 id="取值辅助函数"><a href="#取值辅助函数" class="headerlink" title="取值辅助函数"></a>取值辅助函数</h5><p><strong>CGRectGet[Min|Mid|Max][X|Y]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGRectGetMinX</span><br><span class="line">CGRectGetMinY</span><br><span class="line">CGRectGetMidX</span><br><span class="line">CGRectGetMidY</span><br><span class="line">CGRectGetMaxX</span><br><span class="line">CGRectGetMaxY</span><br></pre></td></tr></table></figure><p>这六个函数返回矩形x或y的最小、中间或最大值，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGFloat CGRectGet[Min|Mid|Max][X|Y] (</span><br><span class="line">  CGRect rect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>用这些函数代替诸如frame.origin.x + frame.size.width之类的代码将更加清晰、语义上更为生动的（特别是用取中间和取最大函数）。</p><p><strong>CGRectGet[Width|Height]</strong></p><ul><li>CGRectGetHeight: 返回矩形的高度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGFloat CGRectGetHeight (</span><br><span class="line">   CGRect rect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>CGRectGetWidth: 返回矩形的宽度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGFloat CGRectGetWidth (</span><br><span class="line">   CGRect rect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>跟之前的函数一样，用CGRectGetWidth 和 CGRectGetHeight返回CGRect的size成员更可取。这绝不只是节省了几个字符，语义上的清晰胜过简洁。</p><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>这里列出了三个我们必须了解的特殊矩形值，它们都有一些独一无二的属性：</p><p><strong>CGRectZero， CGRectNull，和 CGRectInfinite</strong></p><ul><li><p>const CGRect CGRectZero: 一个原点在(0, 0)，且长宽均为 0 的常数矩形。这个零矩形与 CGRectMake(0.0f, 0.0f, 0.0f, 0.0f) 是等价的。</p></li><li><p>const CGRect CGRectNull: 空矩形。这个会在，比如说，求两个不相交的矩形的相交部分时返回。注意，空矩形不是零矩形。</p></li><li><p>const CGRect CGRectInfinite: 无穷大矩形。</p></li></ul><p>CGRectZero 可能是所有这些特殊矩形中最有用的了。当初始化一个视图时，它们的边框通常设置为CGRectZero，把布局放到 -layoutSubviews中。</p><p>CGRectNull 跟 CGRectZero 是两回事，尽管它隐隐约约让你感觉到NULL == 0。这个值在概念上与NSNotFound相近，所以它表示预期值的缺失。请注意函数可能返回 CGRectNull，同时也应让它能正确处理传入的CGRectIsNull。</p><p>CGRectInfinite 是以上所有当中最有异国风情的，并且有一些最有趣的属性。它与所有的点或矩形相交，包含所有矩形，且它与任何矩形的并集等于它自身。用 CGRectIsInfinite 来检查一矩形是否为无限大。</p><h5 id="最复杂、最容易误解、也最有用的CGGeometry-函数：CGRectDivide。"><a href="#最复杂、最容易误解、也最有用的CGGeometry-函数：CGRectDivide。" class="headerlink" title="最复杂、最容易误解、也最有用的CGGeometry 函数：CGRectDivide。"></a>最复杂、最容易误解、也最有用的CGGeometry 函数：CGRectDivide。</h5><ul><li>CGRectDivide: 将源矩形分为两个子矩形。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void CGRectDivide(</span><br><span class="line">  CGRect rect,</span><br><span class="line">  CGRect *slice,</span><br><span class="line">  CGRect *remainder,</span><br><span class="line">  CGFloat amount,</span><br><span class="line">  CGRectEdge edge</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>CGRectDivide 用以下方式将矩形分割为两部分：</p><p>(1). 传入一个矩形并选择一条edge（上，下，左，右）<br>(2). 平行那个边在矩形里量出amount的长度<br>(3). 从edge 到量出的amount区域都保存到slice 参数中<br>(4). 剩余的部分保存到remainder 参数中</p><p>其中 edge 参数是一个CGRectEdge 枚举类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum CGRectEdge &#123;</span><br><span class="line">   CGRectMinXEdge,</span><br><span class="line">   CGRectMinYEdge,</span><br><span class="line">   CGRectMaxXEdge,</span><br><span class="line">   CGRectMaxYEdge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGRectDivide 用于在几个视图之间分割可用空间真是太完美了（把它在随后的remainder容纳多于两个的视图）。下次当你需要手机布局一个UITableViewCell时试试吧。CGRectDivide is perfect for dividing up available space among several views (call it on subsequent remainder amounts to accommodate more than two views). Give it a try next time you’re manually laying-out a UITableViewCell.</p><h4 id="17-layoutSubViews-的使用"><a href="#17-layoutSubViews-的使用" class="headerlink" title="17. layoutSubViews 的使用"></a>17. layoutSubViews 的使用</h4><p>当我们熟练使用 autolayout 时，或许会忽略了 layoutSubViews 的存在，但是不管是使用 autoLayout 还是直接 frame 布局，只要重写了 <code>layoutSubViews</code>，视图都会在布局它的子视图时调用 <code>layoutSubViews</code>（使用 autolayout 布局的话，不能在 layoutSubViews 再更改 frame 的值了）。那么我们一般什么时候需要重写它？既然 <code>layoutSubViews</code> 不能直接调用，那么系统在什么时候会调用它？触发的条件是什么呢？</p><p>很显然，当你需要使用纯frame布局一个视图<code>myView</code>的子视图(<code>view1</code> <code>view2</code> <code>view3</code>等…)时，就需要重写 <code>myView</code> 的<code>layoutSubViews</code> 方法，计算并设置它的子视图的frame从而完成布局。</p><p>先看一段官方文档：</p><blockquote><p>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p></blockquote><p>主要意思是，对于子视图的布局，如果 autoresizing 以及基于约束的布局方式不能满足你实际的需求时，才应该重写该方法。不要直接调用此方法。如果你想强制更新布局，你可以调用setNeedsLayout方法；如果你想立即数显你的views，你需要调用layoutIfNeeded方法。</p><p>layoutSubviews 以下情况会被调用</p><p>苹果官方文档已经强调，不能直接调用layoutSubviews对子视图进行重新布局。以下几种情况layoutSubviews会被调用。</p><ul><li>直接调用setLayoutSubviews（这个在上面苹果官方文档里有说明）</li><li>addSubview的时候。</li><li>当视图的的frame发生改变的时候。</li><li>滑动UIScrollView的时候。</li><li>旋转Screen会触发父UIView上的layoutSubviews事件。</li><li>改变一个子视图大小的时候，也会触发父视图上的 layoutSubviews 事件。</li></ul><p>注意:</p><p>当view的frame的值为0的时候，addSubview也不会调用layoutSubviews的。<br>layoutSubviews方法在对子视图进行布局的时候非常方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个半路出家的小白、一个为了生活不断积累技术知识的俗人，本着急功近利的的精神把工作中遇到的小问题、琐碎知识点总结下来留给我闺女。&lt;br&gt;…&lt;br&gt;…&lt;/p&gt;
    
    </summary>
    
      <category term="iOS dev" scheme="https://yangjie2.github.io/categories/iOS-dev/"/>
    
    
      <category term="iOS" scheme="https://yangjie2.github.io/tags/iOS/"/>
    
      <category term="知识点总结" scheme="https://yangjie2.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>细说iOS并发编程</title>
    <link href="https://yangjie2.github.io/2018/07/06/%E7%BB%86%E8%AF%B4iOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://yangjie2.github.io/2018/07/06/细说iOS并发编程/</id>
    <published>2018-07-06T06:00:48.000Z</published>
    <updated>2018-07-10T04:05:20.087Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程是一个很有挑战的任务，它有许多错综复杂的问题和陷阱。在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文参考 <a href="https://www.objc.io/" target="_blank" rel="noopener">objc.io</a> 上iOS多线程的一篇文章：<a href="https://objccn.io/issue-2-4/" target="_blank" rel="noopener">线程安全类的设计</a>，以及 <a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1" target="_blank" rel="noopener">raywenderlich</a> 上的 <a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1" target="_blank" rel="noopener">Grand Central Dispatch In-Depth:Part 1/2</a> , <a href="https://www.raywenderlich.com/148515/grand-central-dispatch-tutorial-swift-3-part-2" target="_blank" rel="noopener">Grand Central Dispatch In-Depth:Part 2/2</a> ，还有这篇 <a href="http://mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="noopener">iOS多线程到底不安全在哪里</a>。同时c参考了苹果 Guides and Sample Code 中关于<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1" target="_blank" rel="noopener">并发编程</a>的章节。</p><a id="more"></a><h3 id="并发编程相关的几个概念"><a href="#并发编程相关的几个概念" class="headerlink" title="并发编程相关的几个概念"></a>并发编程相关的几个概念</h3><p><strong>进程（Process）</strong> 简单来说，进程是指系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单，是组成进程的子单元。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。说得再具体一些，线程就是“一个CPU执行的一条无分叉的命令序列”。所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。</p><p>同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间、文件描述符等。但每个线程都拥有自己的栈，寄存器，本地存储（thread-local storage）。一个进程可以有很多线程，每条线程并行执行不同的任务，称为多线程。</p><p>多个线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么多个线程就可以真正的并行处理，从而减少了完成某项操作所需要的总时间。</p><p><strong>并发(Concurrent)/并行(Parallel)</strong> 很多人对并发/并行的概念感到困惑，按照我的理解，并发所描述的概念是“同时”运行多个线程，多个线程“同时”被处理。这里对同时加了引号，因为这些线程可能是在单核 CPU 上以分时（时间共享）的形式，在极短的时间片段间不停的切换运行(类似通信中的时分复用(TDM))，也可能是在多核 CPU 上以真正的并行方式同时运行。</p><p>关于并发和并行，可以用下面这张有趣的图解释：</p><img src="/2018/07/06/细说iOS并发编程/并发与并行.png" title="[并发与并行]"><p>如果还是不能理解，或许应该看下这段准确的英文解释：</p><blockquote><p>Concurrency and parallelism are often mentioned together, so it’s worth a short explanation to distinguish them from each other.</p><p>Separate parts of concurrent code can be executed “simultaneously”. However, it’s up to the system to decide how this happens — or if it happens at all.</p><p>Multi-core devices execute multiple threads at the same time via parallelism; however, in order for single-cored devices to achieve this, they must run a thread, perform a context switch, then run another thread or process. This usually happens quickly enough as to give the illusion of parallel execution</p><p>Although you may write your code to use concurrent execution under GCD, it’s up to GCD to decide how much parallelism is required. Parallelism requires concurrency, but concurrency does not guarantee parallelism.</p><p>The deeper point here is that concurrency is actually about structure. When you code with GCD in mind, you structure your code to expose the pieces of work that can run simultaneously, as well as the ones that must not be run simulataneously. If you want to delve more deeply into this subject, check out <a href="https://vimeo.com/49718712" target="_blank" rel="noopener">this excellent talk by Rob Pike</a>.</p></blockquote><p><strong>临界区(Critical Section)</strong> 不能被两个线程同时执行的一段代码叫做临界区。因为这段代码通常操控着一个共享的临界资源(一次仅允许一个线程使用的共享资源)，多个线程必须互斥的访问该临界资源。只能被单一线程/进程访问的共享资源，比如打印机等。</p><p><strong>竞态条件(Race Condition)</strong> 软件系统的正确行为依赖于多个线程交替执行的时序时，就会发生竞态条件。常见的竟态条件为：</p><ol><li>先检测后执行。执行依赖于检测的结果，而检测结果取决于多线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现问题。</li></ol><img src="/2018/07/06/细说iOS并发编程/image2.png" title="[]"><p>对于 main 线程，如果文件a不存在，则创建文件a，但是在判断文件a不存在之后，Task线程创建了文件a，这时候先前的判断结果已经失效（main线程的执行依赖了一个错误的判断结果），此时文件a已经存在了，但是 main 线程还是会继续创建文件a，导致 Task 线程创建的文件a被覆盖、文件中的内容丢失等等问题。多线程环境中对同一个文件的操作要加锁。</p><ol><li>延迟初始化（最典型即为单例）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static MyObject *instance = nil;</span><br><span class="line">+ (instancetype)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    if (instance == nil) &#123;</span><br><span class="line">        instance = [[MyObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如线程thread1和线程thread2同时执行 shareInstance，thread1 看到 instance 为空，创建了一个新的 Obj 对象，此时 thread2 也需要判断 instance 是否为空，此时的 instance 是否为空取决于不可预测的时序：包括 thread1 创建 Obj 对象需要多长时间以及线程的调度方式，如果 thread2 检测时，instance为空，那么 thread2 也会创建一个 instance 对象</p><p><strong>死锁(Deadlock)</strong> Two (or sometimes more) threads are said to be deadlocked if they all get stuck waiting for each other to complete or perform another action. The first can’t finish because it’s waiting for the second to finish. But the second can’t finish because it’s waiting for the first to finish.(翻译水平有限，英文可以更好的理解)</p><p><strong>线程安全(Thread Safe)</strong> 是指代码在多线程或者并发任务下能够被安全调用，而不会引起任何问题(data corruption, crashing, etc)。非线程安全代码必须只能运行在单线程环境下。</p><p><strong>上下文切换(Context Switch)</strong> A context switch is the process of storing and restoring execution state when you switch between executing different threads on a single process(进程).</p><h3 id="iOS-和-OS-X-中的并发编程"><a href="#iOS-和-OS-X-中的并发编程" class="headerlink" title="iOS 和 OS X 中的并发编程"></a>iOS 和 OS X 中的并发编程</h3><p>苹果的移动和桌面操作系统中提供了相同的并发编程API。 这里会介绍 pthread 、 NSThread 、GCD 、NSOperationQueue，以及 NSRunLoop。实际上把 run loop 也列在其中是有点奇怪，因为它并不能实现真正的并行，不过因为它与并发编程有很大的关系，因此值得我们进行一些深入了解。</p><p>需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，也无法控制执行多长时间后将被暂停，以便轮换执行别的任务。开发者可以使用 <a href="https://en.wikipedia.org/wiki/POSIX_Threads" target="_blank" rel="noopener">POSIX 线程</a> API，或者 Objective-C 中提供的对该 API 的封装 NSThread，来创建自己的线程。下面这个小Demo利用 pthread 在一百万个数字中查找最小值和最大值，其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">struct inputInfo &#123;</span><br><span class="line">    uint32_t *intputValues;</span><br><span class="line">    size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct resultInfo &#123;</span><br><span class="line">    uint32_t min;</span><br><span class="line">    uint32_t max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void * findMinAndMax(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct inputInfo const * const info = (struct inputInfo *)arg;</span><br><span class="line">    uint32_t min = UINT32_MAX;</span><br><span class="line">    uint32_t max = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; info-&gt;count; i++) &#123;</span><br><span class="line">        uint32_t temp = info-&gt;intputValues[0];</span><br><span class="line">        min = MIN(temp, min);</span><br><span class="line">        max = MAX(temp, max);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arg);</span><br><span class="line">    struct resultInfo *const result = (struct resultInfo *)malloc(sizeof(*result));</span><br><span class="line">    result-&gt;max = max;</span><br><span class="line">    result-&gt;min = min;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 使用随机数字填充 inputValues</span><br><span class="line">    size_t const count = 1000000;</span><br><span class="line">    uint32_t inputValues[count];</span><br><span class="line">    </span><br><span class="line">    // 使用随机数字填充 inputValues</span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        inputValues[i] = (uint32_t)i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 开始4个寻找最小值和最大值的线程</span><br><span class="line">    size_t const threadCount = 5;</span><br><span class="line">    pthread_t tid[threadCount];</span><br><span class="line">    for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        struct inputInfo * const info = (struct inputInfo *) malloc(sizeof(*info));</span><br><span class="line">        size_t offset = (count / threadCount) * i;</span><br><span class="line">        info-&gt;intputValues = inputValues + offset;</span><br><span class="line">        info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class="line">        int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);</span><br><span class="line">        NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err);</span><br><span class="line">    &#125;</span><br><span class="line">    // 等待线程退出</span><br><span class="line">    struct resultInfo * results[threadCount];</span><br><span class="line">    for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        int err = pthread_join(tid[i], (void **) &amp;(results[i]));</span><br><span class="line">        NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err);</span><br><span class="line">    &#125;</span><br><span class="line">    // 寻找 min 和 max</span><br><span class="line">    uint32_t min = UINT32_MAX;</span><br><span class="line">    uint32_t max = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        min = MIN(min, results[i]-&gt;min);</span><br><span class="line">        max = MAX(max, results[i]-&gt;max);</span><br><span class="line">        free(results[i]);</span><br><span class="line">        results[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;min = %u&quot;, min);</span><br><span class="line">    NSLog(@&quot;max = %u&quot;, max);</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure><p>NSThread 是 Objective-C 对 pthread 的封装，比直接使用 pthread 更方便些。但是不论使用 pthread 还是 NSThread 直接对线程操作，都是相对糟糕的编程体验。</p><p>直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。</p><p>下面介绍两种基于队列的并发编程API：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的<a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener">线程池</a>，来解决创建过多线程导致的问题。</p><h4 id="Grand-Central-Dispatch"><a href="#Grand-Central-Dispatch" class="headerlink" title="Grand Central Dispatch"></a>Grand Central Dispatch</h4><p>为了让开发者更加容易的充分利用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。</p><p>通过GCD，开发者不必再直接跟线程打交道。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</p><p>GCD中的两个核心概念是“任务”和“队列”，开发者只需专注于想要执行的“任务” block，然后添加到适当的“队列”中，这种形象的抽象方式更容易被人理解和使用。</p><p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 任务最终都将被放入到系统的全局队列和线程池中，如下图所示：</p><img src="/2018/07/06/细说iOS并发编程/queues.png" title="[系统队列和自定义队列]"><p>我们强烈建议，在大多数情况下使用默认优先级的队列就可以了，如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。</p><p>虽然 GCD 是一个低层级的 C 语言 API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱，这些将在后面并发编程带来的问题中进行讨论。</p><p><strong>串行队列(Serial Queues)</strong> 串行队列中的任务，每次只执行一个，先前的任务执行完毕后，才会执行下一个。当然，你不会知道一个block结束与下一个block开始之间的时间间隔是多少，如下图所示：</p><img src="/2018/07/06/细说iOS并发编程/serial_queue.png" title="[串行队列]"><p>这些任务的执行时间是在GCD的控制之下，你唯一能够确定的是：GCD每次只执行一个任务，任务执行顺序就是它们被加入队列的顺序。</p><p>因为在串行队列中两个任务不可能并发运行，所以就没有可能会同时访问同一个临界区的风险。所以仅对于这些任务而言，这种运行机制能够保护临界区避免发生竟态条件。所以，如果访问临界区的唯一方式是通过被提交到那个串行队列中的任务，那么你可以确保临界区是安全的。</p><p><strong>并发队列(Concurrent Queues)</strong> 在并发队列中，你能够保证的仅有一件事：任务的执行顺序就是它们被添加到队列中的顺序。对于每个任务的完成顺序、下一个任务什么时候开始以及在任意给定时间内正在运行的 blocks 数量都是不清楚的，这些完全取决去 GCD。下图展示了在GCD下4个并发任务的执行：</p><img src="/2018/07/06/细说iOS并发编程/concurrent_queue.png" title="[并发队列]"><p>上图表达的意思是，一个 block 什么时候开始执行完全取决于 GCD，如果一个 blcok 的执行时间与另一个重叠，由 GCD 决定这个 block 是需要运行在另一个核心上，还是在同一个核心上通过上下文切换(context switch)的方式执行。</p><p>队列类型<br>系统提供了一个特殊的串行队列叫主队列(main queue)，像其他串行队列一样，主队列中的任务每次执行一个，但是能够确定的是，主队列中的所有任务都在主线程执行，主线程是唯一允许更新UI的线程。主队列用来向 UIViews 对象发送消息或者发送通知。</p><p>系统还提供了4种不同优先级的全局并发队列(Global Dispatch Queues)：background、low、default、high，优先级由低到高。需要注意的是，苹果的 API 也使用了这些队列，所以这些队列中并非只有你自己添加的任务。</p><p>最后，你还可以创建自定义串行/并发队列。也就是说，至少有五种队列可供选择：主队列、4个全局并发队列、自定义队列。</p><p>And that’s the big picture of dispatch queues!</p><p>GCD 的“艺术”归根结底在于选择合适的<a href="https://developer.apple.com/documentation/dispatch?language=objc" target="_blank" rel="noopener">队列派发函数(dispatch function)</a>将任务提交到特定队列中。下面举例说明几种常用的 dispatch function。</p><p><strong>(1). dispatch_async</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;First Log&quot;); // 1</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;Second Log&quot;); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个动态图生动的呈现出究竟发生了什么，左侧是代码中的断点，右侧是相关队列的状态：</p><img src="/2018/07/06/细说iOS并发编程/dispatch_async.gif" title="[]"><ol><li>主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内；</li><li>viewDidLoad 在主线程执行</li><li>现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_async</li><li>dispatch_async 的 block 被添加到一个全局队列并且稍后将会执行它</li><li>在 dispatch_async 添加 block 到全局队列之后，viewDidLoad继续向下走，主线程把注意力放在剩余的任务上。与此同时，全局队列也正在并发的处理它的任务。再次提醒，全局队列中的任务将以 “FIFO” 的顺序出队(分发下去)，但是这些任务会被并发执行。</li><li>现在，被 dispatch_async 添加的 block 正在执行了</li><li>dispatch_async 的 block 执行完毕，所有的 NSLog 语句都已经将输出打印到了控制台。尽管在这个小例子中先执行了第二条打印任务，随后才执行第一条，不过 First Log 和 Second Log 打印顺序不定 —— 取决于在那个特定时间硬件正在处理的事情，你没有办法控制或者知晓哪条语句先执行。</li></ol><p><strong>什么时候以及怎样使用 dispatch_async 和各种队列</strong></p><ul><li>自定义串行队列：当你想在后台串行的执行任务并跟踪这个任务的执行状态时，使用自定义串行队列是一个好的选择。这样能消除资源竞争，因为在同一时刻仅有一个任务正在执行。</li><li>主队列(Serial)：通常，在并发队列中的一项任务处理完成后，就需要更新UI。此时你需要嵌套 block 把UI更新任务提交到主队列。如果你现在已经处于主队列，并调用 dispatch_async 将任务添加到主队列，此时你唯一能确保的是，这个新添加的任务将在当前方法执行完毕后的某个时间才被执行。</li><li>并发队列：通常使用并发队列在后台处理非UI操作。</li></ul><p><strong>(2). dispatch_sync</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">     [super viewDidLoad];</span><br><span class="line">     dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">         NSLog(@&quot;First Log&quot;); // 1</span><br><span class="line">     &#125;);</span><br><span class="line">     NSLog(@&quot;Second Log&quot;); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/07/06/细说iOS并发编程/dispatch_sync.gif" title="[]"><p>上图中各个步骤的说明如下：</p><ol><li>主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内</li><li>viewDidLoad 在主线程执行</li><li>现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_sync</li><li>dispatch_sync 的 block 被添加到一个 global queue 并且稍后将会执行它。主线程会被阻塞，直到 block 执行完毕。与此同时，global queue 正在并发的处理任务；在这个 global q ueue 中，所有 block 任务将按照 “FIFO” 的顺序出队，但是会被并发执行。</li><li>global queue 处理先前已经加入队列的任务(在 dispatch_sync block 之前添加到该全局队列中的任务)</li><li>开始执行 dispatch_sync 的 block</li><li>block 执行完毕，dispatch_sync 函数返回，主线程恢复</li><li>viewDidLoad 方法执行完毕，主队列继续处理其他任务</li></ol><p>dispatch_sync 函数将一个任务添加到一个队列中，会阻塞当前线程，直到该任务执行完毕。dispatch_async 不会等待任务执行完，当前线程会继续往下走，不会阻塞当前线程。使用 dispatch_sync 时应注意避免死锁(deadlock)！</p><p><strong>Here’s a quick overview of when and where to use dispatch_sync:</strong></p><ul><li><strong>Custom Serial Queue</strong>: Be VERY careful in this situation; if you’re running in a queue and call dispatch_sync targeting the same queue, you will definitely create a deadlock.</li><li><strong>Main Queue (Serial)</strong>: Be VERY careful for the same reasons as above; this situation also has potential for a deadlock condition.</li><li><strong>Concurrent Queue</strong>: This is a good candidate to sync work through dispatch barriers or when waiting for a task to complete so you can perform further processing.</li></ul><p><strong>(3). dispatch_after</strong></p><p>使用 dispatch_after 延迟执行某个任务。比如在1秒后执行某个block。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double delayInSeconds = 1.0;</span><br><span class="line">   dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 </span><br><span class="line">   dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123; // 2 </span><br><span class="line">        // your task delay to execute       </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p><p>dispatch_after works just like a delayed dispatch_async!!</p><p>dispatch_after 在功能上就像延迟了的 dispatch_async，你没有办法掌控任务的实际执行时间，并且一旦 dispatch_after 函数返回，就没有办法取消任务。</p><p><strong>怎样使用 dispatch_after</strong>:</p><ul><li><strong>自定义串行队列</strong>：在自定义串行队列中谨慎使用 dispatch_after</li><li><strong>主队列(Serial)</strong>：主队列中使用 dispatch_after 是一个好的选择</li><li><strong>并发队列</strong>：谨慎使用，一般你很少在自定义并发队列中使用 dispatch_after</li></ul><p><strong>(4). Dispatch Group</strong></p><p>dispatch_group_create：创建 diapatch group<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br></pre></td></tr></table></figure></p><p>dispatch_group_async：提交 block 到 dispatch queue 中，并将 block 和 group 关联起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, queue, ^&#123; </span><br><span class="line">　　// block</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>dispatch_group_wait：阻塞当前线程，等待 group 关联的所有 block 执行完毕或者到达指定时间。如果到达指定时间后，所有任务并没有全部完成，那么 dispatch_group_wait 返回一个非 0 的数，可以根据这个返回值，判断是否等待超时。如果设置为 DISPATCH_TIME_FOREVER ，意思是永远等待，直到所有 block 执行完毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure></p><p>dispatch_group_notify：不阻塞当前线程，当 group 关联的所有 block 执行完毕后，回调通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">　　// 所有 block 执行完毕的回调</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, queue, ^&#123; </span><br><span class="line">　　// block</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">　　// block</span><br><span class="line">　　dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>when and how to use dispatch groups with the various queue types:</p><ul><li><strong>Custom Serial Queue</strong>: This is a good candidate for notifications when a group of tasks completes.</li><li><strong>Main Queue (Serial)</strong>: This is a good candidate as well in this scenario. You should be wary of using this on the main queue if you are waiting synchronously for the completion of all work since you don’t want to hold up the main thread. However, the asynchronous model is an attractive way to update the UI once several long-running tasks finish such as network calls.</li><li><strong>Concurrent Queue</strong>: This as well is a good candidate for dispatch groups and completion notifications.</li></ul><p><strong>(5). dispatch_apply</strong></p><p>提交 block 到 dispatch queue，并重复调用多次 (Submits a block to a dispatch queue for multiple invocations.)</p><p>dispatch_apply 就像 for 循环一样，并发执行每次的迭代任务。dispatch_apply 函数是同步的，直到所有任务执行完毕，才会返回。如果有大量迭代次数，并且每次迭代都仅处理少量工作，那么并不适合使用 dispatch_apply。</p><p>When is it appropriate to use dispatch_apply?</p><ul><li><strong>Custom Serial Queue</strong>: A serial queue would completely negate the use of dispatch_apply; you might as well just use a normal for loop.</li><li><strong>Main Queue (Serial)</strong>: Just as above, using this on a serial queue is a bad idea. Just use a normal for loop.</li><li><strong>Concurrent Queue</strong>: This is a good choice for concurrent looping, especially if you need to track the progress of your tasks.</li></ul><p><strong>(6). 信号量</strong></p><p>信号量是持有计数的信号，使用它控制对有限资源的使用和访问。假设有一间房子，它对应一个进程，房子里的两个人就对应两个线程。这个房子(进程)有很多资源，比如花园、客厅、卫生间等，是所有人(线程)共享的。但是有些地方，比卫生间，最多只能有1个人能进去。怎么办呢，在卫生间门口挂1把钥匙。进去的人(线程)拿着钥匙进去(信号量 -1)，外面的人(线程)没有钥匙就在门口等待，直到里面的人出来并把钥匙重新放回门口(信号量+1)，此时外面等待的人再拿着这个钥匙进去，所有人(线程)就按照这种方式依次访问卫生间这个有限的资源。门口的钥匙数量就称为信号量(Semaphore)。信号量为0时需要等待，信号量不为零时，减去1而且不等待。</p><p>The semantics for using a dispatch semaphore are as follows:</p><ol><li><p>When you create the semaphore using the dispatch_semaphore_create function, you can specify a positive integer indicating the number of resources available.</p></li><li><p>In each task, call dispatch_semaphore_wait to wait on the semaphore.</p></li><li><p>When the wait call returns, acquire the resource and do your work.</p></li><li><p>When you are done with the resource, release it and signal the semaphore by calling the dispatch_semaphore_signal function.</p></li></ol><p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line">    NSMutableArray *mutableArr = [NSMutableArray array];</span><br><span class="line">    for (NSInteger i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            /*</span><br><span class="line">             某个线程执行到这,如果信号量值为1，执行了wait方法后，信号量的值变成了0。并开始执行下面的代码。</span><br><span class="line">             */</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             这时候信号量的值为0，其它线程都处于等待状态。这样对 mutableArr 进行修改的线程，</span><br><span class="line">             在任意时刻都只有一个，能够保证多线程下读写 mutableArr 的安全性</span><br><span class="line">             */</span><br><span class="line">            [mutableArr addObject:@(i)];</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             执行结束，要调用signal方法，把信号量的值加1。</span><br><span class="line">             这样，其他等待的线程按照等待的先后顺序继续访问 mutableArr</span><br><span class="line">             */</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;%@&quot;,mutableArr.lastObject);</span><br></pre></td></tr></table></figure></p><p><strong>信号量与互斥锁</strong></p><p><strong>信号量</strong>：关注的是信号，信号！可以使用在线程间和进程间。只要信号是允许的，线程就可以访问某个资源。<br><strong>互斥锁</strong>：只能用于线程间。使用时会锁住某个资源，只允许当前一个线程访问，其他线程无法访问，处于等待状态。解锁后其他处于等待状态的线程被唤醒，然后按照等待排队顺序继续访问。</p><p><strong>(7). dispatch_barrier 栅栏函数</strong></p><p>dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用，它等待所有位于 barrier 函数之前的队列中的任务执行完毕后，再执行barrier block 中的任务，并且等待 barrier block中的任务执行完毕之后，barrier函数后续的任务才会得到执行，该函数需要同dispatch_queue_create 函数生成的并发队列(concurrent queue) 一起使用。</p><p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrier</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;barrier&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：1 2 barrier 4 3  其中1 2 与 3 4 由于异步执行先后顺序可能有变，</span><br><span class="line">但是 barrier 一定位于他们中间。</span><br></pre></td></tr></table></figure></p><p>看一段<a href="https://developer.apple.com/documentation/dispatch#//apple_ref/c/func/dispatch_barrier_async" target="_blank" rel="noopener">官方文档</a>能够更好的理解：</p><blockquote><p>调用 dispatch_barrier_async 函数总会在 block 任务提交后立即返回，而不等待 block 被调用。</p></blockquote><blockquote><p>When the barrier block reaches the front of a private concurrent queue, it is not executed immediately. Instead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes.</p></blockquote><blockquote><p>The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create<br>function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_async<br>function.</p></blockquote><h3 id="多线程并发带来的陷阱"><a href="#多线程并发带来的陷阱" class="headerlink" title="多线程并发带来的陷阱"></a>多线程并发带来的陷阱</h3><p>使用并发编程会带来许多陷阱。一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。</p><p>关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务戛然而止，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为优先级反转，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。</p><p>并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性，一个对象，通用的内存、网络设备或者一个文件等等。在多线程中，任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计，以防止这种冲突的发生。</p><p>为了演示这类问题，我们举一个关于资源的简单示例：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。问题来了，你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。</p><p>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。</p><img src="/2018/07/06/细说iOS并发编程/race_condition.png" title="[]"><p>这个问题被叫做<a href="https://en.wikipedia.org/wiki/Race_condition#Software" target="_blank" rel="noopener">竞态条件</a>，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p><p>在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序。</p><p><strong>互斥锁</strong></p><p>互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的<a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29" target="_blank" rel="noopener">互斥锁</a>，只有当某个线程对资源完成了操作，释放掉这个互斥锁，这样别的线程才有机会访问该共享资源。</p><img src="/2018/07/06/细说iOS并发编程/Mutex.png" title="[]"><p>除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障(Memory barrier)</a>。通过设置 Memory barrier，来确保没有无序执行的指令能跨过屏障而执行。</p><p>当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：<a href="https://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发技术</a>。</p><p>从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。</p><p>在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。</p><p>锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(<a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29#Granularity" target="_blank" rel="noopener">锁的竞争</a>是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。</p><p>在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出<a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="noopener">临界区段</a>（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。</p><p>我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 CPU strategy view 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。</p><p><strong>死锁</strong></p><p>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些<a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29#The_problems_with_locks" target="_blank" rel="noopener">其他问题</a>，其中一个就是<a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">死锁</a>。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。</p><img src="/2018/07/06/细说iOS并发编程/dead_lock.png" title="[]"><p>看看下面的代码，它交换两个变量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void swap(A, B)</span><br><span class="line">&#123;</span><br><span class="line">    lock(lockA);</span><br><span class="line">    lock(lockB);</span><br><span class="line">    int a = A;</span><br><span class="line">    int b = B;</span><br><span class="line">    A = b;</span><br><span class="line">    B = a;</span><br><span class="line">    unlock(lockB);</span><br><span class="line">    unlock(lockA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap(X, Y); // 线程 1</span><br><span class="line">swap(Y, X); // 线程 2</span><br></pre></td></tr></table></figure></p><p>此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。</p><p>再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。</p><p><strong>资源饥饿（Starvation)</strong></p><p>当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起读写问题。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。</p><p>为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 writer preference，或者使用 read-copy-update 算法。Daniel 在底层并发编程 API 中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。</p><p><strong>优先级反转</strong></p><p>本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的优先级反转。</p><p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。</p><p>高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。</p><img src="/2018/07/06/细说iOS并发编程/优先级反转.png" title="[]"><p>在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。</p><p>解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。</p><p>从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。</p><p>但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。</p><p>我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程是一个很有挑战的任务，它有许多错综复杂的问题和陷阱。在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文参考 &lt;a href=&quot;https://www.objc.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objc.io&lt;/a&gt; 上iOS多线程的一篇文章：&lt;a href=&quot;https://objccn.io/issue-2-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线程安全类的设计&lt;/a&gt;，以及 &lt;a href=&quot;https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;raywenderlich&lt;/a&gt; 上的 &lt;a href=&quot;https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grand Central Dispatch In-Depth:Part 1/2&lt;/a&gt; , &lt;a href=&quot;https://www.raywenderlich.com/148515/grand-central-dispatch-tutorial-swift-3-part-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grand Central Dispatch In-Depth:Part 2/2&lt;/a&gt; ，还有这篇 &lt;a href=&quot;http://mrpeak.cn/blog/ios-thread-safety/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS多线程到底不安全在哪里&lt;/a&gt;。同时c参考了苹果 Guides and Sample Code 中关于&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;并发编程&lt;/a&gt;的章节。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS dev" scheme="https://yangjie2.github.io/categories/iOS-dev/"/>
    
    
      <category term="iOS" scheme="https://yangjie2.github.io/tags/iOS/"/>
    
      <category term="并发编程" scheme="https://yangjie2.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
