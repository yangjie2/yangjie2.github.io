<!DOCTYPE html>













<html class="theme-next mist" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">




  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="对于iOS端，实现屏幕共享需要两个关键技术：屏幕内容采集和媒体流广播。前者需要系统提供相关权限，可以让开发者采集到app或者整个系统层面的屏幕上的内容，后者需要系统提供采集到实时的视频流和音频流，这样才能通过推流到服务器，实现媒体流的广播。">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS ReplayKit 屏幕共享研究">
<meta property="og:url" content="https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/index.html">
<meta property="og:site_name">
<meta property="og:description" content="对于iOS端，实现屏幕共享需要两个关键技术：屏幕内容采集和媒体流广播。前者需要系统提供相关权限，可以让开发者采集到app或者整个系统层面的屏幕上的内容，后者需要系统提供采集到实时的视频流和音频流，这样才能通过推流到服务器，实现媒体流的广播。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/App_Extention_Life_Cycle.png">
<meta property="og:image" content="https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/App_Extension_Communicate.png">
<meta property="og:image" content="https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/ReplayKit_Live.png">
<meta property="og:updated_time" content="2020-04-28T12:51:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS ReplayKit 屏幕共享研究">
<meta name="twitter:description" content="对于iOS端，实现屏幕共享需要两个关键技术：屏幕内容采集和媒体流广播。前者需要系统提供相关权限，可以让开发者采集到app或者整个系统层面的屏幕上的内容，后者需要系统提供采集到实时的视频流和音频流，这样才能通过推流到服务器，实现媒体流的广播。">
<meta name="twitter:image" content="https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/App_Extention_Life_Cycle.png">



  <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml" />




  <link rel="canonical" href="https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS ReplayKit 屏幕共享研究 | </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"></span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">空谷无人，水流花开</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS ReplayKit 屏幕共享研究
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-28 20:48:52 / Modified: 20:51:19" itemprop="dateCreated datePublished" datetime="2020-04-28T20:48:52+08:00">2020-04-28</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/28/iOS-ReplayKit-屏幕共享研究/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/04/28/iOS-ReplayKit-屏幕共享研究/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对于iOS端，实现屏幕共享需要两个关键技术：屏幕内容采集和媒体流广播。前者需要系统提供相关权限，可以让开发者采集到app或者整个系统层面的屏幕上的内容，后者需要系统提供采集到实时的视频流和音频流，这样才能通过推流到服务器，实现媒体流的广播。</p>
<a id="more"></a>
<h3 id="iOS-各个系统版本实现屏幕共享"><a href="#iOS-各个系统版本实现屏幕共享" class="headerlink" title="iOS 各个系统版本实现屏幕共享"></a>iOS 各个系统版本实现屏幕共享</h3><p>iOS系统屏幕共享技术，因系统版本而异。根据apple官方数据，截止到 2020 年 2 月，iOS13 占有率为70%，iOS12 占有率为 23%，其他更低版本为 7% 。 现在对各系统版本的实现方式和限制等方面进行比较说明。</p>
<h4 id="iOS8-及之前"><a href="#iOS8-及之前" class="headerlink" title="iOS8 及之前"></a>iOS8 及之前</h4><p>实现方式：iOS8 系统不提供相关SDK，开发者只能通过一些trick的方式（例如通过破解苹果用于无线传输的airplay协议，使用协议的私有api相关功能），实现屏幕共享的直播。</p>
<p>存在的问题：存在系统兼容性和发布可靠性两个方面问题。由于使用私有api，无法保证系统更新之后还能继续使用，通常系统更新后需要重新适配api，并且可能无法通过appstore的代码审核，只能通过企业版本发布应用。</p>
<h4 id="iOS9"><a href="#iOS9" class="headerlink" title="iOS9"></a>iOS9</h4><p>实现方式： iOS9系统考虑到开发者在屏幕录制共享方面需求，禁用了之前被开发者使用的实现屏幕共享的私有api，提供了 ReplayKit SDK，并且通过这个SDK, 开发者可以将当前app中(仅支持app内录制)的操作屏幕画面录制下来，完成后可以进行查看、编辑、通过指定方式分享出去。通过上传到服务器，实现分享和直播的功能。</p>
<p>存在的问题：该方案只能将当前app（而不是整个手机上）的屏幕内容录制下来，并且无法将实时的音视频流提供出来，只能将最终录制完毕的整个mp4文件提供给开发者，所以实际上并非真正的屏幕的直播共享，无法保证实时性。</p>
<p><strong>关键代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 启动录制</span><br><span class="line">    </span><br><span class="line">[[RPScreenRecorder sharedRecorder] startRecordingWithMicrophoneEnabled:YES handler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, error);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 停止录制</span><br><span class="line"></span><br><span class="line">[[RPScreenRecorder sharedRecorder] stopRecordingWithHandler:^(RPPreviewViewController * _Nullable previewViewController, NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>⚠️</p>
<ol>
<li>使用 [RPScreenRecorder sharedRecorder] 启动录制，会首先请求用户同意使用摄像头和麦克风，主要考虑用户的隐私和权限，如果用户拒绝了，将无法进行录制。</li>
<li>录制的内容不会包含系统的UI，比如上方导航栏；</li>
<li>录制的内容会经过音视频编码，而不是原始的yuv或pcm数据；</li>
<li>录制的内容无法直接查看，必须通过RPPreviewViewController才能查看预览，或者分享，或者保存到本地相册中。而这个RPPreviewViewController在停止录制的接口回调中才能获取，也就是说，只有停止录制之后才能通过RPPreviewViewController操作录制的音视频。</li>
</ol>
<h4 id="iOS10"><a href="#iOS10" class="headerlink" title="iOS10"></a>iOS10</h4><p>首先介绍一个概念：App Extention</p>
<p>App Extention 是 iOS8 和 OSX 10.10 新增的一个很有意思的功能，可以对现有app添加扩展进程，这在一定程度上弥补iOS的沙盒机制对应用间通信的限制。App Extention 的出现，为用户提供了在其它app中使用我们提供的服务的快捷方式，比如用户可以在 Today 的 widgets(小部件) 中查看应用展示的简略信息，而不用再进到我们的应用中，这将是一种全新的用户体验；但是，extension 的出现可能会减少用户启动应用的次数，同时还会增大开发者的工作量。</p>
<p>在一个App中创建一个Extention，这个App称为Extention的 Containing App，Extension不能单独存在和发布，随 Containing App 的安装而安装，随Containing App的发布而发布，一个Containing App 可以添加多个Extension。</p>
<p>Extension 的运行是独立的一个进程，Containing App 在没有启动的状态下，Extension仍然可以被启动和运行。</p>
<p>Extension 可以被系统直接调用，例如下拉通知栏查看同花顺行情时，就是由通知中心启动调用同花顺提供的extension。Extension 也可以被其它应用间接调用，例如在某个应用中调用搜狗输入法。</p>
<p>Extension 有自己的 Bundle Identifier，需要在开发者账号中注册App id 和创建 Provisioning profile。Extension 的 Bundle Identifier 必须以Containing App 的 Bundle Identifier为前缀。<br>例如：Containing App 的 Bundle Identifier 为 <code>com.demo.app</code><br>Extension 的 Bundle Identifier 必须为 <code>com.demo.app.xxx</code></p>
<p>Extension 不是一个App，所以生命周期和运行环境和App不同。在多数情况下，Extension是由用户在某一个App的界面或者某一个活动的控制器中启动，这个启动Extension的App被称为 Host App。Host App 提供Extension运行所需的上下文并通过发送一个Request的方式开启Extension的生命周期，Extension 在完成 Host App请求的任务后结束运行。</p>
<p><br></p>
<p><img src="/2020/04/28/iOS-ReplayKit-屏幕共享研究/App_Extention_Life_Cycle.png" alt=""></p>
<p><br></p>
<p>一般Extension 主要跟host app 进行通信，两者可以通过 ExtensionContext 直接通信:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//  RPBroadcastExtension.h</span><br><span class="line"></span><br><span class="line">/*! </span><br><span class="line">    @category NSExtensionContext (RPBroadcastExtension)</span><br><span class="line">    @abstract Category which defines the method to call from on an extension context object when user interaction is complete during the broadcast setup flow.</span><br><span class="line"> */</span><br><span class="line">@interface NSExtensionContext (RPBroadcastExtension)</span><br><span class="line"></span><br><span class="line">/*! @abstract Load information about the broadcasting app.</span><br><span class="line">    @param handler block which will be supplied a bundleID, displayName and an optional appIcon.</span><br><span class="line"> */</span><br><span class="line">- (void)loadBroadcastingApplicationInfoWithCompletion:(void(^)(NSString *bundleID, NSString *displayName, UIImage * __nullable appIcon))handler;</span><br><span class="line"></span><br><span class="line">/*! @abstract Method to be called when the extension should finish. Deprecated.</span><br><span class="line">    @param broadcastURL URL that can be used to redirect the user to the ongoing or completed broadcast. This URL is made available to the running application via a property in RPBroadcastController.</span><br><span class="line">    @param broadcastConfiguration Configuration to use for generating movie clips</span><br><span class="line">    @param setupInfo Dictionary that can be used to share any setup information required by the upload extension. The values and keys in this dictionary are to be defined by the extension developer.</span><br><span class="line"> */</span><br><span class="line">- (void)completeRequestWithBroadcastURL:(NSURL *)broadcastURL broadcastConfiguration:(RPBroadcastConfiguration *)broadcastConfiguration setupInfo:(nullable NSDictionary &lt;NSString *, NSObject &lt;NSCoding&gt; *&gt; *)setupInfo API_DEPRECATED(&quot;No longer supported&quot;, ios(10.0,11.0),tvos(10.0,11.0));</span><br><span class="line"></span><br><span class="line">/*! @abstract Method to be called when the extension should finish.</span><br><span class="line">    @param broadcastURL URL that can be used to redirect the user to the ongoing or completed broadcast. This URL is made available to the running application via a property in RPBroadcastController.</span><br><span class="line">    @param setupInfo Dictionary that can be used to share any setup information required by the upload extension. The values and keys in this dictionary are to be defined by the extension developer.</span><br><span class="line"> */</span><br><span class="line">- (void)completeRequestWithBroadcastURL:(NSURL *)broadcastURL setupInfo:(nullable NSDictionary &lt;NSString *, NSObject &lt;NSCoding&gt; *&gt; *)setupInfo API_AVAILABLE(ios(11.0),tvos(11.0));</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>Extension 跟 Containing App 一般不进行通信。甚至Extension在运行的时候，Containing App 都没有启动和运行。Extension 无法直接读取Containing App 的沙盒数据。</p>
<p>A Today widget (and no other app extension type) can ask the system to open its containing app by calling the openURL:completionHandler: method of the NSExtensionContext class.</p>
<p>Extension 和 Containing App 可以通过共同读写一个被称为 Shared Resources 的存储区域共享本地存储数据，这是通过 App Groups 实现的。</p>
<p><img src="/2020/04/28/iOS-ReplayKit-屏幕共享研究/App_Extension_Communicate.png" alt="An app extension can communicate indirectly with its containing app"></p>
<p><br><br>iOS10 系统推出了屏幕共享广播的 Extention，分别是 Broadcast Upload Extention 和 Broadcast Setup UI Extention。通过这两个 extention，可以为我们的app添加屏幕共享功能：将音视频流进行处理分发，并实时直播。</p>
<p>实现方式： iOS10 增加了音视频流实时广播功能，可以让我们实时的获取音视频流。支持代码控制录制的启动，想要录制当前app内的内容，必须通过其他app的extension，而启动这个extension必须通过集成 Replaykit 的 api。</p>
<p>存在的问题： 只能录制当前app内的内容，所以当app切到后台，录制内容将停止。这样会限制一些应用的使用场景。</p>
<p><strong>关键代码：</strong></p>
<p>iOS10 中屏幕录制 extention 作为一个独立进程，可供所有app调用。不能通过代码直接启动录制 Extention 进程。而是需要被录制端(Host App)通过下面代码弹出支持录制 Extention 的列表sheet：</p>
<p>被录制端(Host App，游戏或应用)的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ReplayKit/ReplayKit.h&gt;</span><br><span class="line"></span><br><span class="line">// 弹出extention列表界面</span><br><span class="line"></span><br><span class="line">- (void)startScreenShareLive &#123;</span><br><span class="line">    [RPBroadcastActivityViewController loadBroadcastActivityViewControllerWithHandler:^(RPBroadcastActivityViewController * _Nullable broadcastActivityViewController, NSError * _Nullable error) &#123;</span><br><span class="line">        // 设置代理，通过代理方法的回调我们才能启动录制进程</span><br><span class="line">        broadcastActivityViewController.delegate = self;</span><br><span class="line">        [self presentViewController:broadcastActivityViewController animated:YES completion:nil];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MARK: - RPBroadcastActivityViewControllerDelegate</span><br><span class="line"></span><br><span class="line">- (void)broadcastActivityViewController:(RPBroadcastActivityViewController *)broadcastActivityViewController didFinishWithBroadcastController:(nullable RPBroadcastController *)broadcastController error:(nullable NSError *)error &#123;</span><br><span class="line">    [broadcastActivityViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">    [broadcastController startBroadcastWithHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;startBroadcastWithHandler error: %@&quot;, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果已经安装支持 Upload Extention 的App，上面步骤会弹出选择 extention 的 sheet 列表，点击一个 extention，系统会启动一个UI界面进程：Broadcast Setup UI Extention，这个进程通常用于让用户输入一些鉴权信息，或者自定义的其他页面，在启动录制进程 Broadcast Upload Extention 之前插入一个交互界面。</p>
<p>直播端（Containing App）的实现：</p>
<p>很多直播 App 本身已经支持通过摄像头进行视频流上传、直播，新增对 ReplayKit Live 的支持，只需要创建两个扩展的 target，分别是 Broadcast Setup UI Extension 和 Broadcast Upload Extension</p>
<p>Broadcast Setup UI Extention 负责广播前的一些交互工作，让用户填写直播平台的账号密码直播标题等信息。该 UI 界面什么时候会弹出，上面已经提到。</p>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BroadcastSetupViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation BroadcastSetupViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //自定义交互view</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    //userDidFinishSetup 需要被调用，可以在这里调用，或者自定义的其他action方法中调用</span><br><span class="line">    [self userDidFinishSetup];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Call this method when the user has finished interacting with the view controller and a broadcast stream can start</span><br><span class="line">- (void)userDidFinishSetup &#123;</span><br><span class="line">    </span><br><span class="line">    // URL of the resource where broadcast can be viewed that will be returned to the application</span><br><span class="line">    NSURL *broadcastURL = [NSURL URLWithString:@&quot;http://apple.com/broadcast/streamID&quot;];</span><br><span class="line">    </span><br><span class="line">    // Dictionary with setup information that will be provided to broadcast extension when broadcast is started</span><br><span class="line">    NSDictionary *setupInfo = @&#123; @&quot;broadcastName&quot; : @&quot;example&quot; &#125;;</span><br><span class="line">    </span><br><span class="line">    // Tell ReplayKit that the extension is finished setting up and can begin broadcasting</span><br><span class="line">    [self.extensionContext completeRequestWithBroadcastURL:broadcastURL setupInfo:setupInfo];</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * For iOS 10, use the following codes instead.</span><br><span class="line">     </span><br><span class="line">    RPBroadcastConfiguration * broadcastConfig = [[RPBroadcastConfiguration alloc] init];</span><br><span class="line">    [self.extensionContext completeRequestWithBroadcastURL:broadcastURL broadcastConfiguration:broadcastConfig setupInfo:setupInfo];</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)userDidCancelSetup &#123;</span><br><span class="line">    // Tell ReplayKit that the extension was cancelled by the user</span><br><span class="line">    [self.extensionContext cancelRequestWithError:[NSError errorWithDomain:@&quot;YourAppDomain&quot; code:-1 userInfo:nil]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在 Broadcast Setup UI Extention 的 BroadcastSetupViewController 类中，必须调用 <code>userDidFinishSetup</code>，才能回调到被录制端（Host App）中的代理 <code>RPBroadcastActivityViewControllerDelegate</code>，在该代理中调用 <code>startBroadcastWithHandler</code> 接口，则会启动 Broadcast Upload Extention 进程。Upload Extention 作用是接收并处理 Broadcast UI 传过来的用户信息，以及处理 RPBroadcastController 传过来的实时音视频流数据。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ReplayKit/ReplayKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface SampleHandler : RPBroadcastSampleHandler</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// To handle samples with a subclass of RPBroadcastSampleHandler set the following in the extension&apos;s Info.plist file:</span><br><span class="line">// - RPBroadcastProcessMode should be set to RPBroadcastProcessModeSampleBuffer</span><br><span class="line">// - NSExtensionPrincipalClass should be set to this class</span><br><span class="line"></span><br><span class="line">@implementation SampleHandler</span><br><span class="line"></span><br><span class="line">- (void)broadcastStartedWithSetupInfo:(NSDictionary&lt;NSString *,NSObject *&gt; *)setupInfo &#123; </span><br><span class="line"></span><br><span class="line">    // User has requested to start the broadcast. Setup info from the UI extension will be supplied. </span><br><span class="line">    NSLog(@&quot;broadcastStartedWithSetupInfo: %@&quot;, setupInfo); </span><br><span class="line">    //初始化，比如进程间通知的监听</span><br><span class="line">    [[RKStreamer shared] setupWithInfo:setupInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)broadcastPaused &#123; </span><br><span class="line">    // User has requested to pause the broadcast. Samples will stop being delivered.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)broadcastResumed &#123; </span><br><span class="line">    // User has requested to resume the broadcast. Samples delivery will resume.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)broadcastFinished &#123; </span><br><span class="line">    // User has requested to finish the broadcast.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType &#123; </span><br><span class="line">s   witch (sampleBufferType) &#123;</span><br><span class="line">        case RPSampleBufferTypeVideo:</span><br><span class="line">            [RKStreamer shared] pushVideoSampleBuffer:sampleBuffer];</span><br><span class="line">            break;</span><br><span class="line">        case RPSampleBufferTypeAudioApp:</span><br><span class="line">            [[RKStreamer shared] pushAudioSampleBuffer:sampleBuffer ofAudioChannel:kReplayKitAudioChannelApp];</span><br><span class="line">            break;</span><br><span class="line">        case RPSampleBufferTypeAudioMic:</span><br><span class="line">            [[RKStreamer shared] pushAudioSampleBuffer:sampleBuffer ofAudioChannel:kReplayKitAudioChannelMic];</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>首先会回调到 <code>broadcastStartedWithSetupInfo</code>c方法，这里我们通常进行了一些初始化，例如进程间通知的监听等。下面的几个方法 <code>broadcastPaused</code>、<code>broadcastResumed</code>、<code>broadcastFinished</code> 表示了录制进程的变化，通常我们会在其中添加进程通知，通知 Host App 这些变化。最后的 <code>processSampleBuffer</code> 方法就是最终采集到的音频、视频原始数据。其中音频未做混音，包括麦克音频pcm和app音频pcm，而视频输出为yuv数据。</p>
<p>以上这几个方法中的代码不能阻塞（例如写文件等慢操作），否则导致录制进程停止。</p>
<p>⚠️ RKStreamer 是一个单例类，封装了登录鉴权、处理音视频流、直播推流功能。使用单例，而不是在 <code>SampleHandler</code> 里处理，因为 <code>SampleHandler</code> 并不是 Broadcast Upload Extension 里的唯一一个实例，Upload Extension 会不断地创建很多个 SampleHandler 来处理 <code>CMSampleBufferRef</code>，而我们为了保存一些内部状态，必须使用一个固定的类实例来实现。</p>
<p>下面是 Host App 和 Extention 之间的交互图，可以更直观的看到他们是怎么工作的：</p>
<p><img src="/2020/04/28/iOS-ReplayKit-屏幕共享研究/ReplayKit_Live.png" alt=""></p>
<h5 id="iOS11"><a href="#iOS11" class="headerlink" title="iOS11"></a>iOS11</h5><p>这个版本的iOS提供了 ReplayKit2 这个升级的SDK,最重大的升级就是解决了iOS10中无法录制整个手机屏幕内容（只能录制当前app）的弊病，并且进一步提高集成sdk和实现屏幕录制直播的可用性。</p>
<p>实现方式: 支持录制App内和整个系统，若要仅录制当前App内的屏幕，直接使用iOS 10 的方法即可，不过iOS11增加了新接口，可以直接启动想要的录制 Extention 进程，跳过弹出列表sheet再点击选择 Extention 的过程。若要录制整个系统，iOS11不允许开发直接调用api来启动系统界别的录制，必须是用户通过手动启动。启动方法很复杂：用户点击进入手机设置页面-&gt; 控制中心-&gt; 自定义 , 找到屏幕录制的功能按钮，将其添加到控制中心。添加成功后，我们可以在手机上滑唤出控制界面，看到这个圆形启动录屏按钮，长按录屏按钮，弹出选择 Extention 界面，选中我们的 Extention 进程进行录制。</p>
<p>存在的问题： iOS11不允许开发直接调用api来启动系统级别的录制，必须是用户通过手动启动。而且手动启动的过程也比较复杂，门槛较高。</p>
<p>由于iOS11录制的启动为手动操作，并且开发者启动录制进程的App也无从知道是否已经启动，所以通常我们会在 broadcastStartedWithSetupInfo 中发出进程级通知，告知App，录制已经启动。</p>
<h5 id="iOS12"><a href="#iOS12" class="headerlink" title="iOS12"></a>iOS12</h5><blockquote>
<p>苹果WWDC 2018全球开发者大会宣布iOS12系统将要正式发布，大会在“ live screen broadcast with replaykit ”主题演讲中对iOS12系统将升级的ReplayKit2 SDK做了重点描述，其中提到将对iOS11系统中的ReplayKit2问题进行优化，使开发者可以通过接口直接启动屏幕录制，并完成直播，从而解决了iOS11系统还需要用户进行一系列复杂操作的问题。</p>
</blockquote>
<p>实现方式：支持api控制启动录制，iOS12还是会考虑用户的感知性，要求开发者必须通过replaykit提供的 RPSystemBroadcastPickerView 来展示启动的view，然后通过点击view上面的按钮才能启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 12.0, *)) &#123;</span><br><span class="line">    RPSystemBroadcastPickerView *picker = [[RPSystemBroadcastPickerView alloc] initWithFrame:CGRectMake(0, 0, 100, 200)];</span><br><span class="line">    picker.showsMicrophoneButton = YES;</span><br><span class="line">     //你的app对用upload extension的 bundle id， 必须要填写对</span><br><span class="line">    picker.preferredExtension = @&quot;com.ReplayKit2.ReplayKit2Liveios12.BroadcastUpload&quot;;</span><br><span class="line">    [self.view addSubview:picker];</span><br><span class="line">    picker.center = self.view.center;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Fallback on earlier versions</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后是总结，Fuck the apple!</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/26/Objective-C-如何hook-block/" rel="next" title="Objective-C 如何hook block">
                <i class="fa fa-chevron-left"></i> Objective-C 如何hook block
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/08/Objective-C-Method-Swizzling/" rel="prev" title="Objective-C Method Swizzling">
                Objective-C Method Swizzling <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Yang Jie" />
            
              <p class="site-author-name" itemprop="name">Yang Jie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yangjie2" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/users/8227142/y-jie" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS-各个系统版本实现屏幕共享"><span class="nav-number">1.</span> <span class="nav-text">iOS 各个系统版本实现屏幕共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS8-及之前"><span class="nav-number">1.1.</span> <span class="nav-text">iOS8 及之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS9"><span class="nav-number">1.2.</span> <span class="nav-text">iOS9</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS10"><span class="nav-number">1.3.</span> <span class="nav-text">iOS10</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#iOS11"><span class="nav-number">1.3.1.</span> <span class="nav-text">iOS11</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iOS12"><span class="nav-number">1.3.2.</span> <span class="nav-text">iOS12</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang Jie</span>

  

  
</div>








  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  

  
    <script id="dsq-count-scr" src="https://yangjie.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://yangjie2.github.io/2020/04/28/iOS-ReplayKit-屏幕共享研究/';
        this.page.identifier = '2020/04/28/iOS-ReplayKit-屏幕共享研究/';
        this.page.title = 'iOS ReplayKit 屏幕共享研究';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://yangjie.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





  












  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
