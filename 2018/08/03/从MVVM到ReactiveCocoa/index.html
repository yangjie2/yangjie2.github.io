<!DOCTYPE html>













<html class="theme-next mist" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">




  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="翻译自 Bob Spryn 的 ReactiveCocoa and MVVM, an Introduction这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。 MVC任何有经验的软件开发者都会熟悉 MVC 这个概念。它表示 Model View Contr">
<meta name="keywords" content="ReactiveCocoa,MVVM">
<meta property="og:type" content="article">
<meta property="og:title" content="从MVVM到ReactiveCocoa">
<meta property="og:url" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/index.html">
<meta property="og:site_name">
<meta property="og:description" content="翻译自 Bob Spryn 的 ReactiveCocoa and MVVM, an Introduction这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。 MVC任何有经验的软件开发者都会熟悉 MVC 这个概念。它表示 Model View Contr">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image1.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image2.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image3.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image4.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image5.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image6.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image7.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image8.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image9.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image10.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image11.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image12.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image13.png">
<meta property="og:updated_time" content="2018-08-04T06:43:52.877Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从MVVM到ReactiveCocoa">
<meta name="twitter:description" content="翻译自 Bob Spryn 的 ReactiveCocoa and MVVM, an Introduction这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。 MVC任何有经验的软件开发者都会熟悉 MVC 这个概念。它表示 Model View Contr">
<meta name="twitter:image" content="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/image1.png">



  <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml" />




  <link rel="canonical" href="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>从MVVM到ReactiveCocoa | </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"></span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">空谷无人，水流花开</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从MVVM到ReactiveCocoa
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-03 18:28:46" itemprop="dateCreated datePublished" datetime="2018-08-03T18:28:46+08:00">2018-08-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-08-04 14:43:52" itemprop="dateModified" datetime="2018-08-04T14:43:52+08:00">2018-08-04</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS-dev/" itemprop="url" rel="index"><span itemprop="name">iOS dev</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/03/从MVVM到ReactiveCocoa/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/08/03/从MVVM到ReactiveCocoa/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>翻译自 <a href="http://twitter.com/sprynmr" target="_blank" rel="noopener">Bob Spryn</a> 的 <a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/" target="_blank" rel="noopener">ReactiveCocoa and MVVM, an Introduction</a><br>这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>任何有经验的软件开发者都会熟悉 <strong>MVC</strong> 这个概念。它表示 <strong>Model</strong> <strong>View</strong> <strong>Controller</strong> ，是在复杂应用设计中一种久经考验的代码组织方式。在IOS开发中，MVC也被证实具有第二种含义：<strong>Massive View Controller</strong> (笨重的视图控制器) ，这让许多开发者困惑于如何优雅地对代码进行组织和解耦。IOS开发者需要给 view controller 瘦身，这是他们的共识。然而，怎么做呢？</p>
<a id="more"></a>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>为了解决上面的问题，<strong>MVVM</strong> 应运而生。它表示 <strong>Model</strong> <strong>View</strong> <strong>View-Model</strong> ，它帮助我们创建更易管理、具有良好设计的代码。<br>某些情况下违背Apple建议的编码方式没有多大意义，我不是说不赞成这么做，而是觉得这么做弊大于利。比如我不建议你去实现一个 View Controller 基类并试图自己处理VIew的生命周期。<br>带着这种思想，我不禁提出这样一个问题：使用Apple推荐的MVC之外的设计模式是不明智的吗？<br>不！原因有两点：<br>Apple 没有真正给出解决 <strong>Massive View Controller</strong> 问题的任何指导，他们将更多空间留给我们。MVVM 就是一种很酷的解决方式。</p>
<p>MVVM 能够与 MVC 很好的兼容，并将 MVC 延展到另一个层次。</p>
<p>关于 MVC/MVVM 的历史这里不做介绍了，我会更关注它在 iOS 开发中的应用。</p>
<h2 id="Defining-MVVM"><a href="#Defining-MVVM" class="headerlink" title="Defining MVVM"></a>Defining MVVM</h2><p><strong>Model</strong> - 在 MVVM 中，model 的作用并没有什么特别变化，我们仅把它当做存放数据-模型对象信息的结构体，而在单独的管理类中保留创建/管理model的统一逻辑。</p>
<p><strong>View</strong> - view中包含真正的UI本身(不管是 UIView 代码，还是 storyboard 和 Xib )、任何与视图有关的特定逻辑以及对用户输入的响应。这包括了许多由 UIViewController 负责处理的工作，不仅仅是UIView代码和文件。</p>
<p><strong>View-Model</strong> - 这个术语本身就会给我们带来困惑，它由两个我们熟悉的术语组合而成，但完全是不同的东西。它不是传统意义上 data-model 结构中 model 的作用。它的职责之一是作为一个静态模型，为视图展示自身提供必要的数据，但它也有收集、解释、转换这些数据的责任。这留给 View(Controller) 一个更加清晰明确的任务：将 View-Model 提供的数据呈现出来。</p>
<h2 id="More-about-the-view-model"><a href="#More-about-the-view-model" class="headerlink" title="More about the view-model"></a>More about the view-model</h2><p><strong>view-model</strong> 这个术语不足以描述我们的意图，一个更合适的名字可能是 “<strong>View Coordinator (视图协调器)</strong>”。它从<strong>资源</strong>(database，web service calls，etc)中收集原始数据，应用某种逻辑去处理修改造这些数据，加工成供 view(controller) 界面展示所需的数据。view-model (通常通过属性)仅仅暴露出来 view(controller) 显示所需的信息 (理想情况下不要暴露你的 data-model 对象)。它还负责处理上游数据的修改，比如更新模型/数据库, API POST 调用。</p>
<p><strong>MVVM in a MVC world</strong><br>在iOS开发中，我觉得 MVVM 这个首字母缩写像 view-model 一样词不达意，让我们再看下它是怎么适应MVC模式的。</p>
<p><strong>Here is a simple mapping of how these two patterns fit together in iOS:</strong> </p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image1.png" title="[]">
<p>说明：</p>
<ul>
<li><p>使用图形块的大小粗略的表示它负责的工作量的多少</p>
</li>
<li><p>注意看 view controller 部分有多大？</p>
</li>
<li><p>巨大的 view controller 和 view-model 之间有大块工作上的重合</p>
</li>
<li><p>view controller 和 MVVM 中的 view 也有一大部分的工作是重合的</p>
</li>
</ul>
<p>我们并不是要去除 view controller 这个概念，或者丢掉 “controller” 去匹配 MVVM，我们仅仅是将这部分重合的任务划分到 view-model 中，让 view controller 变得更加简单清晰。</p>
<p>最终得到的结果用图表示如下：</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image2.png" title="[]">
<p>现在，view controller 仅涉及配置和管理各种视图，这些视图的数据都来自 view-model，view controller 也负责在用户有输入动作发生时通知 view-model ，让 view-model 去修改上游数据。view controller 不需要知道有关web service calls, Core Data, model objects 等的一些东西。</p>
<p>view-model 也是一个对象，它会以一个属性的方式存在于 view controller 中，视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知。你或许已经感觉到这种设计好多了，因为在这里我们对相关工作做了很好的分离。</p>
<p>下图展示了这种 MVVM 模式下新的应用设计结构：</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image3.png" title="[]">
<p>这张图或许能更好的帮助你理解。</p>
<h2 id="View-Model-and-View-Controller-together-but-separate"><a href="#View-Model-and-View-Controller-together-but-separate" class="headerlink" title="View-Model and View Controller, together but separate"></a>View-Model and View Controller, together but separate</h2><p>举个栗子：为了情节简单, 让我们构建一个简化的twitter客户端，任何使用推特的用户，只要输入用户名，就可以查阅最近的回复。 我们的例子交互和界面如下:</p>
<ul>
<li>有一个 <code>UITextField</code>，让用户可以输入名字，一个 “Go” <code>UIbutton</code></li>
<li>有一个 <code>UIImageView</code>和一个 <code>UILabel</code> ，用于显示当前被查看的用户的头像和姓名</li>
<li>下面有一个 <code>UITableView</code>，显示最近的推文回复。</li>
<li>允许无限滚动</li>
</ul>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image4.png" title="[]">
<h4 id="The-Example-View-Model"><a href="#The-Example-View-Model" class="headerlink" title="The Example View-Model"></a>The Example View-Model</h4><p>view-model 的头文件如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface MYTwitterLookupViewModel: NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly, getter=isUsernameValid) BOOL usernameValid;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *userFullName;</span><br><span class="line">@property (nonatomic, strong, readonly) UIImage *userAvatarImage;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *tweets;</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL allTweetsLoaded;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readwrite) NSString *username;</span><br><span class="line"></span><br><span class="line">- (void) getTweetsForCurrentUsername;</span><br><span class="line">- (void) loadMoreTweets;</span><br></pre></td></tr></table></figure></p>
<p>头文件很简单。注意到所有这些壮观的 <strong>readonly</strong>属性了吗？view-model 仅暴露我们的 view controller 需要的最少的信息，而且 view conreoller 不关心 view-model 是怎么得到这些信息的。</p>
<h4 id="view-model-不做的事情"><a href="#view-model-不做的事情" class="headerlink" title="view-model 不做的事情"></a>view-model 不做的事情</h4><ul>
<li>通过任何形式直接作用于 view controller，或者直接通知控制器关于自己的一些变化。</li>
</ul>
<h4 id="The-Example-View-Controller"><a href="#The-Example-View-Controller" class="headerlink" title="The Example View Controller"></a>The Example View Controller</h4><p>视图控制器使用从 view-model 获取的数据去做:</p>
<ul>
<li>当<code>usernameValid</code>值变化时，触发“Go”按钮的<code>enabled</code>属性</li>
<li>当 <code>usernameValid</code> 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为1.0)</li>
<li>使用 <code>userFullName</code>更新 UILabel 的文本内容</li>
<li>使用 <code>userAvatarImage</code>更新 UIImageView 的 image</li>
<li>使用数组 <code>tweets</code>配置 table view 的 cells</li>
<li>当滑动到 table view 的底部时，如果 <code>allTweetsLoaded</code>为 NO，提供一个显示“loading”的 cell </li>
</ul>
<h4 id="View-Controller将通过如下方式作用于-view-model-："><a href="#View-Controller将通过如下方式作用于-view-model-：" class="headerlink" title="View Controller将通过如下方式作用于 view-model ："></a>View Controller将通过如下方式作用于 view-model ：</h4><ul>
<li>每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username</li>
<li>当 “Go” 按钮被按下时，调用 view-model 上的 getTweetsForCurrentUsername 方法</li>
<li>当到达表格中的 “loading” cell 时，调用 view-model 上的 loadMoreTweets 方法</li>
</ul>
<h4 id="view-controller-不做的事情"><a href="#view-controller-不做的事情" class="headerlink" title="view controller 不做的事情"></a>view controller 不做的事情</h4><ul>
<li>发起网络服务调用</li>
<li>管理 tweets 数组</li>
<li>判定 username 内容是否有效</li>
<li>将用户的姓和名格式化为全名</li>
<li>下载用户头像并转成 UIImage</li>
<li>挥洒汗水</li>
</ul>
<p><strong>再次注意，视图控制器的总责任是如何处理 view-model 中的变化</strong></p>
<p>#####Child View-Models<br>上面提到，我们使用 view-model 的 tweets 数组配置表格中的cell。通常你期望用来展示 tweets 的是这些 data-model 对象。但是上面提到，MVVM 模式下，不会暴露 data-model 对象，这时候你正感受到深深的恶意。。。</p>
<p><strong>不需要仅使用一个 view-model 代表屏幕上展示的所有东西！</strong> 你可以使用 child view-model 表示更小的、潜在的更具封装性的部分：如果某一小块视图(比如 cell)在你的app中可以复用，或者它表示多个 data-model 对象，这么做将会十分有益。</p>
<p>你并不总是需要 child view-models。比如，我可以使用一个 table header view 来渲染我们的app “tweetboat plus”顶部部分，它不是一个可复用组件，所以我仅需要传入 view controller 使用的那个相同的 view-model 给这个自定义 header view 就可以了。它从那个 veiw-model 中获取自己需要的信息而忽略其他的。这是一个让你的子视图保持同步的特别棒的方法，因为它们都可以有效地使用相同的信息上下文，并观察与更新相同的属性。</p>
<p>在我们示例app中，<code>tweets</code>数组内放置的是 <strong>子view-model</strong>，大概长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface MYTweetCellViewModel: NSObject</span><br><span class="line"> </span><br><span class="line">@property (nonatomic, strong, readonly) NSString *tweetAuthorFullName;</span><br><span class="line">@property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *tweetContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>你可能会觉得，这个子view-model也太像通常意义的 data-mode 对象了吧？为什么要把它转换成 view-model ？ 尽管很相似，但是 view-model 让我们能够限制信息，仅暴露出我们需要的部分；提供可能转换数据的其他属性；或者为特定视图计算数据 (再说下，一种很好的设计方式是尽可能不要暴露可变的 data-model 对象，因为我们希望 view-model 自己负责修改更新他们，而不是 view 或者 view controler)。</p>
<h2 id="View-Model-从哪来"><a href="#View-Model-从哪来" class="headerlink" title="View-Model 从哪来?"></a>View-Model 从哪来?</h2><p>那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么?</p>
<h4 id="View-Model-产生-View-Model"><a href="#View-Model-产生-View-Model" class="headerlink" title="View-Model 产生 View-Model"></a>View-Model 产生 View-Model</h4><p>严格来讲，你应该在 app delegate 中为顶级视图控制器创建一个 view-model。当展示一个新的 view controller 或者一个很小的视图(这个小的视图使用 view-model 表示)时，要让当前的这个 view-model 为你创建需要的 child view-model 。</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image5.png" title="[]">
<p>假如我们想要在用户点击应用顶部的头像时，添加一个资料视图控制器，我们可以为当前主 view-model 添加一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser;</span><br></pre></td></tr></table></figure>
<p>在我们的主控制器中，可以像这样使用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction) didTapPrimaryUserAvatar</span><br><span class="line">&#123;</span><br><span class="line">    MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser];</span><br><span class="line">    </span><br><span class="line">    MYTwitterUserProfileViewController *profileViewController = </span><br><span class="line">        [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel];</span><br><span class="line">    [self.navigationController pushViewController: profileViewController animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我想弹出一个用户资料视图控制器，但是这个控制器需要一个 view-model。我的主控制器并不知道关于这个用户的数据信息，无法创建这个view-model(也不应该要它创建)，所以，我的主控制器让它的 view-model 去做这项苦差事。</p>
<h4 id="view-model-列表"><a href="#view-model-列表" class="headerlink" title="view-model 列表"></a>view-model 列表</h4><p>回到推特例子中 table view 的 cell，当数据通过网络请求被拿到后，我会特意提前将对应cell的所有view-model创建好。所以在我们这里，主view-model的<code>tweets</code>数组内是<code>MYTweetCellViewModel</code>对象。在 table view 的 <code>cellForRowAtIndexPath</code>方法中，我会简单地在正确的索引位置从<code>tweets</code>数组中抓取子view-model，将它赋值给 cell 的 view-model 属性。</p>
<h2 id="Functional-Core-Imperative-Shell-函数式内核，命令式外壳"><a href="#Functional-Core-Imperative-Shell-函数式内核，命令式外壳" class="headerlink" title="Functional Core, Imperative Shell (函数式内核，命令式外壳)"></a>Functional Core, Imperative Shell (函数式内核，命令式外壳)</h2><h4 id="Functional-Core-函数式内核"><a href="#Functional-Core-函数式内核" class="headerlink" title="Functional Core(函数式内核)"></a>Functional Core(函数式内核)</h4><p>view-model 就是我们的函数式内核 <a href="http://www.smashingmagazine.com/2014/07/02/dont-be-scared-of-functional-programming/" target="_blank" rel="noopener">“functional core”</a>”，尽管实际上在 iOS/Objective-C 中达到纯函数级别是很棘手的(Swift 提供了一些附加的函数性, 这会让我们更接近)。一般的想法是让 view-model 尽可能少地依赖和影响应用程序的其它部分。这是什么意思？回想一下你刚开始学编程时遇到的简单的函数，它们接受一两个输入参数，并输出一个结果值。<strong>Data in, data out</strong>。也许这个函数做了一些数学计算或者字符串拼接。不管应用程序中发生了什么，相同的输入，就会得到相同的输出。这就是 <font color="#0099ff">函数式 </font>。</p>
<p>我们使用 view-model ，就是想得到函数式结果。view-model 内部包含逻辑与功能，将数据转换并存储在它的属性中。理想情况下，相同的输入将导致相同的输出结果。这意味着可以尽可能多的消除应用程序的其它部分对输出结果的影响，比如使用大量的状态值。<strong>我们要做的第一步就是在你的view-model的头文件中不要包含UIKit.h</strong>（这是一个很好的原则，但也有一些灰色区域：比如，你可能会将UIImage看作数据，而不是视图（我喜欢这样）。在这种情况下，你需要UIKit.h来获得UIImage类）。UIKit 的性质就决定了它会严重影响应用程序的许多地方，它含有很多副作用，更改一个值或调用一个方法将触发许多间接(甚至不可知)的更改。</p>
<p><strong>update：</strong>  需要理解你的 view-model 仍然是一个 object，并且的确需要维持一些状态(否则它对你的视图来说就不是一个非常有用的模型了)。但你仍然应该努力将尽可能多的逻辑转移到无状态函数的“值”中(swift 在这方面比 Objective-C 更可行)。</p>
<h4 id="Imperative-Declarative-Shell（命令式（声明式？）外壳）"><a href="#Imperative-Declarative-Shell（命令式（声明式？）外壳）" class="headerlink" title="Imperative (Declarative?) Shell（命令式（声明式？）外壳）"></a>Imperative (Declarative?) Shell（命令式（声明式？）外壳）</h4><p>我们将 view-model 数据转换成屏幕所显示的东西，需要做一系列工作，比如所有的状态改变，应用内其它部分的改变，命令式外壳就是我们做这些脏活儿累活儿的地方。这就是我们的 view (controller)，我们处理 UIKit 的地方。我依然特别注意尽可能的减少状态变量，将这一系列工作用声明式的方式完成，例如使用ReactiveCocoa。但本质上，iOS和UIKit是命令式的。</p>
<h4 id="Testable-Core"><a href="#Testable-Core" class="headerlink" title="Testable Core"></a>Testable Core</h4><p>iOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注: mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法)</p>
<p>这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是变得非常能够进行单元测试. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 现在我们将数据的获取/逻辑/转换从 view controller 中提取出来, 避免了视图控制器的复杂性. 那意味着测试时不需要用疯狂的 mock 对象, method swizzling, 或其他疯癫的变通方法(希望能有)了。</p>
<h2 id="Connecting-Everything"><a href="#Connecting-Everything" class="headerlink" title="Connecting Everything"></a>Connecting Everything</h2><p>那么，当 view-model 上的公开属性值变化时，我们怎么更新视图呢？</p>
<p>大多时候，我们使用相应的 view-model 去初始化 view controller，类似在上文见到的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MYTwitterUserProfileViewController *profileViewController =</span><br><span class="line">[[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel];</span><br></pre></td></tr></table></figure></p>
<p>有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在该 view (controller) 中暴露一个公有可写的 view-model 属性.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYTwitterUserCell *cell =</span><br><span class="line">    [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath];</span><br><span class="line">// grab the cell view-model from the vc view-model and assign it</span><br><span class="line">cell.viewModel = self.viewModel.tweets[indexPath.row];</span><br></pre></td></tr></table></figure></p>
<p>有时候可以在钩子程序执行前传入 view-model，比如 <code>init</code>或者 <code>viewDidLoad</code>，这样，我们可以使用 view-model 提供的属性值初始化所有UI部件的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">    _viewModel = viewModel;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _goButton.enabled = viewModel.isUsernameValid;</span><br><span class="line">    _goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5;</span><br><span class="line">    // etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很棒！我们已经配置好了初始值。当 view-model 中的数据变化时，怎么更新UI部件的状态？怎么将按钮变为不可用？我们的用户名label和头像将如何被网络请求的结果所填充?</p>
<p>将 viewcontroller 设置为 view-model 的代理？数据变化时，view-model 发送通知？ 不不不。。</p>
<p>我们的视图控制器能够知道一些变化的发生。可以使用 <code>UITextfield</code> 的代理方法，通过每次有输入字符变动时检查 view-model ，来更新<code>button</code>的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)textFieldDidChange:(UITextField *)sender &#123;</span><br><span class="line">    // update the view-model</span><br><span class="line">    self.viewModel.username = sender.text;</span><br><span class="line">    // check if things are now valid</span><br><span class="line">    self.goButton.enabled = self.viewModel.isUsernameValid;</span><br><span class="line">    self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 isUsernameValid 值. 假使还有其他变量/动作改变 isUsernameValid 的状态将会怎么样? 对于 view-model 中的网络请求又如何呢?或许我们该为 view-model 中的方法加一个完成后回调处理, 这样我们在那个节点就可以更新 有关UI 的一切东西了?使用古老而笨重的KVO方法？</p>
<p>最终，我们可以使用我们所熟悉的各种机制来连接 view-model 和 view (controller) 中的所有接触点，但是你知道标题上可不是这么写的。这种方式在代码中创建了大量的入口点，就算是简单的UI更新，也必须完全重新创建应用程序状态的上下文。</p>
<h2 id="Enter-ReactiveCocoa"><a href="#Enter-ReactiveCocoa" class="headerlink" title="Enter ReactiveCocoa"></a>Enter ReactiveCocoa</h2><p>ReactiveCocoa (RAC) 是来拯救我们的。让我们看看它是怎么做的。</p>
<p>考虑通过一个新的用户界面来控制信息的流动：该界面在表单有效时更新提交按钮的状态。以下是你目前的工作方式:</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image6.png" title="[]">
<p>最终，通过使用状态，谨小慎微地将自己简单的逻辑穿插在众多不同且无关的代码上下文中。看一下信息流中所有不同的入口点，是不是感觉乱糟糟的？(这还仅仅是一个UI元素的逻辑线) 。 我们在编程中使用的这些抽象还不够聪明，不能追踪所有这些事情的联系，所以最终还得自己做这些事儿。</p>
<h4 id="让我们看下“陈述式”的版本："><a href="#让我们看下“陈述式”的版本：" class="headerlink" title="让我们看下“陈述式”的版本："></a>让我们看下“陈述式”的版本：</h4><img src="/2018/08/03/从MVVM到ReactiveCocoa/image7.png" title="[]">
<p>这张图谱记录了我们应用程序的流程。通过这种陈述式编程，我们使用了一种更高级别的抽象，它让我们在实际的编程中，能够更接近我们自己脑海中的思维流。我们让电脑做更多的工作。现在实际的代码与这张图谱显得很接近了。</p>
<h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p>ReactiveCocoa核心就是 RACSignal。RACSignal (信号)对于 RAC 来说是构造单元。它是一个我们最终将会接收到的承载着信息的对象。<strong>当你有了一个在某个时间点将会收到的信息的具体表示形式时，那就开干吧！运用必要逻辑并预先构建你的信息流(声明式)</strong>，而不是必须等到事件发生时才这么做(响应式)。</p>
<p><strong>信号会捕获所有的异步方法(委托, 回调 block, 通知, KVO, target/action事件观察者，etc)来控制通过应用程序的信息流，并将他们统一在一个接口下。</strong>不仅如此，它还能够让你轻松的<strong>转换/分解/合并/过滤</strong> 流经你app的信息。</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image8.png" title="[]">
<p><strong>那么什么是信号呢，这就是一个信号：</strong></p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image9.png" title="[]">
<p>信号是一个发送一连串值的物体。但我们这里的信号什么都没做，因为它还没有任何订阅者。一个RAC信号仅当有订阅者去监听它时，它才会发出信息。它将向订阅者发送0或者载有数值的“next”事件，后面紧跟着一个 “complete” 事件或者一个 “error” 事件。信号不仅限于一次只向它的订阅者发送一个返回值。</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image10.png" title="[]">
<p>就像我前面提到的，如果需要的话你可以过滤, 转换, 分解，合并那些值。不同的订阅者可能需要由信号发出的这些数值的不同形式。</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image11.png" title="[]">
<h4 id="信号从哪里得到它们发送的值？"><a href="#信号从哪里得到它们发送的值？" class="headerlink" title="信号从哪里得到它们发送的值？"></a>信号从哪里得到它们发送的值？</h4><p>Signals 是一些等待事件发生的异步代码，当事件发生时就向它们的订阅者发送结果值。你可以使用 RACSignal 类中的类方法<br> <code>createSignal:</code> 手动创建这些信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;];</span><br><span class="line">        [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123;</span><br><span class="line">            [subscriber sendNext:result];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure></p>
<p>上面我创建了一个信号，我使用 RACSignal 提供的 <code>subscriber</code> 对象调用 <code>sendNext:</code> 和 <code>sendCompleted:</code> 方法(请求成功时)，或者调用 <code>sendError:</code>(请求失败时)。现在我可以订阅这个信号并在网络请求返回时接收到 json 值或是 error。</p>
<p>RAC 为我们提供了丰富的机制来从我们常用的现有异步模式中提取信号。如果你有一个异步任务没有覆盖在内置的信号中，你可以很容易地用 createSignal: 或类似方法来创建信号。</p>
<p>RAC提供的一个机制就是使用宏 <code>RACObserve()</code>，这个宏是对 KVO 中那些糟透的 API 的替代。你只需要传入一个对象以及在这个对象中你想要监听的属性的名称。给出这些参数后，<code>RACObserve ()</code>会生成一个信号，并立即向它的监听者发送这个属性的当前值，以及未来关于这个属性的任何变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid);</span><br></pre></td></tr></table></figure>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image12.png" title="[]">
<p>上面仅是创建信号的一种方式，下面有几种现成的从控制流机制中获得信号的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc)</span><br><span class="line">    // subscribeNext:^(UIButton *button) &#123; NSLog(@&quot;%@&quot;, button); // UIButton instance &#125;</span><br><span class="line"></span><br><span class="line">RACSignal *textChange = [myTextField rac_textSignal];</span><br><span class="line">    // some special methods are provided for commonly needed control event values off certain controls</span><br><span class="line">    // subscribeNext:^(UITextField *textfield) &#123; NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; &#125;</span><br><span class="line"></span><br><span class="line">RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal];</span><br><span class="line">    // signals for some delegate methods send the delegate params as the value</span><br><span class="line">    // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc</span><br><span class="line">    // (limited to methods that return void)</span><br><span class="line">    // subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; &#125;</span><br><span class="line"></span><br><span class="line">RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)];</span><br><span class="line">    // signals for arbitrary selectors that return void, send the method params as the value</span><br><span class="line">    // works for built in or your own methods</span><br><span class="line">    // subscribeNext:^(NSNumber *animated) &#123; NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear 1&quot; &#125;</span><br></pre></td></tr></table></figure></p>
<p>你也能轻松创建自己的信号, 包括<a href="http://spin.atomicobject.com/2014/02/03/objective-c-delegate-pattern/" target="_blank" rel="noopener">替代那些没有内置支持的其他委托</a>。我们现在可以将所有这些断了联系的异步/控制流工具中获得信号，将也可以将它们组合在一起，想想这是多么酷的事情！这些信号会成为上面看到的陈述式图谱中的nodes节点，开心吧。</p>
<h4 id="什么是订阅者？"><a href="#什么是订阅者？" class="headerlink" title="什么是订阅者？"></a>什么是订阅者？</h4><p>简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了(它也可以作用于 “complete” 和 “error” 事件)。<br><strong>再次注意，订阅者就是一段代码，而不是一个具体的对象。</strong></p>
<p>下面是一个简单的 subscriber，通过向信号的实例方法 <code>subscribeNext :</code> 传入一个 block 创建的。这里我们正在通过 RACObserve() 宏创建的这个信号，观察一个对象的某个属性的当前值, 并把这个属性值赋给一个内部属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">  // ...</span><br><span class="line">  // create and get a reference to the signal</span><br><span class="line">  RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid);</span><br><span class="line">  // update the local property when this value changes</span><br><span class="line">  [usernameValidSignal subscribeNext:^(NSNumber *isValidNumber) &#123;</span><br><span class="line">          self.usernameIsValid = isValidNumber.boolValue</span><br><span class="line">      &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意 ：RAC 只处理对象, 而不处理像 BOOL 这样的原始值。 不过不用担心, RAC 通常会帮你处理这些转换。</p>
<p>RAC 作者也意识到这种绑定行为的普遍必要性。所以他们提供了另一个宏定义：<code>RAC()</code>。与 <code>RACObserve()</code> 类似，你提供一个对象和这个对象的属性名参数，传入的值就会绑定到这个对象的这个参数上。这个宏定义在内部就是做了上面 viewDidLoad 方法中的工作：创建订阅者，更新属性值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    //...</span><br><span class="line">    RAC(self, usernameIsValid) = RACObserve(self.viewModel, isUsernameValid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但考虑到我们的目的，这样做有点傻冒。我们并不真的需要将信号中的值存储到一个属性中(也会因此创建状态)，我们真正想做的是用从这个值中收集的信息来更新UI。</p>
<h4 id="转换数据流"><a href="#转换数据流" class="headerlink" title="转换数据流"></a>转换数据流</h4><p>现在我们开始看 RAC 为我们提供的转换数据流的值的方法。我们会用到 <code>RACSignal</code> 类提供的 <code>map</code> 实例方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    //...</span><br><span class="line">    RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);</span><br><span class="line">    RAC(self.goButton, enabled) = usernameIsValidSignal;</span><br><span class="line">    RAC(self.goButton, alpha) = [usernameIsValidSignal</span><br><span class="line">        map:^id(NSNumber *usernameIsValid) &#123;</span><br><span class="line">            return usernameIsValid.boolValue ? @1.0 : @0.5;</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们将 view-model 上的 <code>isUsernameValid</code> 属性所发生的更改直接绑定到 goButton 上的 <code>enabled</code>属性上。绑定 goButton 按钮的 <code>alpha</code> 属性显得更让人兴奋，因为我们使用 <code>map</code> 方法将信号的值转换成 <code>alpha</code> 属性的值。</p>
<h4 id="多个订阅者-副作用-昂贵的操作"><a href="#多个订阅者-副作用-昂贵的操作" class="headerlink" title="多个订阅者, 副作用, 昂贵的操作"></a>多个订阅者, 副作用, 昂贵的操作</h4><p>在订阅信号链时，你应当认识到这样一件非常重要的事，<strong>每当一个新值通过该信号链发送时，它实际上是每一个订阅者都会发送一次。</strong> 比如新增了一个订阅者去监听一个信号，那么信号会立即向订阅者发送信息，注意是所有订阅者！而不仅仅是你刚才新增的那个。信号发送出的信息(值)不会存储在任何地方(除了RAC的内部实现部分)，认识到这一点对我们来说是有意义的。当信号需要发送一个新的值时，它会遍历所有的订阅者，并给每个订阅者发送那个值。</p>
<p>这就意味着在你信号链的某处产生的任何副作用，任何影响应用程序世界的转换，都会多次发生。对于刚开始使用RAC的用户来说，这是意料之外的(这也违背了“函数式”思想—相同的输入，产生相同的输出)。</p>
<p>举个蹩脚的例子：有一个按钮点击事件信号，它会在信号链的某个地方更新一个计数属性，如果有多个订阅者监听了这个信号链，这个计数属性的增长比你想象的还要多。你需要从信号链中尽可能的剔除副作用，当副作用不可避免时, 你可以使用一些恰当的预防机制，我将会在另一篇文章中讨论。</p>
<p>除了副作用以外，你需要特别注意带有代价昂贵的操作和可变数据的信号链。网络请求是一个兼有以下三点的例子：</p>
<ol>
<li>网络请求影响你的 app 的网络层(副作用).</li>
<li>网络请求给信号链带来了可变数据. (两个完全一样请求可能返回了不同的数据)</li>
<li>网络请求反应慢</li>
</ol>
<p>例如，你有一个信号，每次点击按钮，信号就会发送一个值，你想转换这个值，并用转换结果进行网络请求从而得到请求结果。如果有多个订阅者要处理这个信号链返回的值，你将会发起多次网络请求。</p>
<img src="/2018/08/03/从MVVM到ReactiveCocoa/image13.png" title="[]">
<p>显然网络请求是经常需要的，如你所想，RAC 为这种情况提供了解决方案：RACCommand 和多点广播。我将在下一篇文章中深入讨论。</p>
<h2 id="Tweetboat-Plus"><a href="#Tweetboat-Plus" class="headerlink" title="Tweetboat Plus"></a>Tweetboat Plus</h2><p>简短的介绍之后，现在我们着手怎么将 view-model 和 view controller 使用 ReactiveCocoa 联系起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// View Controller</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">- (void) viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    RAC(self.viewModel, username) = [myTextfield rac_textSignal];</span><br><span class="line"></span><br><span class="line">    RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid);</span><br><span class="line"></span><br><span class="line">    RAC(self.goButton, alpha) = [usernameIsValidSignal</span><br><span class="line">        map: ^(NSNumber *valid) &#123;</span><br><span class="line">            return valid.boolValue ? @1 : @0.5;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    RAC(self.goButton, enabled) = usernameIsValidSignal;</span><br><span class="line"></span><br><span class="line">    RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage);</span><br><span class="line">    </span><br><span class="line">    RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName);</span><br><span class="line"></span><br><span class="line">    @weakify(self);</span><br><span class="line">    [[[RACSignal merge:@[RACObserve(self.viewModel, tweets),</span><br><span class="line">                        RACObserve(self.viewModel, allTweetsLoaded)]]</span><br><span class="line">        bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]]</span><br><span class="line">        subscribeNext:^(id value) &#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            [self.tableView reloadData];</span><br><span class="line">        &#125;];</span><br><span class="line">    </span><br><span class="line">    [[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">        subscribeNext: ^(id value) &#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            [self.viewModel getTweetsForCurrentUsername];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    // if table section is the tweets section</span><br><span class="line">    if (indexPath.section == 0) &#123;</span><br><span class="line">        MYTwitterUserCell *cell =</span><br><span class="line">        [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath];</span><br><span class="line">        </span><br><span class="line">        // grab the cell view model from the vc view model and assign it</span><br><span class="line">        cell.viewModel = self.viewModel.tweets[indexPath.row];</span><br><span class="line">        return cell;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // else if the section is our loading cell</span><br><span class="line">        MYLoadingCell *cell =</span><br><span class="line">        [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath];</span><br><span class="line">        [self.viewModel loadMoreTweets];</span><br><span class="line">        return cell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// MYTwitterUserCell</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// this could also be in cell init</span><br><span class="line">- (void) awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">    </span><br><span class="line">    RAC(self.avatarImageView, image) = RACObserve(self, viewModel.tweetAuthorAvatarImage);</span><br><span class="line">    RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName);</span><br><span class="line">    RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们来分析下上面的这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.viewModel, username) = [myTextfield rac_textSignal];</span><br></pre></td></tr></table></figure>
<p>这里使用RAC提供的方法，从 <code>UITextField</code> 中得到一个信号。上面这行代码将 view-model 的可读写属性 <code>username</code> 绑定到 textfield 的任何更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid);</span><br><span class="line"></span><br><span class="line">RAC(self.goButton, alpha) = [usernameIsValidSignal</span><br><span class="line">    map: ^(NSNumber *valid) &#123;</span><br><span class="line">        return valid.boolValue ? @1 : @0.5;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RAC(self.goButton, enabled) = usernameIsValidSignal;</span><br></pre></td></tr></table></figure>
<p> 这里我们使用宏 <code>RACObserve()</code> 在 view-model 的 <code>usernameValid</code> 属性上创建一个信号 <code>usernameIsValidSignal</code>，不管什么时候只要这个属性值有变化，这个信号就会沿着管道(pipe)发送一个新的 @YES 或 @NO 值。我们将这个值绑定到 <code>goButton</code> 的两个属性上。</p>
<p>接着，通过使用宏 <code>RACObserve</code> 在对应的 view-model 属性上创建信号，为 table view 表头的 image view 和 user label 创建绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage);</span><br><span class="line"></span><br><span class="line">RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName);</span><br></pre></td></tr></table></figure></p>
<p>下面这段代码看起来有点棘手，所以让我们多花点时间在这里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[[[RACSignal merge:@[RACObserve(self.viewModel, tweets),</span><br><span class="line">                     RACObserve(self.viewModel, allTweetsLoaded)]]</span><br><span class="line">    bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]]</span><br><span class="line">    subscribeNext:^(id value) &#123;</span><br><span class="line">        @strongify(self);</span><br><span class="line">        [self.tableView reloadData];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p> 我们希望在 view-model 里的 <code>tweets</code> 数组和 <code>allTweetsLoaded</code> 属性发生变化时就能立刻更新 table view。所以我们将观察这两个属性的信号两个信号合并成一个“大信号”，这样，当这两个属性有任何一个变化时，这个合并后的大信号就会发送一个值 (通常你希望信号的值是同类型的，而不是像这个信号那样混合着其他类型值。这可能会在 RAC swift 强制执行，但这里我们不关心发送的实际值，我们只是用它来触发 table view 的重新加载)。</p>
<p>所以这里有点吓人的部分可能是 <code>bufferWithTime:onScheduler:</code> 方法，这么做是为了解决 UIKit 中的一个问题。我们需要同时追踪 <code>tweets</code> 和 <code>allTweetsLoaded</code> 这两个属性，目的是为了防止其中一个发生变化而另一个没有变(有一个属性变化，就需要更新 table view)。问题是，有时这两个属性碰巧会在同一时间点发生变化，这意味着，合并产生的大信号中的两个小信号都将发送一个值，那么<code>reloadData</code> 将在同一个 run loop 中被连续调用两次。UIKit 不喜欢这样。<code>bufferWithTime:</code> 捕获任何在给定时间内发送过来的下一个值，当这段时间过去以后，再将这些值一并发送给订阅者。通过传入参数 0 ，<code>bufferWithTime:</code>方法将捕获在一个 run-loop 时间内由“大信号”发出的所有值，然后再将这些值一起发出去。别担心，就把它当做需要将这些值必须在主线程上传递。现在我们能够确保 <code>reloadData</code> 方法在每个run-loop 内只执行一次。<br><strong>注意</strong>：我们用到了 <code>@weakify/@strongify</code> 宏，这对打破循block引起的环引用非常重要。</p>
<p>下面这段代码展示出 <code>RACCommand</code> 将会发挥作用的地方，将在下一篇文章中介绍。就目前来说，当按钮被点击时，我们只是手动调用 view-model 的 <code>getTweetsForCurrentUsername</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">    subscribeNext: ^(id value) &#123;</span><br><span class="line">        @strongify(self);</span><br><span class="line">        [self.viewModel getTweetsForCurrentUsername];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>我们已经介绍了<code>cellForRowAtIndexPath</code> 的第一部分，所以这里只说下 loading cell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYLoadingCell *cell =</span><br><span class="line">[self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath];</span><br><span class="line">[self.tableView loadMoreTweets];</span><br><span class="line">return cell;</span><br></pre></td></tr></table></figure></p>
<p>这是将来我们使用 <code>RACCommand</code> 的另一个领域。现在我们只是调用 view-model 中的 <code>loadMoreTweets</code>方法。我们相信，如果 cell 隐藏并显示了多次，view-model 可以在内部避免多次调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void) awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line"></span><br><span class="line">    RAC(self.avatarImageView, image) = RACObserve(self, viewModel.userAvatarImage);</span><br><span class="line">    RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName);</span><br><span class="line">    RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This should be fairly straightforward now, aside from one thing I want to point out. We are binding an image and strings to the appropriate properties on our UI, but note that viewModel is on the right side of the comma in the RACObserve macro. These cells will end up getting reused and new view-models will be assigned. Instead of listening for the viewModel property to change and then re-setting up our bindings everytime, if we put viewModel on the right side of the comma, RACObserve is going to take care of that for us. So we only set up this binding ONCE and let Reactive Cocoa do the rest. This is a good thing to keep in mind for performance with bindings on table cells. In practice I’ve had no issues even with lots of table cells screaming around.</p>
<h4 id="额外的好处——消除更多的状态"><a href="#额外的好处——消除更多的状态" class="headerlink" title="额外的好处——消除更多的状态"></a>额外的好处——消除更多的状态</h4><p>有时候你在 view-model 中暴露出 <code>RACSignal</code> 而不是一些属性值会帮你消除 view-model 上更多的状态。这样，你的 view (controller) 就可以直接使用这些信号，而不必使用 <code>RACObserve</code>创建它自己的信号了。<strong>注意：如果在 UI 订阅/绑定这个信号之前，它就已经发送了一个值，那么你就会错过这个“初始”的值。</strong></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这是一种不同的编程风格，它为你提供了另一种与“命令式”完全不同的思路。即使你一开始并不会经常使用这种方式，但它仍然告诉你，有这样一位姑娘(RAC) 可以用她特有的方式为你解决困惑。</p>

      
    </div>

    

    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Yang Jie</li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/" title="从MVVM到ReactiveCocoa">https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ReactiveCocoa/" rel="tag"># ReactiveCocoa</a>
          
            <a href="/tags/MVVM/" rel="tag"># MVVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/06/IM消息的可靠投递/" rel="next" title="IM消息的可靠投递">
                <i class="fa fa-chevron-left"></i> IM消息的可靠投递
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/04/C-虚函数-纯虚函数/" rel="prev" title="[C++]虚函数,纯虚函数">
                [C++]虚函数,纯虚函数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Yang Jie" />
            
              <p class="site-author-name" itemprop="name">Yang Jie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yangjie2" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/users/8227142/y-jie" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC"><span class="nav-number">1.</span> <span class="nav-text">MVC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM"><span class="nav-number">2.</span> <span class="nav-text">MVVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-MVVM"><span class="nav-number">3.</span> <span class="nav-text">Defining MVVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#More-about-the-view-model"><span class="nav-number">4.</span> <span class="nav-text">More about the view-model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-Model-and-View-Controller-together-but-separate"><span class="nav-number">5.</span> <span class="nav-text">View-Model and View Controller, together but separate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Example-View-Model"><span class="nav-number">5.0.1.</span> <span class="nav-text">The Example View-Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#view-model-不做的事情"><span class="nav-number">5.0.2.</span> <span class="nav-text">view-model 不做的事情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Example-View-Controller"><span class="nav-number">5.0.3.</span> <span class="nav-text">The Example View Controller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View-Controller将通过如下方式作用于-view-model-："><span class="nav-number">5.0.4.</span> <span class="nav-text">View Controller将通过如下方式作用于 view-model ：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#view-controller-不做的事情"><span class="nav-number">5.0.5.</span> <span class="nav-text">view controller 不做的事情</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-Model-从哪来"><span class="nav-number">6.</span> <span class="nav-text">View-Model 从哪来?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#View-Model-产生-View-Model"><span class="nav-number">6.0.1.</span> <span class="nav-text">View-Model 产生 View-Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#view-model-列表"><span class="nav-number">6.0.2.</span> <span class="nav-text">view-model 列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functional-Core-Imperative-Shell-函数式内核，命令式外壳"><span class="nav-number">7.</span> <span class="nav-text">Functional Core, Imperative Shell (函数式内核，命令式外壳)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Functional-Core-函数式内核"><span class="nav-number">7.0.1.</span> <span class="nav-text">Functional Core(函数式内核)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Imperative-Declarative-Shell（命令式（声明式？）外壳）"><span class="nav-number">7.0.2.</span> <span class="nav-text">Imperative (Declarative?) Shell（命令式（声明式？）外壳）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Testable-Core"><span class="nav-number">7.0.3.</span> <span class="nav-text">Testable Core</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Connecting-Everything"><span class="nav-number">8.</span> <span class="nav-text">Connecting Everything</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enter-ReactiveCocoa"><span class="nav-number">9.</span> <span class="nav-text">Enter ReactiveCocoa</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#让我们看下“陈述式”的版本："><span class="nav-number">9.0.1.</span> <span class="nav-text">让我们看下“陈述式”的版本：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RACSignal"><span class="nav-number">9.0.2.</span> <span class="nav-text">RACSignal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号从哪里得到它们发送的值？"><span class="nav-number">9.0.3.</span> <span class="nav-text">信号从哪里得到它们发送的值？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是订阅者？"><span class="nav-number">9.0.4.</span> <span class="nav-text">什么是订阅者？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转换数据流"><span class="nav-number">9.0.5.</span> <span class="nav-text">转换数据流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个订阅者-副作用-昂贵的操作"><span class="nav-number">9.0.6.</span> <span class="nav-text">多个订阅者, 副作用, 昂贵的操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tweetboat-Plus"><span class="nav-number">10.</span> <span class="nav-text">Tweetboat Plus</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#额外的好处——消除更多的状态"><span class="nav-number">10.0.1.</span> <span class="nav-text">额外的好处——消除更多的状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结论"><span class="nav-number">11.</span> <span class="nav-text">结论</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang Jie</span>

  

  
</div>








  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  

  
    <script id="dsq-count-scr" src="https://yangjie.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://yangjie2.github.io/2018/08/03/从MVVM到ReactiveCocoa/';
        this.page.identifier = '2018/08/03/从MVVM到ReactiveCocoa/';
        this.page.title = '从MVVM到ReactiveCocoa';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://yangjie.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





  












  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
