<!DOCTYPE html>













<html class="theme-next mist" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">




  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="并发编程是一个很有挑战的任务，它有许多错综复杂的问题和陷阱。在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文参考 objc.io 上iOS多线程的一篇文章：线程安全类的设计，以及 raywenderlich 上的 Grand Central Dispatch In-Depth:Pa">
<meta name="keywords" content="iOS,并发编程">
<meta property="og:type" content="article">
<meta property="og:title" content="细说iOS并发编程">
<meta property="og:url" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/index.html">
<meta property="og:site_name">
<meta property="og:description" content="并发编程是一个很有挑战的任务，它有许多错综复杂的问题和陷阱。在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文参考 objc.io 上iOS多线程的一篇文章：线程安全类的设计，以及 raywenderlich 上的 Grand Central Dispatch In-Depth:Pa">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/并发与并行.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/image2.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/queues.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/serial_queue.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/concurrent_queue.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/dispatch_async.gif">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/dispatch_sync.gif">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/race_condition.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/Mutex.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/dead_lock.png">
<meta property="og:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/优先级反转.png">
<meta property="og:updated_time" content="2018-07-10T04:05:20.087Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="细说iOS并发编程">
<meta name="twitter:description" content="并发编程是一个很有挑战的任务，它有许多错综复杂的问题和陷阱。在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文参考 objc.io 上iOS多线程的一篇文章：线程安全类的设计，以及 raywenderlich 上的 Grand Central Dispatch In-Depth:Pa">
<meta name="twitter:image" content="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/并发与并行.png">



  <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml" />




  <link rel="canonical" href="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>细说iOS并发编程 | </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"></span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">空谷无人，水流花开</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangjie2.github.io/2018/07/06/细说iOS并发编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">细说iOS并发编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-06 14:00:48" itemprop="dateCreated datePublished" datetime="2018-07-06T14:00:48+08:00">2018-07-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-07-10 12:05:20" itemprop="dateModified" datetime="2018-07-10T12:05:20+08:00">2018-07-10</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS-dev/" itemprop="url" rel="index"><span itemprop="name">iOS dev</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/06/细说iOS并发编程/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/06/细说iOS并发编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>并发编程是一个很有挑战的任务，它有许多错综复杂的问题和陷阱。在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文参考 <a href="https://www.objc.io/" target="_blank" rel="noopener">objc.io</a> 上iOS多线程的一篇文章：<a href="https://objccn.io/issue-2-4/" target="_blank" rel="noopener">线程安全类的设计</a>，以及 <a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1" target="_blank" rel="noopener">raywenderlich</a> 上的 <a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1" target="_blank" rel="noopener">Grand Central Dispatch In-Depth:Part 1/2</a> , <a href="https://www.raywenderlich.com/148515/grand-central-dispatch-tutorial-swift-3-part-2" target="_blank" rel="noopener">Grand Central Dispatch In-Depth:Part 2/2</a> ，还有这篇 <a href="http://mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="noopener">iOS多线程到底不安全在哪里</a>。同时c参考了苹果 Guides and Sample Code 中关于<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1" target="_blank" rel="noopener">并发编程</a>的章节。</p>
<a id="more"></a>
<h3 id="并发编程相关的几个概念"><a href="#并发编程相关的几个概念" class="headerlink" title="并发编程相关的几个概念"></a>并发编程相关的几个概念</h3><p><strong>进程（Process）</strong> 简单来说，进程是指系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>
<p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单，是组成进程的子单元。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。说得再具体一些，线程就是“一个CPU执行的一条无分叉的命令序列”。所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。</p>
<p>同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间、文件描述符等。但每个线程都拥有自己的栈，寄存器，本地存储（thread-local storage）。一个进程可以有很多线程，每条线程并行执行不同的任务，称为多线程。</p>
<p>多个线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么多个线程就可以真正的并行处理，从而减少了完成某项操作所需要的总时间。</p>
<p><strong>并发(Concurrent)/并行(Parallel)</strong> 很多人对并发/并行的概念感到困惑，按照我的理解，并发所描述的概念是“同时”运行多个线程，多个线程“同时”被处理。这里对同时加了引号，因为这些线程可能是在单核 CPU 上以分时（时间共享）的形式，在极短的时间片段间不停的切换运行(类似通信中的时分复用(TDM))，也可能是在多核 CPU 上以真正的并行方式同时运行。</p>
<p>关于并发和并行，可以用下面这张有趣的图解释：</p>
<img src="/2018/07/06/细说iOS并发编程/并发与并行.png" title="[并发与并行]">
<p>如果还是不能理解，或许应该看下这段准确的英文解释：</p>
<blockquote>
<p>Concurrency and parallelism are often mentioned together, so it’s worth a short explanation to distinguish them from each other.</p>
<p>Separate parts of concurrent code can be executed “simultaneously”. However, it’s up to the system to decide how this happens — or if it happens at all.</p>
<p>Multi-core devices execute multiple threads at the same time via parallelism; however, in order for single-cored devices to achieve this, they must run a thread, perform a context switch, then run another thread or process. This usually happens quickly enough as to give the illusion of parallel execution</p>
<p>Although you may write your code to use concurrent execution under GCD, it’s up to GCD to decide how much parallelism is required. Parallelism requires concurrency, but concurrency does not guarantee parallelism.</p>
<p>The deeper point here is that concurrency is actually about structure. When you code with GCD in mind, you structure your code to expose the pieces of work that can run simultaneously, as well as the ones that must not be run simulataneously. If you want to delve more deeply into this subject, check out <a href="https://vimeo.com/49718712" target="_blank" rel="noopener">this excellent talk by Rob Pike</a>.</p>
</blockquote>
<p><strong>临界区(Critical Section)</strong> 不能被两个线程同时执行的一段代码叫做临界区。因为这段代码通常操控着一个共享的临界资源(一次仅允许一个线程使用的共享资源)，多个线程必须互斥的访问该临界资源。只能被单一线程/进程访问的共享资源，比如打印机等。</p>
<p><strong>竞态条件(Race Condition)</strong> 软件系统的正确行为依赖于多个线程交替执行的时序时，就会发生竞态条件。常见的竟态条件为：</p>
<ol>
<li>先检测后执行。执行依赖于检测的结果，而检测结果取决于多线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现问题。</li>
</ol>
<img src="/2018/07/06/细说iOS并发编程/image2.png" title="[]">
<p>对于 main 线程，如果文件a不存在，则创建文件a，但是在判断文件a不存在之后，Task线程创建了文件a，这时候先前的判断结果已经失效（main线程的执行依赖了一个错误的判断结果），此时文件a已经存在了，但是 main 线程还是会继续创建文件a，导致 Task 线程创建的文件a被覆盖、文件中的内容丢失等等问题。多线程环境中对同一个文件的操作要加锁。</p>
<ol>
<li>延迟初始化（最典型即为单例）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static MyObject *instance = nil;</span><br><span class="line">+ (instancetype)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    if (instance == nil) &#123;</span><br><span class="line">        instance = [[MyObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如线程thread1和线程thread2同时执行 shareInstance，thread1 看到 instance 为空，创建了一个新的 Obj 对象，此时 thread2 也需要判断 instance 是否为空，此时的 instance 是否为空取决于不可预测的时序：包括 thread1 创建 Obj 对象需要多长时间以及线程的调度方式，如果 thread2 检测时，instance为空，那么 thread2 也会创建一个 instance 对象</p>
<p><strong>死锁(Deadlock)</strong> Two (or sometimes more) threads are said to be deadlocked if they all get stuck waiting for each other to complete or perform another action. The first can’t finish because it’s waiting for the second to finish. But the second can’t finish because it’s waiting for the first to finish.(翻译水平有限，英文可以更好的理解)</p>
<p><strong>线程安全(Thread Safe)</strong> 是指代码在多线程或者并发任务下能够被安全调用，而不会引起任何问题(data corruption, crashing, etc)。非线程安全代码必须只能运行在单线程环境下。</p>
<p><strong>上下文切换(Context Switch)</strong> A context switch is the process of storing and restoring execution state when you switch between executing different threads on a single process(进程).</p>
<h3 id="iOS-和-OS-X-中的并发编程"><a href="#iOS-和-OS-X-中的并发编程" class="headerlink" title="iOS 和 OS X 中的并发编程"></a>iOS 和 OS X 中的并发编程</h3><p>苹果的移动和桌面操作系统中提供了相同的并发编程API。 这里会介绍 pthread 、 NSThread 、GCD 、NSOperationQueue，以及 NSRunLoop。实际上把 run loop 也列在其中是有点奇怪，因为它并不能实现真正的并行，不过因为它与并发编程有很大的关系，因此值得我们进行一些深入了解。</p>
<p>需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，也无法控制执行多长时间后将被暂停，以便轮换执行别的任务。开发者可以使用 <a href="https://en.wikipedia.org/wiki/POSIX_Threads" target="_blank" rel="noopener">POSIX 线程</a> API，或者 Objective-C 中提供的对该 API 的封装 NSThread，来创建自己的线程。下面这个小Demo利用 pthread 在一百万个数字中查找最小值和最大值，其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">struct inputInfo &#123;</span><br><span class="line">    uint32_t *intputValues;</span><br><span class="line">    size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct resultInfo &#123;</span><br><span class="line">    uint32_t min;</span><br><span class="line">    uint32_t max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void * findMinAndMax(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct inputInfo const * const info = (struct inputInfo *)arg;</span><br><span class="line">    uint32_t min = UINT32_MAX;</span><br><span class="line">    uint32_t max = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; info-&gt;count; i++) &#123;</span><br><span class="line">        uint32_t temp = info-&gt;intputValues[0];</span><br><span class="line">        min = MIN(temp, min);</span><br><span class="line">        max = MAX(temp, max);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arg);</span><br><span class="line">    struct resultInfo *const result = (struct resultInfo *)malloc(sizeof(*result));</span><br><span class="line">    result-&gt;max = max;</span><br><span class="line">    result-&gt;min = min;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 使用随机数字填充 inputValues</span><br><span class="line">    size_t const count = 1000000;</span><br><span class="line">    uint32_t inputValues[count];</span><br><span class="line">    </span><br><span class="line">    // 使用随机数字填充 inputValues</span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        inputValues[i] = (uint32_t)i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 开始4个寻找最小值和最大值的线程</span><br><span class="line">    size_t const threadCount = 5;</span><br><span class="line">    pthread_t tid[threadCount];</span><br><span class="line">    for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        struct inputInfo * const info = (struct inputInfo *) malloc(sizeof(*info));</span><br><span class="line">        size_t offset = (count / threadCount) * i;</span><br><span class="line">        info-&gt;intputValues = inputValues + offset;</span><br><span class="line">        info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class="line">        int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);</span><br><span class="line">        NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err);</span><br><span class="line">    &#125;</span><br><span class="line">    // 等待线程退出</span><br><span class="line">    struct resultInfo * results[threadCount];</span><br><span class="line">    for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        int err = pthread_join(tid[i], (void **) &amp;(results[i]));</span><br><span class="line">        NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err);</span><br><span class="line">    &#125;</span><br><span class="line">    // 寻找 min 和 max</span><br><span class="line">    uint32_t min = UINT32_MAX;</span><br><span class="line">    uint32_t max = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        min = MIN(min, results[i]-&gt;min);</span><br><span class="line">        max = MAX(max, results[i]-&gt;max);</span><br><span class="line">        free(results[i]);</span><br><span class="line">        results[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;min = %u&quot;, min);</span><br><span class="line">    NSLog(@&quot;max = %u&quot;, max);</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>
<p>NSThread 是 Objective-C 对 pthread 的封装，比直接使用 pthread 更方便些。但是不论使用 pthread 还是 NSThread 直接对线程操作，都是相对糟糕的编程体验。</p>
<p>直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。</p>
<p>下面介绍两种基于队列的并发编程API：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的<a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener">线程池</a>，来解决创建过多线程导致的问题。</p>
<h4 id="Grand-Central-Dispatch"><a href="#Grand-Central-Dispatch" class="headerlink" title="Grand Central Dispatch"></a>Grand Central Dispatch</h4><p>为了让开发者更加容易的充分利用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。</p>
<p>通过GCD，开发者不必再直接跟线程打交道。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</p>
<p>GCD中的两个核心概念是“任务”和“队列”，开发者只需专注于想要执行的“任务” block，然后添加到适当的“队列”中，这种形象的抽象方式更容易被人理解和使用。</p>
<p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 任务最终都将被放入到系统的全局队列和线程池中，如下图所示：</p>
<img src="/2018/07/06/细说iOS并发编程/queues.png" title="[系统队列和自定义队列]">
<p>我们强烈建议，在大多数情况下使用默认优先级的队列就可以了，如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。</p>
<p>虽然 GCD 是一个低层级的 C 语言 API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱，这些将在后面并发编程带来的问题中进行讨论。</p>
<p><strong>串行队列(Serial Queues)</strong> 串行队列中的任务，每次只执行一个，先前的任务执行完毕后，才会执行下一个。当然，你不会知道一个block结束与下一个block开始之间的时间间隔是多少，如下图所示：</p>
<img src="/2018/07/06/细说iOS并发编程/serial_queue.png" title="[串行队列]">
<p>这些任务的执行时间是在GCD的控制之下，你唯一能够确定的是：GCD每次只执行一个任务，任务执行顺序就是它们被加入队列的顺序。</p>
<p>因为在串行队列中两个任务不可能并发运行，所以就没有可能会同时访问同一个临界区的风险。所以仅对于这些任务而言，这种运行机制能够保护临界区避免发生竟态条件。所以，如果访问临界区的唯一方式是通过被提交到那个串行队列中的任务，那么你可以确保临界区是安全的。</p>
<p><strong>并发队列(Concurrent Queues)</strong> 在并发队列中，你能够保证的仅有一件事：任务的执行顺序就是它们被添加到队列中的顺序。对于每个任务的完成顺序、下一个任务什么时候开始以及在任意给定时间内正在运行的 blocks 数量都是不清楚的，这些完全取决去 GCD。下图展示了在GCD下4个并发任务的执行：</p>
<img src="/2018/07/06/细说iOS并发编程/concurrent_queue.png" title="[并发队列]">
<p>上图表达的意思是，一个 block 什么时候开始执行完全取决于 GCD，如果一个 blcok 的执行时间与另一个重叠，由 GCD 决定这个 block 是需要运行在另一个核心上，还是在同一个核心上通过上下文切换(context switch)的方式执行。</p>
<p>队列类型<br>系统提供了一个特殊的串行队列叫主队列(main queue)，像其他串行队列一样，主队列中的任务每次执行一个，但是能够确定的是，主队列中的所有任务都在主线程执行，主线程是唯一允许更新UI的线程。主队列用来向 UIViews 对象发送消息或者发送通知。</p>
<p>系统还提供了4种不同优先级的全局并发队列(Global Dispatch Queues)：background、low、default、high，优先级由低到高。需要注意的是，苹果的 API 也使用了这些队列，所以这些队列中并非只有你自己添加的任务。</p>
<p>最后，你还可以创建自定义串行/并发队列。也就是说，至少有五种队列可供选择：主队列、4个全局并发队列、自定义队列。</p>
<p>And that’s the big picture of dispatch queues!</p>
<p>GCD 的“艺术”归根结底在于选择合适的<a href="https://developer.apple.com/documentation/dispatch?language=objc" target="_blank" rel="noopener">队列派发函数(dispatch function)</a>将任务提交到特定队列中。下面举例说明几种常用的 dispatch function。</p>
<p><strong>(1). dispatch_async</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;First Log&quot;); // 1</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;Second Log&quot;); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个动态图生动的呈现出究竟发生了什么，左侧是代码中的断点，右侧是相关队列的状态：</p>
<img src="/2018/07/06/细说iOS并发编程/dispatch_async.gif" title="[]">
<ol>
<li>主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内；</li>
<li>viewDidLoad 在主线程执行</li>
<li>现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_async</li>
<li>dispatch_async 的 block 被添加到一个全局队列并且稍后将会执行它</li>
<li>在 dispatch_async 添加 block 到全局队列之后，viewDidLoad继续向下走，主线程把注意力放在剩余的任务上。与此同时，全局队列也正在并发的处理它的任务。再次提醒，全局队列中的任务将以 “FIFO” 的顺序出队(分发下去)，但是这些任务会被并发执行。</li>
<li>现在，被 dispatch_async 添加的 block 正在执行了</li>
<li>dispatch_async 的 block 执行完毕，所有的 NSLog 语句都已经将输出打印到了控制台。尽管在这个小例子中先执行了第二条打印任务，随后才执行第一条，不过 First Log 和 Second Log 打印顺序不定 —— 取决于在那个特定时间硬件正在处理的事情，你没有办法控制或者知晓哪条语句先执行。</li>
</ol>
<p><strong>什么时候以及怎样使用 dispatch_async 和各种队列</strong></p>
<ul>
<li>自定义串行队列：当你想在后台串行的执行任务并跟踪这个任务的执行状态时，使用自定义串行队列是一个好的选择。这样能消除资源竞争，因为在同一时刻仅有一个任务正在执行。</li>
<li>主队列(Serial)：通常，在并发队列中的一项任务处理完成后，就需要更新UI。此时你需要嵌套 block 把UI更新任务提交到主队列。如果你现在已经处于主队列，并调用 dispatch_async 将任务添加到主队列，此时你唯一能确保的是，这个新添加的任务将在当前方法执行完毕后的某个时间才被执行。</li>
<li>并发队列：通常使用并发队列在后台处理非UI操作。</li>
</ul>
<p><strong>(2). dispatch_sync</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">     [super viewDidLoad];</span><br><span class="line">     dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">         NSLog(@&quot;First Log&quot;); // 1</span><br><span class="line">     &#125;);</span><br><span class="line">     NSLog(@&quot;Second Log&quot;); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018/07/06/细说iOS并发编程/dispatch_sync.gif" title="[]">
<p>上图中各个步骤的说明如下：</p>
<ol>
<li>主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内</li>
<li>viewDidLoad 在主线程执行</li>
<li>现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_sync</li>
<li>dispatch_sync 的 block 被添加到一个 global queue 并且稍后将会执行它。主线程会被阻塞，直到 block 执行完毕。与此同时，global queue 正在并发的处理任务；在这个 global q ueue 中，所有 block 任务将按照 “FIFO” 的顺序出队，但是会被并发执行。</li>
<li>global queue 处理先前已经加入队列的任务(在 dispatch_sync block 之前添加到该全局队列中的任务)</li>
<li>开始执行 dispatch_sync 的 block</li>
<li>block 执行完毕，dispatch_sync 函数返回，主线程恢复</li>
<li>viewDidLoad 方法执行完毕，主队列继续处理其他任务</li>
</ol>
<p>dispatch_sync 函数将一个任务添加到一个队列中，会阻塞当前线程，直到该任务执行完毕。dispatch_async 不会等待任务执行完，当前线程会继续往下走，不会阻塞当前线程。使用 dispatch_sync 时应注意避免死锁(deadlock)！</p>
<p><strong>Here’s a quick overview of when and where to use dispatch_sync:</strong></p>
<ul>
<li><strong>Custom Serial Queue</strong>: Be VERY careful in this situation; if you’re running in a queue and call dispatch_sync targeting the same queue, you will definitely create a deadlock.</li>
<li><strong>Main Queue (Serial)</strong>: Be VERY careful for the same reasons as above; this situation also has potential for a deadlock condition.</li>
<li><strong>Concurrent Queue</strong>: This is a good candidate to sync work through dispatch barriers or when waiting for a task to complete so you can perform further processing.</li>
</ul>
<p><strong>(3). dispatch_after</strong></p>
<p>使用 dispatch_after 延迟执行某个任务。比如在1秒后执行某个block。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double delayInSeconds = 1.0;</span><br><span class="line">   dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 </span><br><span class="line">   dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123; // 2 </span><br><span class="line">        // your task delay to execute       </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p>
<p>dispatch_after works just like a delayed dispatch_async!!</p>
<p>dispatch_after 在功能上就像延迟了的 dispatch_async，你没有办法掌控任务的实际执行时间，并且一旦 dispatch_after 函数返回，就没有办法取消任务。</p>
<p><strong>怎样使用 dispatch_after</strong>:</p>
<ul>
<li><strong>自定义串行队列</strong>：在自定义串行队列中谨慎使用 dispatch_after</li>
<li><strong>主队列(Serial)</strong>：主队列中使用 dispatch_after 是一个好的选择</li>
<li><strong>并发队列</strong>：谨慎使用，一般你很少在自定义并发队列中使用 dispatch_after</li>
</ul>
<p><strong>(4). Dispatch Group</strong></p>
<p>dispatch_group_create：创建 diapatch group<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br></pre></td></tr></table></figure></p>
<p>dispatch_group_async：提交 block 到 dispatch queue 中，并将 block 和 group 关联起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, queue, ^&#123; </span><br><span class="line">　　// block</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>dispatch_group_wait：阻塞当前线程，等待 group 关联的所有 block 执行完毕或者到达指定时间。如果到达指定时间后，所有任务并没有全部完成，那么 dispatch_group_wait 返回一个非 0 的数，可以根据这个返回值，判断是否等待超时。如果设置为 DISPATCH_TIME_FOREVER ，意思是永远等待，直到所有 block 执行完毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure></p>
<p>dispatch_group_notify：不阻塞当前线程，当 group 关联的所有 block 执行完毕后，回调通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">　　// 所有 block 执行完毕的回调</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, queue, ^&#123; </span><br><span class="line">　　// block</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">　　// block</span><br><span class="line">　　dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>when and how to use dispatch groups with the various queue types:</p>
<ul>
<li><strong>Custom Serial Queue</strong>: This is a good candidate for notifications when a group of tasks completes.</li>
<li><strong>Main Queue (Serial)</strong>: This is a good candidate as well in this scenario. You should be wary of using this on the main queue if you are waiting synchronously for the completion of all work since you don’t want to hold up the main thread. However, the asynchronous model is an attractive way to update the UI once several long-running tasks finish such as network calls.</li>
<li><strong>Concurrent Queue</strong>: This as well is a good candidate for dispatch groups and completion notifications.</li>
</ul>
<p><strong>(5). dispatch_apply</strong></p>
<p>提交 block 到 dispatch queue，并重复调用多次 (Submits a block to a dispatch queue for multiple invocations.)</p>
<p>dispatch_apply 就像 for 循环一样，并发执行每次的迭代任务。dispatch_apply 函数是同步的，直到所有任务执行完毕，才会返回。如果有大量迭代次数，并且每次迭代都仅处理少量工作，那么并不适合使用 dispatch_apply。</p>
<p>When is it appropriate to use dispatch_apply?</p>
<ul>
<li><strong>Custom Serial Queue</strong>: A serial queue would completely negate the use of dispatch_apply; you might as well just use a normal for loop.</li>
<li><strong>Main Queue (Serial)</strong>: Just as above, using this on a serial queue is a bad idea. Just use a normal for loop.</li>
<li><strong>Concurrent Queue</strong>: This is a good choice for concurrent looping, especially if you need to track the progress of your tasks.</li>
</ul>
<p><strong>(6). 信号量</strong></p>
<p>信号量是持有计数的信号，使用它控制对有限资源的使用和访问。假设有一间房子，它对应一个进程，房子里的两个人就对应两个线程。这个房子(进程)有很多资源，比如花园、客厅、卫生间等，是所有人(线程)共享的。但是有些地方，比卫生间，最多只能有1个人能进去。怎么办呢，在卫生间门口挂1把钥匙。进去的人(线程)拿着钥匙进去(信号量 -1)，外面的人(线程)没有钥匙就在门口等待，直到里面的人出来并把钥匙重新放回门口(信号量+1)，此时外面等待的人再拿着这个钥匙进去，所有人(线程)就按照这种方式依次访问卫生间这个有限的资源。门口的钥匙数量就称为信号量(Semaphore)。信号量为0时需要等待，信号量不为零时，减去1而且不等待。</p>
<p>The semantics for using a dispatch semaphore are as follows:</p>
<ol>
<li><p>When you create the semaphore using the dispatch_semaphore_create function, you can specify a positive integer indicating the number of resources available.</p>
</li>
<li><p>In each task, call dispatch_semaphore_wait to wait on the semaphore.</p>
</li>
<li><p>When the wait call returns, acquire the resource and do your work.</p>
</li>
<li><p>When you are done with the resource, release it and signal the semaphore by calling the dispatch_semaphore_signal function.</p>
</li>
</ol>
<p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line">    NSMutableArray *mutableArr = [NSMutableArray array];</span><br><span class="line">    for (NSInteger i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            /*</span><br><span class="line">             某个线程执行到这,如果信号量值为1，执行了wait方法后，信号量的值变成了0。并开始执行下面的代码。</span><br><span class="line">             */</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             这时候信号量的值为0，其它线程都处于等待状态。这样对 mutableArr 进行修改的线程，</span><br><span class="line">             在任意时刻都只有一个，能够保证多线程下读写 mutableArr 的安全性</span><br><span class="line">             */</span><br><span class="line">            [mutableArr addObject:@(i)];</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             执行结束，要调用signal方法，把信号量的值加1。</span><br><span class="line">             这样，其他等待的线程按照等待的先后顺序继续访问 mutableArr</span><br><span class="line">             */</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;%@&quot;,mutableArr.lastObject);</span><br></pre></td></tr></table></figure></p>
<p><strong>信号量与互斥锁</strong></p>
<p><strong>信号量</strong>：关注的是信号，信号！可以使用在线程间和进程间。只要信号是允许的，线程就可以访问某个资源。<br><strong>互斥锁</strong>：只能用于线程间。使用时会锁住某个资源，只允许当前一个线程访问，其他线程无法访问，处于等待状态。解锁后其他处于等待状态的线程被唤醒，然后按照等待排队顺序继续访问。</p>
<p><strong>(7). dispatch_barrier 栅栏函数</strong></p>
<p>dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用，它等待所有位于 barrier 函数之前的队列中的任务执行完毕后，再执行barrier block 中的任务，并且等待 barrier block中的任务执行完毕之后，barrier函数后续的任务才会得到执行，该函数需要同dispatch_queue_create 函数生成的并发队列(concurrent queue) 一起使用。</p>
<p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrier</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;barrier&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：1 2 barrier 4 3  其中1 2 与 3 4 由于异步执行先后顺序可能有变，</span><br><span class="line">但是 barrier 一定位于他们中间。</span><br></pre></td></tr></table></figure></p>
<p>看一段<a href="https://developer.apple.com/documentation/dispatch#//apple_ref/c/func/dispatch_barrier_async" target="_blank" rel="noopener">官方文档</a>能够更好的理解：</p>
<blockquote>
<p>调用 dispatch_barrier_async 函数总会在 block 任务提交后立即返回，而不等待 block 被调用。</p>
</blockquote>
<blockquote>
<p>When the barrier block reaches the front of a private concurrent queue, it is not executed immediately. Instead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes.</p>
</blockquote>
<blockquote>
<p>The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create<br>function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_async<br>function.</p>
</blockquote>
<h3 id="多线程并发带来的陷阱"><a href="#多线程并发带来的陷阱" class="headerlink" title="多线程并发带来的陷阱"></a>多线程并发带来的陷阱</h3><p>使用并发编程会带来许多陷阱。一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。</p>
<p>关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务戛然而止，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为优先级反转，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。</p>
<p>并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性，一个对象，通用的内存、网络设备或者一个文件等等。在多线程中，任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计，以防止这种冲突的发生。</p>
<p>为了演示这类问题，我们举一个关于资源的简单示例：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。问题来了，你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。</p>
<p>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。</p>
<img src="/2018/07/06/细说iOS并发编程/race_condition.png" title="[]">
<p>这个问题被叫做<a href="https://en.wikipedia.org/wiki/Race_condition#Software" target="_blank" rel="noopener">竞态条件</a>，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p>
<p>在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序。</p>
<p><strong>互斥锁</strong></p>
<p>互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的<a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29" target="_blank" rel="noopener">互斥锁</a>，只有当某个线程对资源完成了操作，释放掉这个互斥锁，这样别的线程才有机会访问该共享资源。</p>
<img src="/2018/07/06/细说iOS并发编程/Mutex.png" title="[]">
<p>除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障(Memory barrier)</a>。通过设置 Memory barrier，来确保没有无序执行的指令能跨过屏障而执行。</p>
<p>当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：<a href="https://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发技术</a>。</p>
<p>从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。</p>
<p>在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。</p>
<p>锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(<a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29#Granularity" target="_blank" rel="noopener">锁的竞争</a>是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。</p>
<p>在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出<a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="noopener">临界区段</a>（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。</p>
<p>我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 CPU strategy view 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。</p>
<p><strong>死锁</strong></p>
<p>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些<a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29#The_problems_with_locks" target="_blank" rel="noopener">其他问题</a>，其中一个就是<a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">死锁</a>。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。</p>
<img src="/2018/07/06/细说iOS并发编程/dead_lock.png" title="[]">
<p>看看下面的代码，它交换两个变量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void swap(A, B)</span><br><span class="line">&#123;</span><br><span class="line">    lock(lockA);</span><br><span class="line">    lock(lockB);</span><br><span class="line">    int a = A;</span><br><span class="line">    int b = B;</span><br><span class="line">    A = b;</span><br><span class="line">    B = a;</span><br><span class="line">    unlock(lockB);</span><br><span class="line">    unlock(lockA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap(X, Y); // 线程 1</span><br><span class="line">swap(Y, X); // 线程 2</span><br></pre></td></tr></table></figure></p>
<p>此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。</p>
<p>再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。</p>
<p><strong>资源饥饿（Starvation)</strong></p>
<p>当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起读写问题。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。</p>
<p>为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 writer preference，或者使用 read-copy-update 算法。Daniel 在底层并发编程 API 中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。</p>
<p><strong>优先级反转</strong></p>
<p>本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的优先级反转。</p>
<p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。</p>
<p>高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。</p>
<img src="/2018/07/06/细说iOS并发编程/优先级反转.png" title="[]">
<p>在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。</p>
<p>解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。</p>
<p>从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。</p>
<p>但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。</p>
<p>我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/并发编程/" rel="tag"># 并发编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/06/iOS开发琐碎知识点/" rel="prev" title="iOS开发琐碎知识点">
                iOS开发琐碎知识点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Yang Jie" />
            
              <p class="site-author-name" itemprop="name">Yang Jie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yangjie2" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/users/8227142/y-jie" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发编程相关的几个概念"><span class="nav-number">1.</span> <span class="nav-text">并发编程相关的几个概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS-和-OS-X-中的并发编程"><span class="nav-number">2.</span> <span class="nav-text">iOS 和 OS X 中的并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Grand-Central-Dispatch"><span class="nav-number">2.1.</span> <span class="nav-text">Grand Central Dispatch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程并发带来的陷阱"><span class="nav-number">3.</span> <span class="nav-text">多线程并发带来的陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang Jie</span>

  

  
</div>








  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://yangjie2.github.io/2018/07/06/细说iOS并发编程/';
        this.page.identifier = '2018/07/06/细说iOS并发编程/';
        this.page.title = '细说iOS并发编程';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
