<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[C++]虚函数,纯虚函数]]></title>
    <url>%2F2018%2F08%2F04%2FC-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参考来源：知乎 虚函数定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。举个栗子： 假设我们有下面的类层次： 12345678910111213141516171819202122class Animal&#123; public: virtual void eat() &#123; cout&lt;&lt;&quot;i eat like animals.&quot;&lt;&lt;endl; &#125; &#125;; class Dog:public Animal &#123; public: void eat() &#123; cout&lt;&lt;&quot;i eat like a dog.&quot;&lt;&lt;endl; &#125; &#125;; int main(void) &#123; Animal *a = new Dog(); a-&gt;eat(); // 在这里，a虽然是指向Animal的指针，但是被调函数`eat()`却是`Dog`的! 。 return 0; &#125; 这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。 它虚就虚在所谓“推迟联编”或者“动态联编”上，函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。虚函数只能借助于指针或者引用来达到多态的效果。 纯虚函数定义: 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。将函数定义为纯虚函数的方式如下（后面多了个 ＝0 ）： 1virtual ReturnType Function() = 0; 引入原因 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 为了解决上述问题，引入了纯虚函数的概念，只要在基类中定义了纯虚函数，则编译器要求在其派生类中必须予以重写以实现多态性。含有纯虚函数的类称为抽象类，抽象类它不能生成对象。 这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。纯虚函数最显著的特征是：它们必须在子类中重新声明（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中没有定义。 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。 抽象类抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的定义： 称带有纯虚函数的类为抽象类。抽象类的作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。 使用抽象类时注意：• 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。• 抽象类是不能定义对象的。 总结：1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。 2、虚函数声明如下：virtual ReturnType FunctionName(Parameter)； 虚函数必须实现，如果不实现，编译器将报错，错误提示为：error LNK****: unresolved external symbol &quot;public: virtual void __thiscall ClassName::virtualFunctionName(void)&quot; 3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。 4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。 5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。 6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。 7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。 8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。定义纯虚函数就是为了让基类不可实例化化因为实例化这样的抽象数据结构本身并没有意义。或者给出实现也没有意义。实际上我个人认为纯虚函数的引入，是出于两个目的1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。2、为了效率，不是程序执行的效率，而是为了编码的效率。 最后引用别人的一段生动形象的解释： 上帝是一个程序员，创造了动物(基类)，给予了动物吃饭，睡觉，叫唤等通用功能。(封装)只指定了平均睡觉八小时(虚函数)，其中没有指定具体的吃饭，叫唤的行为。(纯虚函数)然后细分一下，动物有猫狗羊和人。(继承)人类明确它们物种的时候(明确类型的派生类指针)猫吃鱼 狗吃肉 羊吃草猫喵喵 狗汪汪 羊咩咩(多态 同名覆盖)一切都如此顺理成章。突然人发现一只动物！这只是什么呢？诶？这货不知道是啥！只能用”动物”来称呼他！(基类指针指向子类对象)当没有虚函数的时候，人类发现这只动物不会叫也不会吃！因为他根本没有这样的实现！(注意 真正编程上如果派生类不对纯虚函数进行实现将无法通过编译)有了虚函数，让那只动物”吃”，发现他吃草！于是捅一下这只动物，发现它会 哞哞叫！于是得知这是一头牛！可以吃！于是人类就把它吃掉了。总结:虚函数目的是在用基类指针指向派生类的时候还能正确调用派生的实现。]]></content>
      <categories>
        <category>C++ dev</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从MVVM到ReactiveCocoa]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%BB%8EMVVM%E5%88%B0ReactiveCocoa%2F</url>
    <content type="text"><![CDATA[翻译自 Bob Spryn 的 ReactiveCocoa and MVVM, an Introduction这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。 MVC任何有经验的软件开发者都会熟悉 MVC 这个概念。它表示 Model View Controller ，是在复杂应用设计中一种久经考验的代码组织方式。在IOS开发中，MVC也被证实具有第二种含义：Massive View Controller (笨重的视图控制器) ，这让许多开发者困惑于如何优雅地对代码进行组织和解耦。IOS开发者需要给 view controller 瘦身，这是他们的共识。然而，怎么做呢？ MVVM为了解决上面的问题，MVVM 应运而生。它表示 Model View View-Model ，它帮助我们创建更易管理、具有良好设计的代码。某些情况下违背Apple建议的编码方式没有多大意义，我不是说不赞成这么做，而是觉得这么做弊大于利。比如我不建议你去实现一个 View Controller 基类并试图自己处理VIew的生命周期。带着这种思想，我不禁提出这样一个问题：使用Apple推荐的MVC之外的设计模式是不明智的吗？不！原因有两点：Apple 没有真正给出解决 Massive View Controller 问题的任何指导，他们将更多空间留给我们。MVVM 就是一种很酷的解决方式。 MVVM 能够与 MVC 很好的兼容，并将 MVC 延展到另一个层次。 关于 MVC/MVVM 的历史这里不做介绍了，我会更关注它在 iOS 开发中的应用。 Defining MVVMModel - 在 MVVM 中，model 的作用并没有什么特别变化，我们仅把它当做存放数据-模型对象信息的结构体，而在单独的管理类中保留创建/管理model的统一逻辑。 View - view中包含真正的UI本身(不管是 UIView 代码，还是 storyboard 和 Xib )、任何与视图有关的特定逻辑以及对用户输入的响应。这包括了许多由 UIViewController 负责处理的工作，不仅仅是UIView代码和文件。 View-Model - 这个术语本身就会给我们带来困惑，它由两个我们熟悉的术语组合而成，但完全是不同的东西。它不是传统意义上 data-model 结构中 model 的作用。它的职责之一是作为一个静态模型，为视图展示自身提供必要的数据，但它也有收集、解释、转换这些数据的责任。这留给 View(Controller) 一个更加清晰明确的任务：将 View-Model 提供的数据呈现出来。 More about the view-modelview-model 这个术语不足以描述我们的意图，一个更合适的名字可能是 “View Coordinator (视图协调器)”。它从资源(database，web service calls，etc)中收集原始数据，应用某种逻辑去处理修改造这些数据，加工成供 view(controller) 界面展示所需的数据。view-model (通常通过属性)仅仅暴露出来 view(controller) 显示所需的信息 (理想情况下不要暴露你的 data-model 对象)。它还负责处理上游数据的修改，比如更新模型/数据库, API POST 调用。 MVVM in a MVC world在iOS开发中，我觉得 MVVM 这个首字母缩写像 view-model 一样词不达意，让我们再看下它是怎么适应MVC模式的。 Here is a simple mapping of how these two patterns fit together in iOS: 说明： 使用图形块的大小粗略的表示它负责的工作量的多少 注意看 view controller 部分有多大？ 巨大的 view controller 和 view-model 之间有大块工作上的重合 view controller 和 MVVM 中的 view 也有一大部分的工作是重合的 我们并不是要去除 view controller 这个概念，或者丢掉 “controller” 去匹配 MVVM，我们仅仅是将这部分重合的任务划分到 view-model 中，让 view controller 变得更加简单清晰。 最终得到的结果用图表示如下： 现在，view controller 仅涉及配置和管理各种视图，这些视图的数据都来自 view-model，view controller 也负责在用户有输入动作发生时通知 view-model ，让 view-model 去修改上游数据。view controller 不需要知道有关web service calls, Core Data, model objects 等的一些东西。 view-model 也是一个对象，它会以一个属性的方式存在于 view controller 中，视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知。你或许已经感觉到这种设计好多了，因为在这里我们对相关工作做了很好的分离。 下图展示了这种 MVVM 模式下新的应用设计结构： 这张图或许能更好的帮助你理解。 View-Model and View Controller, together but separate举个栗子：为了情节简单, 让我们构建一个简化的twitter客户端，任何使用推特的用户，只要输入用户名，就可以查阅最近的回复。 我们的例子交互和界面如下: 有一个 UITextField，让用户可以输入名字，一个 “Go” UIbutton 有一个 UIImageView和一个 UILabel ，用于显示当前被查看的用户的头像和姓名 下面有一个 UITableView，显示最近的推文回复。 允许无限滚动 The Example View-Modelview-model 的头文件如下所示：123456789101112@interface MYTwitterLookupViewModel: NSObject@property (nonatomic, assign, readonly, getter=isUsernameValid) BOOL usernameValid;@property (nonatomic, strong, readonly) NSString *userFullName;@property (nonatomic, strong, readonly) UIImage *userAvatarImage;@property (nonatomic, strong, readonly) NSArray *tweets;@property (nonatomic, assign, readonly) BOOL allTweetsLoaded;@property (nonatomic, strong, readwrite) NSString *username;- (void) getTweetsForCurrentUsername;- (void) loadMoreTweets; 头文件很简单。注意到所有这些壮观的 readonly属性了吗？view-model 仅暴露我们的 view controller 需要的最少的信息，而且 view conreoller 不关心 view-model 是怎么得到这些信息的。 view-model 不做的事情 通过任何形式直接作用于 view controller，或者直接通知控制器关于自己的一些变化。 The Example View Controller视图控制器使用从 view-model 获取的数据去做: 当usernameValid值变化时，触发“Go”按钮的enabled属性 当 usernameValid 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为1.0) 使用 userFullName更新 UILabel 的文本内容 使用 userAvatarImage更新 UIImageView 的 image 使用数组 tweets配置 table view 的 cells 当滑动到 table view 的底部时，如果 allTweetsLoaded为 NO，提供一个显示“loading”的 cell View Controller将通过如下方式作用于 view-model ： 每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username 当 “Go” 按钮被按下时，调用 view-model 上的 getTweetsForCurrentUsername 方法 当到达表格中的 “loading” cell 时，调用 view-model 上的 loadMoreTweets 方法 view controller 不做的事情 发起网络服务调用 管理 tweets 数组 判定 username 内容是否有效 将用户的姓和名格式化为全名 下载用户头像并转成 UIImage 挥洒汗水 再次注意，视图控制器的总责任是如何处理 view-model 中的变化 #####Child View-Models上面提到，我们使用 view-model 的 tweets 数组配置表格中的cell。通常你期望用来展示 tweets 的是这些 data-model 对象。但是上面提到，MVVM 模式下，不会暴露 data-model 对象，这时候你正感受到深深的恶意。。。 不需要仅使用一个 view-model 代表屏幕上展示的所有东西！ 你可以使用 child view-model 表示更小的、潜在的更具封装性的部分：如果某一小块视图(比如 cell)在你的app中可以复用，或者它表示多个 data-model 对象，这么做将会十分有益。 你并不总是需要 child view-models。比如，我可以使用一个 table header view 来渲染我们的app “tweetboat plus”顶部部分，它不是一个可复用组件，所以我仅需要传入 view controller 使用的那个相同的 view-model 给这个自定义 header view 就可以了。它从那个 veiw-model 中获取自己需要的信息而忽略其他的。这是一个让你的子视图保持同步的特别棒的方法，因为它们都可以有效地使用相同的信息上下文，并观察与更新相同的属性。 在我们示例app中，tweets数组内放置的是 子view-model，大概长这样：1234567@interface MYTweetCellViewModel: NSObject @property (nonatomic, strong, readonly) NSString *tweetAuthorFullName;@property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage;@property (nonatomic, strong, readonly) NSString *tweetContent;@end 你可能会觉得，这个子view-model也太像通常意义的 data-mode 对象了吧？为什么要把它转换成 view-model ？ 尽管很相似，但是 view-model 让我们能够限制信息，仅暴露出我们需要的部分；提供可能转换数据的其他属性；或者为特定视图计算数据 (再说下，一种很好的设计方式是尽可能不要暴露可变的 data-model 对象，因为我们希望 view-model 自己负责修改更新他们，而不是 view 或者 view controler)。 View-Model 从哪来?那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么? View-Model 产生 View-Model严格来讲，你应该在 app delegate 中为顶级视图控制器创建一个 view-model。当展示一个新的 view controller 或者一个很小的视图(这个小的视图使用 view-model 表示)时，要让当前的这个 view-model 为你创建需要的 child view-model 。 假如我们想要在用户点击应用顶部的头像时，添加一个资料视图控制器，我们可以为当前主 view-model 添加一个方法： 1- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser; 在我们的主控制器中，可以像这样使用它：12345678- (IBAction) didTapPrimaryUserAvatar&#123; MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser]; MYTwitterUserProfileViewController *profileViewController = [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; [self.navigationController pushViewController: profileViewController animated:YES];&#125; 在这个例子中，我想弹出一个用户资料视图控制器，但是这个控制器需要一个 view-model。我的主控制器并不知道关于这个用户的数据信息，无法创建这个view-model(也不应该要它创建)，所以，我的主控制器让它的 view-model 去做这项苦差事。 view-model 列表回到推特例子中 table view 的 cell，当数据通过网络请求被拿到后，我会特意提前将对应cell的所有view-model创建好。所以在我们这里，主view-model的tweets数组内是MYTweetCellViewModel对象。在 table view 的 cellForRowAtIndexPath方法中，我会简单地在正确的索引位置从tweets数组中抓取子view-model，将它赋值给 cell 的 view-model 属性。 Functional Core, Imperative Shell (函数式内核，命令式外壳)Functional Core(函数式内核)view-model 就是我们的函数式内核 “functional core””，尽管实际上在 iOS/Objective-C 中达到纯函数级别是很棘手的(Swift 提供了一些附加的函数性, 这会让我们更接近)。一般的想法是让 view-model 尽可能少地依赖和影响应用程序的其它部分。这是什么意思？回想一下你刚开始学编程时遇到的简单的函数，它们接受一两个输入参数，并输出一个结果值。Data in, data out。也许这个函数做了一些数学计算或者字符串拼接。不管应用程序中发生了什么，相同的输入，就会得到相同的输出。这就是 函数式 。 我们使用 view-model ，就是想得到函数式结果。view-model 内部包含逻辑与功能，将数据转换并存储在它的属性中。理想情况下，相同的输入将导致相同的输出结果。这意味着可以尽可能多的消除应用程序的其它部分对输出结果的影响，比如使用大量的状态值。我们要做的第一步就是在你的view-model的头文件中不要包含UIKit.h（这是一个很好的原则，但也有一些灰色区域：比如，你可能会将UIImage看作数据，而不是视图（我喜欢这样）。在这种情况下，你需要UIKit.h来获得UIImage类）。UIKit 的性质就决定了它会严重影响应用程序的许多地方，它含有很多副作用，更改一个值或调用一个方法将触发许多间接(甚至不可知)的更改。 update： 需要理解你的 view-model 仍然是一个 object，并且的确需要维持一些状态(否则它对你的视图来说就不是一个非常有用的模型了)。但你仍然应该努力将尽可能多的逻辑转移到无状态函数的“值”中(swift 在这方面比 Objective-C 更可行)。 Imperative (Declarative?) Shell（命令式（声明式？）外壳）我们将 view-model 数据转换成屏幕所显示的东西，需要做一系列工作，比如所有的状态改变，应用内其它部分的改变，命令式外壳就是我们做这些脏活儿累活儿的地方。这就是我们的 view (controller)，我们处理 UIKit 的地方。我依然特别注意尽可能的减少状态变量，将这一系列工作用声明式的方式完成，例如使用ReactiveCocoa。但本质上，iOS和UIKit是命令式的。 Testable CoreiOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注: mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法) 这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是变得非常能够进行单元测试. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 现在我们将数据的获取/逻辑/转换从 view controller 中提取出来, 避免了视图控制器的复杂性. 那意味着测试时不需要用疯狂的 mock 对象, method swizzling, 或其他疯癫的变通方法(希望能有)了。 Connecting Everything那么，当 view-model 上的公开属性值变化时，我们怎么更新视图呢？ 大多时候，我们使用相应的 view-model 去初始化 view controller，类似在上文见到的，比如：12MYTwitterUserProfileViewController *profileViewController =[[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; 有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在该 view (controller) 中暴露一个公有可写的 view-model 属性.1234MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath];// grab the cell view-model from the vc view-model and assign itcell.viewModel = self.viewModel.tweets[indexPath.row]; 有时候可以在钩子程序执行前传入 view-model，比如 init或者 viewDidLoad，这样，我们可以使用 view-model 提供的属性值初始化所有UI部件的状态：123456789101112- (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel &#123; self = [super init]; if (!self) return nil; _viewModel = viewModel; return self;&#125;- (void) viewDidLoad &#123; [super viewDidLoad]; _goButton.enabled = viewModel.isUsernameValid; _goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5; // etc&#125; 很棒！我们已经配置好了初始值。当 view-model 中的数据变化时，怎么更新UI部件的状态？怎么将按钮变为不可用？我们的用户名label和头像将如何被网络请求的结果所填充? 将 viewcontroller 设置为 view-model 的代理？数据变化时，view-model 发送通知？ 不不不。。 我们的视图控制器能够知道一些变化的发生。可以使用 UITextfield 的代理方法，通过每次有输入字符变动时检查 view-model ，来更新button的状态。1234567- (void)textFieldDidChange:(UITextField *)sender &#123; // update the view-model self.viewModel.username = sender.text; // check if things are now valid self.goButton.enabled = self.viewModel.isUsernameValid; self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5;&#125; 这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 isUsernameValid 值. 假使还有其他变量/动作改变 isUsernameValid 的状态将会怎么样? 对于 view-model 中的网络请求又如何呢?或许我们该为 view-model 中的方法加一个完成后回调处理, 这样我们在那个节点就可以更新 有关UI 的一切东西了?使用古老而笨重的KVO方法？ 最终，我们可以使用我们所熟悉的各种机制来连接 view-model 和 view (controller) 中的所有接触点，但是你知道标题上可不是这么写的。这种方式在代码中创建了大量的入口点，就算是简单的UI更新，也必须完全重新创建应用程序状态的上下文。 Enter ReactiveCocoaReactiveCocoa (RAC) 是来拯救我们的。让我们看看它是怎么做的。 考虑通过一个新的用户界面来控制信息的流动：该界面在表单有效时更新提交按钮的状态。以下是你目前的工作方式: 最终，通过使用状态，谨小慎微地将自己简单的逻辑穿插在众多不同且无关的代码上下文中。看一下信息流中所有不同的入口点，是不是感觉乱糟糟的？(这还仅仅是一个UI元素的逻辑线) 。 我们在编程中使用的这些抽象还不够聪明，不能追踪所有这些事情的联系，所以最终还得自己做这些事儿。 让我们看下“陈述式”的版本： 这张图谱记录了我们应用程序的流程。通过这种陈述式编程，我们使用了一种更高级别的抽象，它让我们在实际的编程中，能够更接近我们自己脑海中的思维流。我们让电脑做更多的工作。现在实际的代码与这张图谱显得很接近了。 RACSignalReactiveCocoa核心就是 RACSignal。RACSignal (信号)对于 RAC 来说是构造单元。它是一个我们最终将会接收到的承载着信息的对象。当你有了一个在某个时间点将会收到的信息的具体表示形式时，那就开干吧！运用必要逻辑并预先构建你的信息流(声明式)，而不是必须等到事件发生时才这么做(响应式)。 信号会捕获所有的异步方法(委托, 回调 block, 通知, KVO, target/action事件观察者，etc)来控制通过应用程序的信息流，并将他们统一在一个接口下。不仅如此，它还能够让你轻松的转换/分解/合并/过滤 流经你app的信息。 那么什么是信号呢，这就是一个信号： 信号是一个发送一连串值的物体。但我们这里的信号什么都没做，因为它还没有任何订阅者。一个RAC信号仅当有订阅者去监听它时，它才会发出信息。它将向订阅者发送0或者载有数值的“next”事件，后面紧跟着一个 “complete” 事件或者一个 “error” 事件。信号不仅限于一次只向它的订阅者发送一个返回值。 就像我前面提到的，如果需要的话你可以过滤, 转换, 分解，合并那些值。不同的订阅者可能需要由信号发出的这些数值的不同形式。 信号从哪里得到它们发送的值？Signals 是一些等待事件发生的异步代码，当事件发生时就向它们的订阅者发送结果值。你可以使用 RACSignal 类中的类方法 createSignal: 手动创建这些信号：12345678RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;]; [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123; [subscriber sendNext:result]; [subscriber sendCompleted]; &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123; [subscriber sendError:error]; &#125;]; 上面我创建了一个信号，我使用 RACSignal 提供的 subscriber 对象调用 sendNext: 和 sendCompleted: 方法(请求成功时)，或者调用 sendError:(请求失败时)。现在我可以订阅这个信号并在网络请求返回时接收到 json 值或是 error。 RAC 为我们提供了丰富的机制来从我们常用的现有异步模式中提取信号。如果你有一个异步任务没有覆盖在内置的信号中，你可以很容易地用 createSignal: 或类似方法来创建信号。 RAC提供的一个机制就是使用宏 RACObserve()，这个宏是对 KVO 中那些糟透的 API 的替代。你只需要传入一个对象以及在这个对象中你想要监听的属性的名称。给出这些参数后，RACObserve ()会生成一个信号，并立即向它的监听者发送这个属性的当前值，以及未来关于这个属性的任何变化。 1RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid); 上面仅是创建信号的一种方式，下面有几种现成的从控制流机制中获得信号的方式：123456789101112131415161718RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside]; // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc) // subscribeNext:^(UIButton *button) &#123; NSLog(@&quot;%@&quot;, button); // UIButton instance &#125;RACSignal *textChange = [myTextField rac_textSignal]; // some special methods are provided for commonly needed control event values off certain controls // subscribeNext:^(UITextField *textfield) &#123; NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; &#125;RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal]; // signals for some delegate methods send the delegate params as the value // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc // (limited to methods that return void) // subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; &#125;RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)]; // signals for arbitrary selectors that return void, send the method params as the value // works for built in or your own methods // subscribeNext:^(NSNumber *animated) &#123; NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear 1&quot; &#125; 你也能轻松创建自己的信号, 包括替代那些没有内置支持的其他委托。我们现在可以将所有这些断了联系的异步/控制流工具中获得信号，将也可以将它们组合在一起，想想这是多么酷的事情！这些信号会成为上面看到的陈述式图谱中的nodes节点，开心吧。 什么是订阅者？简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了(它也可以作用于 “complete” 和 “error” 事件)。再次注意，订阅者就是一段代码，而不是一个具体的对象。 下面是一个简单的 subscriber，通过向信号的实例方法 subscribeNext : 传入一个 block 创建的。这里我们正在通过 RACObserve() 宏创建的这个信号，观察一个对象的某个属性的当前值, 并把这个属性值赋给一个内部属性。123456789- (void) viewDidLoad &#123; // ... // create and get a reference to the signal RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid); // update the local property when this value changes [usernameValidSignal subscribeNext:^(NSNumber *isValidNumber) &#123; self.usernameIsValid = isValidNumber.boolValue &#125;];&#125; 注意 ：RAC 只处理对象, 而不处理像 BOOL 这样的原始值。 不过不用担心, RAC 通常会帮你处理这些转换。 RAC 作者也意识到这种绑定行为的普遍必要性。所以他们提供了另一个宏定义：RAC()。与 RACObserve() 类似，你提供一个对象和这个对象的属性名参数，传入的值就会绑定到这个对象的这个参数上。这个宏定义在内部就是做了上面 viewDidLoad 方法中的工作：创建订阅者，更新属性值。1234- (void) viewDidLoad &#123; //... RAC(self, usernameIsValid) = RACObserve(self.viewModel, isUsernameValid);&#125; 但考虑到我们的目的，这样做有点傻冒。我们并不真的需要将信号中的值存储到一个属性中(也会因此创建状态)，我们真正想做的是用从这个值中收集的信息来更新UI。 转换数据流现在我们开始看 RAC 为我们提供的转换数据流的值的方法。我们会用到 RACSignal 类提供的 map 实例方法。123456789- (void) viewDidLoad &#123; //... RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid); RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid) &#123; return usernameIsValid.boolValue ? @1.0 : @0.5; &#125;];&#125; 现在，我们将 view-model 上的 isUsernameValid 属性所发生的更改直接绑定到 goButton 上的 enabled属性上。绑定 goButton 按钮的 alpha 属性显得更让人兴奋，因为我们使用 map 方法将信号的值转换成 alpha 属性的值。 多个订阅者, 副作用, 昂贵的操作在订阅信号链时，你应当认识到这样一件非常重要的事，每当一个新值通过该信号链发送时，它实际上是每一个订阅者都会发送一次。 比如新增了一个订阅者去监听一个信号，那么信号会立即向订阅者发送信息，注意是所有订阅者！而不仅仅是你刚才新增的那个。信号发送出的信息(值)不会存储在任何地方(除了RAC的内部实现部分)，认识到这一点对我们来说是有意义的。当信号需要发送一个新的值时，它会遍历所有的订阅者，并给每个订阅者发送那个值。 这就意味着在你信号链的某处产生的任何副作用，任何影响应用程序世界的转换，都会多次发生。对于刚开始使用RAC的用户来说，这是意料之外的(这也违背了“函数式”思想—相同的输入，产生相同的输出)。 举个蹩脚的例子：有一个按钮点击事件信号，它会在信号链的某个地方更新一个计数属性，如果有多个订阅者监听了这个信号链，这个计数属性的增长比你想象的还要多。你需要从信号链中尽可能的剔除副作用，当副作用不可避免时, 你可以使用一些恰当的预防机制，我将会在另一篇文章中讨论。 除了副作用以外，你需要特别注意带有代价昂贵的操作和可变数据的信号链。网络请求是一个兼有以下三点的例子： 网络请求影响你的 app 的网络层(副作用). 网络请求给信号链带来了可变数据. (两个完全一样请求可能返回了不同的数据) 网络请求反应慢 例如，你有一个信号，每次点击按钮，信号就会发送一个值，你想转换这个值，并用转换结果进行网络请求从而得到请求结果。如果有多个订阅者要处理这个信号链返回的值，你将会发起多次网络请求。 显然网络请求是经常需要的，如你所想，RAC 为这种情况提供了解决方案：RACCommand 和多点广播。我将在下一篇文章中深入讨论。 Tweetboat Plus简短的介绍之后，现在我们着手怎么将 view-model 和 view controller 使用 ReactiveCocoa 联系起来。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// View Controller//- (void) viewDidLoad &#123; [super viewDidLoad]; RAC(self.viewModel, username) = [myTextfield rac_textSignal]; RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid); RAC(self.goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) &#123; return valid.boolValue ? @1 : @0.5; &#125;]; RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName); @weakify(self); [[[RACSignal merge:@[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id value) &#123; @strongify(self); [self.tableView reloadData]; &#125;]; [[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext: ^(id value) &#123; @strongify(self); [self.viewModel getTweetsForCurrentUsername]; &#125;];&#125;-(UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // if table section is the tweets section if (indexPath.section == 0) &#123; MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath]; // grab the cell view model from the vc view model and assign it cell.viewModel = self.viewModel.tweets[indexPath.row]; return cell; &#125; else &#123; // else if the section is our loading cell MYLoadingCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath]; [self.viewModel loadMoreTweets]; return cell; &#125;&#125;//// MYTwitterUserCell//// this could also be in cell init- (void) awakeFromNib &#123; [super awakeFromNib]; RAC(self.avatarImageView, image) = RACObserve(self, viewModel.tweetAuthorAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName); RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);&#125; 让我们来分析下上面的这个例子： 1RAC(self.viewModel, username) = [myTextfield rac_textSignal]; 这里使用RAC提供的方法，从 UITextField 中得到一个信号。上面这行代码将 view-model 的可读写属性 username 绑定到 textfield 的任何更新。 12345678RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid);RAC(self.goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) &#123; return valid.boolValue ? @1 : @0.5; &#125;];RAC(self.goButton, enabled) = usernameIsValidSignal; 这里我们使用宏 RACObserve() 在 view-model 的 usernameValid 属性上创建一个信号 usernameIsValidSignal，不管什么时候只要这个属性值有变化，这个信号就会沿着管道(pipe)发送一个新的 @YES 或 @NO 值。我们将这个值绑定到 goButton 的两个属性上。 接着，通过使用宏 RACObserve 在对应的 view-model 属性上创建信号，为 table view 表头的 image view 和 user label 创建绑定：123RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage);RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName); 下面这段代码看起来有点棘手，所以让我们多花点时间在这里。12345678@weakify(self);[[[RACSignal merge:@[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id value) &#123; @strongify(self); [self.tableView reloadData]; &#125;]; 我们希望在 view-model 里的 tweets 数组和 allTweetsLoaded 属性发生变化时就能立刻更新 table view。所以我们将观察这两个属性的信号两个信号合并成一个“大信号”，这样，当这两个属性有任何一个变化时，这个合并后的大信号就会发送一个值 (通常你希望信号的值是同类型的，而不是像这个信号那样混合着其他类型值。这可能会在 RAC swift 强制执行，但这里我们不关心发送的实际值，我们只是用它来触发 table view 的重新加载)。 所以这里有点吓人的部分可能是 bufferWithTime:onScheduler: 方法，这么做是为了解决 UIKit 中的一个问题。我们需要同时追踪 tweets 和 allTweetsLoaded 这两个属性，目的是为了防止其中一个发生变化而另一个没有变(有一个属性变化，就需要更新 table view)。问题是，有时这两个属性碰巧会在同一时间点发生变化，这意味着，合并产生的大信号中的两个小信号都将发送一个值，那么reloadData 将在同一个 run loop 中被连续调用两次。UIKit 不喜欢这样。bufferWithTime: 捕获任何在给定时间内发送过来的下一个值，当这段时间过去以后，再将这些值一并发送给订阅者。通过传入参数 0 ，bufferWithTime:方法将捕获在一个 run-loop 时间内由“大信号”发出的所有值，然后再将这些值一起发出去。别担心，就把它当做需要将这些值必须在主线程上传递。现在我们能够确保 reloadData 方法在每个run-loop 内只执行一次。注意：我们用到了 @weakify/@strongify 宏，这对打破循block引起的环引用非常重要。 下面这段代码展示出 RACCommand 将会发挥作用的地方，将在下一篇文章中介绍。就目前来说，当按钮被点击时，我们只是手动调用 view-model 的 getTweetsForCurrentUsername 方法：12345[[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext: ^(id value) &#123; @strongify(self); [self.viewModel getTweetsForCurrentUsername]; &#125;]; 我们已经介绍了cellForRowAtIndexPath 的第一部分，所以这里只说下 loading cell：1234MYLoadingCell *cell =[self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath];[self.tableView loadMoreTweets];return cell; 这是将来我们使用 RACCommand 的另一个领域。现在我们只是调用 view-model 中的 loadMoreTweets方法。我们相信，如果 cell 隐藏并显示了多次，view-model 可以在内部避免多次调用。 1234567- (void) awakeFromNib &#123; [super awakeFromNib]; RAC(self.avatarImageView, image) = RACObserve(self, viewModel.userAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName); RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);&#125; This should be fairly straightforward now, aside from one thing I want to point out. We are binding an image and strings to the appropriate properties on our UI, but note that viewModel is on the right side of the comma in the RACObserve macro. These cells will end up getting reused and new view-models will be assigned. Instead of listening for the viewModel property to change and then re-setting up our bindings everytime, if we put viewModel on the right side of the comma, RACObserve is going to take care of that for us. So we only set up this binding ONCE and let Reactive Cocoa do the rest. This is a good thing to keep in mind for performance with bindings on table cells. In practice I’ve had no issues even with lots of table cells screaming around. 额外的好处——消除更多的状态有时候你在 view-model 中暴露出 RACSignal 而不是一些属性值会帮你消除 view-model 上更多的状态。这样，你的 view (controller) 就可以直接使用这些信号，而不必使用 RACObserve创建它自己的信号了。注意：如果在 UI 订阅/绑定这个信号之前，它就已经发送了一个值，那么你就会错过这个“初始”的值。 结论这是一种不同的编程风格，它为你提供了另一种与“命令式”完全不同的思路。即使你一开始并不会经常使用这种方式，但它仍然告诉你，有这样一位姑娘(RAC) 可以用她特有的方式为你解决困惑。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM消息的可靠投递]]></title>
    <url>%2F2018%2F07%2F06%2FIM%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92%2F</url>
    <content type="text"><![CDATA[报文类型im的客户端与服务器通过发送报文（也就是网络包）来完成消息的传递，报文分为三种：请求报文（request，后简称为为R）应答报文（acknowledge，后简称为A）通知报文（notify，后简称为N），这三种报文的解释如下： R：客户端主动发送给服务器的报文A：服务器被动应答客户端的报文，一个A对应一个RN：服务器主动发送给客户端的报文 普通消息投递流程用户A给用户B发送一个“你好”，流程如下： 1）client-A向im-server发送一个消息请求包，即msg:R2）im-server在成功处理后，回复client-A一个消息响应包，即msg:A3）如果此时client-B在线，则im-server主动向client-B发送一个消息通知包，即msg:N（当然，如果client-B不在线，则消息会存储离线） 上述消息投递流程出现的问题从流程图中容易看到，发送方client-A收到msg:A后，只能说明im-server成功接收到了消息，并不能说明client-B接收到了消息。在若干场景下，可能出现msg:N包丢失，且发送方client-A完全不知道，例如：1）服务器崩溃，msg:N包未发出2）网络抖动，msg:N包被网络设备丢弃3）client-B崩溃，msg:N包未接收结论是悲观的：接收方client-B是否有收到msg:N，发送方client-A完全不可控，那怎么办呢？ 应用层确认+im消息可靠投递的六个报文upd是一种不可靠的传输层协议，tcp是一种可靠的传输层协议，tcp是如何做到可靠的？答案是：超时、重传、确认要想实现应用层的消息可靠投递，必须加入应用层的确认机制，即：要想让发送方client-A确保接收方client-B收到了消息，必须让接收方client-B给一个消息的确认，这个应用层的确认的流程，与消息的发送流程类似： 4）client-B向im-server发送一个ack请求包，即ack:R5）im-server在成功处理后，回复client-B一个ack响应包，即ack:A6）则im-server主动向client-A发送一个ack通知包，即ack:N至此，发送“你好”的client-A，在收到了ack:N报文后，才能确认client-B真正接收到了“你好”。 会发现，一条消息的发送，分别包含（上）（下）两个半场，即msg的R/A/N三个报文，ack的R/A/N三个报文，一个应用层即时通讯消息的可靠投递，共涉及6个报文，这就是im系统中消息投递的最核心技术。 可靠消息投递存在什么问题期望六个报文完成消息的可靠投递，但实际情况，msg:N，ack:N这两个报文都可能丢失（原因如第二章所述，可能是服务器奔溃、网络抖动、或者客户端奔溃），此时client-A都收不到期待的ack:N报文，即client-A不能确认client-B是否收到“你好”，但这两个报文的丢失对应的业务影响又大有不同：1）msg:N包丢失，业务结果是client-B没有收到消息2）ack:N包丢失，业务结果是client-B收到了消息，只是client-A不知道而已那怎么办呢？ 消息的超时与重传client-A发出了msg:R，收到了msg:A之后，在一个期待的时间内，如果没有收到ack:N，client-A会尝试将msg:R重发。可能client-A同时发出了很多消息，故client-A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到ack:N，以定时重发。 一旦收到了ack:N，说明client-B收到了“你好”消息，对应的消息将从“等待ack队列”中移除。 消息的重传存在什么问题上面第五部分提到过，msg:N，ack:N都有可能丢失：1）msg:N报文丢失，说明client-B之前压根没有收到“你好”报文，超时与重传机制十分有效2）ack:N报文丢失，说明client-B之前已经收到了“你好”报文（只是client-A不知道而已），超时与重传机制将导致client-B收到重复的消息，那就需要进行消息的去重。 消息去重解决方法也很简单，由发送方client-A生成一个消息去重的msgid，保存在“等待ack队列”里，同一条消息使用相同的msgid来重传，供client-B去重，而不影响用户体验。 其他1）上述设计理念，由客户端重传，可以保证服务端无状态性（架构设计基本准则）2）如果client-B不在线，im-server保存了离线消息后，要伪造ack:N发送给client-A 总结1）im系统是通过超时、重传、确认、去重的机制来保证消息的可靠投递，不丢不重2）一个“你好”的发送，包含上半场 msg:R/A/N 与下半场 ack:R/A/N 的6个报文3）im系统难以做到系统层面的不丢不重，只能做到业务层面的不丢不重]]></content>
      <categories>
        <category>IM</category>
      </categories>
      <tags>
        <tag>IM</tag>
        <tag>消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry布局控件frame为0的问题]]></title>
    <url>%2F2018%2F07%2F06%2FMasonry%E5%B8%83%E5%B1%80%E6%8E%A7%E4%BB%B6frame%E4%B8%BA0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Masonry 是对 autolayout 的封装，优雅的链式语法和简洁易用的接口让我们在做UI开发时节省了不少时间。然而在初次使用它时，由于还对 autolayout 理解不够深，就遇到了一些问题，比如使用 Masonry 对控件添加约束后，并不会立即生效，frame 仍然是 0。如果此时我们需要这个 frame，应该怎么做呢？ 1234567891011UIView *parent = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];UIImageView *child = [UIView alloc] init];[parent addSubview:child];[child mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(20,20)); make.top.left.mas_equalTo(50); &#125;];NSLog(@&quot;%@&quot;,redView);打印结果：** &lt;UIImageView: 0x7fb222605550; frame = (0 0; 0 0); layer = &lt;CALayer: 0x7fb22260b3a0&gt;&gt;** 使用 Masonry 添加约束后，如果有要设置 child 的形状为圆形，就得知道它的 frame，像下面这样写肯定不会设置成功的： 123456[child mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(20,20)); make.top.left.mas_equalTo(50); &#125;]; child.layer.cornerRadius = child.bounds.size.width/2; child.layer.masksToBounds = YES; //设置头像为圆形 因为这时候的 frame 还是 0。曾天真的想，会不会是因为 block 中的处理是在异步线程进行的，不会等待 block 执行完就已经走到了下面使用frame的代码，(一阵狂喜，好聪明。。。)，所以马上把代码改写： 123456[child mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(20,20)); make.top.left.mas_equalTo(50); child.layer.cornerRadius = child.bounds.size.width/2; child.layer.masksToBounds = YES; //设置头像为圆形 &#125;]; 然而并没有什么卵用。 想不通的时候，就只能请教 goole 了，然后找到了 Masonry 约束下获取 frame 的方法 masonry 本就是对 autolayout 的封装，使用 Masonry 就等于使用了苹果的 autolayout。使用 masonry 布局完之后，系统会在某个时间点调用各个 view 的 layoutSubViews 方法，从而更新各个控件的frame。遗憾的是，frame 的更新并不会在刚执行完 Masonry 布局代码时立即进行，在布局代码的下一行，你所获取到的 frame 仍然是0。 想要在布局代码结束就立即获取当前某个控件正确的 frame，需要调用layoutIfNeeded函数立即刷新布局，各个控件才会按照约束条件，生成当前布局相应的frame和bounds。而调用layoutIfNeeded的目的是让系统调用layoutSubviews方法，我们也可以直接在这个方法里获取frame，因为这时候开始layout subviews，Masonry已经计算出了真实的frame。 下面附上关于autolayout更新几个方法的区别： setNeedsLayout：标记页面需要更新，但是什么时候才会调用layoutSubviews 去刷新布局，就不一定了。 layoutIfNeeded：告知页面如果需要，就立刻更新布局。这里的“如果需要”什么意思呢？有什么条件吗？是的，只有满足如下某一个或几个条件，调用 layoutIfNeeded 才会立即刷新frame： 有 addSubview 操作 设置了view的 frame，当然前提是设置前后 frame 的值发生了变化 滚动一个UIScrollView 旋转 Screen 改变一个UIView大小的时候 如果不满足，就算是调用了 layoutIfNeeded 也不会立刻执行 layoutSubViews 进行 frame 更新。 如果我们想不管什么情况，都强制执行 layoutSubViews 进行 frame 更新怎么办呢？那就是同时调用下面这两个方法：12[self setNeedsLayout];[self layoutIfNeeded]; 这样必然会调用 layoutSubViews 。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Masonry</tag>
        <tag>auto layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发琐碎知识点]]></title>
    <url>%2F2018%2F07%2F06%2FiOS%E5%BC%80%E5%8F%91%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[作为一个半路出家的小白、一个为了生活不断积累技术知识的俗人，本着急功近利的的精神把工作中遇到的小问题、琐碎知识点总结下来留给我闺女。…… 1. bringSubViewToFront 不起作用的问题 bringSubViewToFront方法只对该view的childView起作用，而对grandView不起作用，可以用上面的方法，把grandView前置。 最近项目中遇到一个坑，有一个父view，该父view中添加了第三方SDK中的view，所以没有准确判断view的层级关系，导致我添加的一个label无论怎样调用bringSubViewToFront都无法显示在最前面。后来发现原因是，我的label添加后，调用bringSubViewToFront过早，因为这个时候第三方view还没加载上去，所以调用bringSubViewToFront也不会将label显示在第三方veiw的前面。要在第三方view加载完成后，才会起作用。 总结：bringSubViewToFront方法只会将某个view放在其父view的所有已存在的子view的前面。后来添加的view依然有可能遮挡住这个view. 2. 强制某个 viewController 横屏竖屏1234567891011121314151617181920/*方法*/- (void)interfaceOrientation:(UIInterfaceOrientation)orientation&#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = orientation; [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125; 举个栗子：123456789// 横屏- (IBAction)landscapAction:(id)sender &#123; [self interfaceOrientation:UIInterfaceOrientationLandscapeRight];&#125;// 竖屏- (IBAction)portraitAction:(id)sender &#123; [self interfaceOrientation:UIInterfaceOrientationPortrait];&#125; 3. nib 文件加载过程 Outlets are set after -init and before -awakeFromNib. If you want to access outlets, you need to do that in -awakeFromNib or another method that’s executed after the outlets are set (e.g. -[NSWindowController windowDidLoad]). When a nib file is loaded: Objects in the nib file are allocated/initialised, receiving either -init, -initWithFrame:, or -initWithCoder: All connections are reestablished. This includes actions, outlets, and bindings. -awakeFromNib is sent to interface objects, file’s owner, and proxy objects. 4. table view 优化123456789101. cell 复用2. view 的opaque属性尽可能设置为 YES3. 避免渐变、图像伸缩、离屏渲染4. 如果cell高度不变，缓存计算出的高度5. 如果cell展示的内容包含网络请求的内容，缓存并且异步加载6. 阴影用shadow path7. 尽可能减少cell的subviews数量8. 在cellForRowAtIndexPath回调中尽可能少做事，如果必须，尽可能缓存耗时操作的结果9. 抽象出合理的数据结构来展示信息10.直接设置rowHeight、sectionFooterHeight、sectionHeaderHeight的值，不要在相应的代理中设置 5. xib 中使用 autolayout 布局关于 xib 中使用 autolayout 布局的问题，下面两张图应该说明的很明白了。 6. 使用 setValue:forKey:设置对象属性值在使用 setValue:forKey: 设置对象属性值时，不管该属性是否为只读的、不管在 .h 或者 .m 文件中，都能够成功设置！ 果如你重写了这个属性的 setter 方法，那么也会走该属性的 setter 方法。 7. Class / id / objc_objectObjective-C类是由 Class 类型来表示的，它实际上是一个指向objc_class 结构体的指针。Class 的定义如下：1typedef struct objc_class *Class; 查看 objc/runtime.h 中 objc_class 结构体的定义如下： 12345678910111213141516struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 由 objc_class 结构体可知，在 objective-C 中，所有的类自身也是一个对象，里面有一个 Class 类型的 isa 指针，指向 metaClass(元类)。 super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。 cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，提高了调用效率。 objc_object 是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：1234567/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; id 类型是一个指向 objc_object 结构体类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。 在 Objective-C，一个对象的类由它的 isa 指针决定。isa 指针指向这个对象的 Class。在 Objective-C 中，对象的一个重要的特性是，你可以向它们发送消息： 当你向一个对象发送消息，就在那个对象的方法列表中查找那个消息。 当你想一个类发送消息，就再那个类的 meta-class 中查找那个消息。 meta-class 是一个类对象的类 当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。 meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class ，因为每个类的类方法基本不可能完全相同。 meta-class 是必须的，因为它为一个 Class 存储类方法。每个类都必须有一个唯一的 meta-class，因为每个 Class 都有一个可能不一样的类方法。 meta-class，如之前的 Class，同样是个对象。这就意味着你也可以在它上面调用方法。自然的，这就意味着它也必须有一个类 所有的 meta-class 使用它们基类的 meta-class （继承层次中最顶层的 Class 的 meta-class）作为它们自己的类。这就是说所有继承自 NSObject 的类（大部分的类），以 NSObject 的 meta-class 作为自己的 meta-class 的类。 遵循这个规则，所有的 meta-class 使用基类的 meta-class 作为他们的类，任何基类的 meta-class 将会是他们自己（它们的 isa 指向他们自己）。这就是说 NSObject 的 meta-class 的 isa 指针指向它们自己（是自己的一个实例）。 8. nullable、__nullable、_Nullable 究竟有什么区别 对于属性、方法返回值、方法参数的修饰，使用： nonnull/nullable 对于 C 函数的参数、Block 的参数、Block 返回值的修饰，使用： _Nonnull/_Nullable ， 建议弃用 nonnull/nullable 如果需要每个属性或每个方法都去指定 nonnull 和 nullable ，将是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END 。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull ，因此我们只需要去指定那些 nullable 指针对象即可。 疑问：为什么已经有了 nonnull/nullable ，为什么还要增加 _Nonnull/_Nullable ？ 9. 使用pathForResource获取不到 bundle 里的资源，返回nil的问题通过 右键-&gt;add files to 的方式将 Bundle 添加到工程里面，但是使用[[NSBundle mainBundle] pathForResource:@”name” ofType:@”type”]时，无论如何都找不到文件，经过了重启工程 、clear工程以及重启电脑等方式都无法解决问题。经过思考和测试，感觉这可能是xcode的一个bug。 解决办法及原理是这样的，[NSBundle mainBundle]其获取的路径是你程序的安装路径下的资源文件位置。 在xcode中采用add file to 方式添加文件时，一般情况下xcode会自动将文件添加到你的资源文件，而且，这些文件在你工程的 build Phases 中的 copy Bundle Resources 中可以查看到。但是有时候，由于xcode的问题，采用add files to 不能自动添加到你的资源文件中，这时，可以采用copy Bundle Resources下面的“+”号，手动将文件添加到你的资源文件中，这样就可以解决问题了。 10. 新建 window 并设置它的 rootViewController 遇到的状态栏问题新建 window 并设置它的 rootViewController ，在 rootViewController 中想要自定义状态栏样式或者隐藏状态栏，遇到的问题是，如果该 window 的 frame 不等于 [UIScreen mainScreen].bounds ，那么在 rootViewController 中想要使用下面两个方法设置状态栏时，是无效的，因为此时这两个方法不会调用： 12- (UIStatusBarStyle)preferredStatusBarStyle;- (BOOL)prefersStatusBarHidden Apple 这样做是有理由的，比如新建 window 不能覆盖整个屏幕，只是一个很小的悬浮框，此时的 rootViewController 不需要控制状态栏样式。 当不设置 window 的 frame 或者设置 window 的 frame 为 [UIScreen mainScreen].bounds 时，在 rootViewController 中才能够设置状态栏样式。 12345678910111213//能够正确设置状态栏的代码：UIWindow *delegateWindow = [UIApplication sharedApplication].delegate.window;CGRect rect = [UIScreen mainScreen].bounds;self.window = [[UIWindow alloc] init];self.window.rootViewController = self.rootVC;[self.window makeKeyAndVisible];self.window.frame = CGRectMake(0, -rect.size.height, rect.size.width, rect.size.height);// 保持原先的keyWindow，避免一些奇怪的bug[delegateWindow makeKeyWindow];[UIView animateWithDuration:0.3 animations:^&#123; self.window.frame = rect;&#125; completion:NULL]; 11. 当 present 一个viewController并且设置这个viewController背景透明度时，背景色变黑的问题想模态展示一个VC窗口，设置它的背景透明度为0.5，却发觉prsent后的背景色变为黑色。 原因是： NavigationController and the View Controllers are designed in such a way that only one view controller may show at a time. When a new view controller is pushed/presented the previous view controller will be hidden by the system. So when you reduce the modal view’s alpha you will possibly see the window’s backgroundColor (the black color you see now). If you want a translucent view to slide-in over the main view, you can add the view as the subView of main view and animate it using UIView Animations. 解决方法可以是 ：直接动画添加view或者 设置模态VC的属性 modalPresentationStyle 为UIModalPresentationCustom 12. App支持从4种来源去打开一个VC页面 Push推送 App外部网页打开 App内部网页打开 应用内点击打开 这四种方式均跳转到 DetailViewController 界面。普通的跳转依然可以满足该场景, 最简单的解决方案是在四个不同的地方都写一个独立的界面打开逻辑。作为一名有追求的开发者, 这么冗余的四份入口代码显然不合适。 一种解决方案是采用 URL 协议统一跳转。每个 viewController 页面定义与之对应的 URL，在各个入口只需要调用打开该URL的方法即可完成页面的创建以及跳转。 基于URL的路由方案： SNMediator 是用于 iOS 应用进行模块化拆分的中间件框架，它不依赖任何第三方库，基于 URL 协议实现三端(iOS, Android, H5)统一的页面跳转方式。 例如：你的 APP DetailViewController 界面对应URL定义为：myapp://businessModule/goodsdetails/?id=100其中，scheme为 myapp，host为 businessModule，path为 goodsdetails，携带参数 id=100. 使用 SNMediator 跳转页面方法如下： 123+ (BOOL)routeURL:(nonnull NSURL *)URL withParams:(nullable NSDictionary *)params completion:(void(^ _Nullable)(id _Nullable result))completion;[SNMediator routeURL:@&quot;myapp://businessModule/goodsdetails/?id=100&quot; params:nil completion:NULL]; SNMediator 支持通过字典传递额外的自定义复杂对象，也支持URL自身携带参数。所以4种入口都可以通过这一句代码调用完成页面跳转，保持了不同入口跳转同一界面的代码一致性。 13. iOS 中一个viewController只能 present 出来唯一一个其他viewController如果你要在同一个 viewController 中上同时 present 两个viewController，比如：12345SNViewControllerOne *oneVC = [[SNViewControllerOne alloc] init]; [self presentViewController:oneVC animated:YES completion:^&#123; SNViewControllerTwo *twoVC = [[SNViewControllerTwo alloc] init]; [self presentViewController:twoVC animated:YES completion:NULL]; &#125;]; 此时界面上只会显示 oneVC 的视图，不会显示 twoVC 并且 twoVC 也不存在于视图栈中。这是因为当一个新的 viewController 被 push/present 时，先前的那个 viewController 就会被系统隐藏，所以不会出现在视图栈中。 When a new view controller is pushed/presented the previous view controller will be hidden by the system. 并且在控制台还会给出警告： Warning: Attempt to present &lt; SNViewControllerTwo: 0x7ff813c5c760&gt; on &lt;SNRootViewController: 0x7ff813e307c0&gt; whose view is not in the window hierarchy! 告诉你当 SNRootViewController present 出来 SNViewControllerOne 后，再试图 present SNViewControllerTwo 时，SNRootViewController 已经被隐藏，不再存在于 window 的视图层级中，所以也就无法在 SNRootViewController 基础上继续 present 另一个视图。 14. UIGestureRecognizerState 各个状态的变化UIGestureRecognizerState的定义如下: 123456789typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; UIGestureRecognizerStatePossible, UIGestureRecognizerStateBegan, UIGestureRecognizerStateChanged, UIGestureRecognizerStateEnded, UIGestureRecognizerStateCancelled, UIGestureRecognizerStateFailed, UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded &#125;; Remarks:This describes the state of a UIGestureRecognizer. All of UIGestureRecognizers start in the Possible state. Once one or more touches has been received, the recognizers transition to the Began state. For one-shot patterns (like Tap), this will either transition into the Recognized state or the Failed state. For continuous gestures (like panning, pinching, rotating) the recognizer will transition to the Changed state and emit multiple calls back to the action and finally transition to either the Ended or Cancelled states. 15. NULL / nil / Nil / NSNullC 用 0 来作为不存在的原始值，而NULL作为指针，这在指针环境中相当于 0。 Objective-C 在 C 的表达不存在的基础上增加了nil。nil 是一个指向不存在的对象指针。虽然它在语义上与NULL 不同，但它们在技术上是相等的。 在框架层面，Foundation 定义了 NSNull，即一个类方法 +null，它返回一个单独的 NSNull 对象。NSNull 与 nil 以及 NULL 不同，因为它是一个实际的对象，而不是一个零值。、 在 Foundation/NSObjCRuntime.h 中，Nil 被定义为指向零的类指针。它并不常常出现，但至少值得注意。 16. CGGeometryGRect 用于表示屏幕上绘制的所有视图的 frame，一个程序员操作矩形几何体的能力决定着他在图形编程上的成功。 变换几何变换，这些函数返回在传入的矩形中做某些特定操作后的 CGRect CGRectOffset: 返回一个原点在源矩形基础上进行了偏移的矩形 12345CGRect CGRectOffset( CGRect rect, CGFloat dx, CGFloat dy) 注意，用这个你只改变了矩形的原点。它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。 CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形 12345CGRect CGRectOffset( CGRect rect, CGFloat dx, CGFloat dy) 注意，用这个你只改变了矩形的原点。它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。 CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形 12345CGRect CGRectInset( CGRect rect, CGFloat dx, CGFloat dy) 想一个视图中的视图更好看吗？用CGRectInset给它设置一个 10pt 的边距吧。需要记住的是，矩形将围绕它的中心点进行缩放，左右分别增减dx（总共2 x dx），上下分别增减 dy（总共 2 x dy）。 如果你用 CGRectInset 作为缩放矩形的快捷方法，一般通用的做法是嵌套调用CGRectOffset，把CGRectInset的返回值作为CGRectOffset的参数。 CGRectIntegral: 返回包围源矩形的最小整数矩形 123CGRect CGRectIntegral ( CGRect rect) 将CGRect 取整到最近的完整点是非常重要的。小数值会让边框画在像素边界处。因为像素已经是最小单元（不能再细分），小数值会使绘制时取周围几个像素的平均值，这样看起来就模糊了。 CGRectIntegral 将表示原点的值向下取整，表示大小的值向上取整，这样就保证了你的绘制代码平整地对齐到像素边界。 作为一个经验性的原则，如果你在执行任何一个可能产生小数值的操作（例如除法，CGGetMid[X|Y]，或是 CGRectDivide），在把一矩形作为视图的边框之前应该用CGRectIntegral正则化它。 从技术上讲，坐标系讲的是点，而视网膜屏一个点中有四个像素，所以它在奇数像素± 0.5f处绘制也不会产生模糊。 取值辅助函数CGRectGet[Min|Mid|Max][X|Y] 123456CGRectGetMinXCGRectGetMinYCGRectGetMidXCGRectGetMidYCGRectGetMaxXCGRectGetMaxY 这六个函数返回矩形x或y的最小、中间或最大值，原型如下： 123CGFloat CGRectGet[Min|Mid|Max][X|Y] ( CGRect rect) 用这些函数代替诸如frame.origin.x + frame.size.width之类的代码将更加清晰、语义上更为生动的（特别是用取中间和取最大函数）。 CGRectGet[Width|Height] CGRectGetHeight: 返回矩形的高度。 123CGFloat CGRectGetHeight ( CGRect rect) CGRectGetWidth: 返回矩形的宽度。 123CGFloat CGRectGetWidth ( CGRect rect) 跟之前的函数一样，用CGRectGetWidth 和 CGRectGetHeight返回CGRect的size成员更可取。这绝不只是节省了几个字符，语义上的清晰胜过简洁。 常量这里列出了三个我们必须了解的特殊矩形值，它们都有一些独一无二的属性： CGRectZero， CGRectNull，和 CGRectInfinite const CGRect CGRectZero: 一个原点在(0, 0)，且长宽均为 0 的常数矩形。这个零矩形与 CGRectMake(0.0f, 0.0f, 0.0f, 0.0f) 是等价的。 const CGRect CGRectNull: 空矩形。这个会在，比如说，求两个不相交的矩形的相交部分时返回。注意，空矩形不是零矩形。 const CGRect CGRectInfinite: 无穷大矩形。 CGRectZero 可能是所有这些特殊矩形中最有用的了。当初始化一个视图时，它们的边框通常设置为CGRectZero，把布局放到 -layoutSubviews中。 CGRectNull 跟 CGRectZero 是两回事，尽管它隐隐约约让你感觉到NULL == 0。这个值在概念上与NSNotFound相近，所以它表示预期值的缺失。请注意函数可能返回 CGRectNull，同时也应让它能正确处理传入的CGRectIsNull。 CGRectInfinite 是以上所有当中最有异国风情的，并且有一些最有趣的属性。它与所有的点或矩形相交，包含所有矩形，且它与任何矩形的并集等于它自身。用 CGRectIsInfinite 来检查一矩形是否为无限大。 最复杂、最容易误解、也最有用的CGGeometry 函数：CGRectDivide。 CGRectDivide: 将源矩形分为两个子矩形。 1234567void CGRectDivide( CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge) CGRectDivide 用以下方式将矩形分割为两部分： (1). 传入一个矩形并选择一条edge（上，下，左，右）(2). 平行那个边在矩形里量出amount的长度(3). 从edge 到量出的amount区域都保存到slice 参数中(4). 剩余的部分保存到remainder 参数中 其中 edge 参数是一个CGRectEdge 枚举类型： 123456enum CGRectEdge &#123; CGRectMinXEdge, CGRectMinYEdge, CGRectMaxXEdge, CGRectMaxYEdge&#125; CGRectDivide 用于在几个视图之间分割可用空间真是太完美了（把它在随后的remainder容纳多于两个的视图）。下次当你需要手机布局一个UITableViewCell时试试吧。CGRectDivide is perfect for dividing up available space among several views (call it on subsequent remainder amounts to accommodate more than two views). Give it a try next time you’re manually laying-out a UITableViewCell. 综上所述，如果你不重视 Geometry 类的话将会怎样…]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>知识点总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说iOS并发编程]]></title>
    <url>%2F2018%2F07%2F06%2F%E7%BB%86%E8%AF%B4iOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[并发编程是一个很有挑战的任务，它有许多错综复杂的问题和陷阱。在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文参考 objc.io 上iOS多线程的一篇文章：线程安全类的设计，以及 raywenderlich 上的 Grand Central Dispatch In-Depth:Part 1/2 , Grand Central Dispatch In-Depth:Part 2/2 ，还有这篇 iOS多线程到底不安全在哪里。同时c参考了苹果 Guides and Sample Code 中关于并发编程的章节。 并发编程相关的几个概念进程（Process） 简单来说，进程是指系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 线程（thread） 是操作系统能够进行运算调度的最小单，是组成进程的子单元。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。说得再具体一些，线程就是“一个CPU执行的一条无分叉的命令序列”。所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。 同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间、文件描述符等。但每个线程都拥有自己的栈，寄存器，本地存储（thread-local storage）。一个进程可以有很多线程，每条线程并行执行不同的任务，称为多线程。 多个线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么多个线程就可以真正的并行处理，从而减少了完成某项操作所需要的总时间。 并发(Concurrent)/并行(Parallel) 很多人对并发/并行的概念感到困惑，按照我的理解，并发所描述的概念是“同时”运行多个线程，多个线程“同时”被处理。这里对同时加了引号，因为这些线程可能是在单核 CPU 上以分时（时间共享）的形式，在极短的时间片段间不停的切换运行(类似通信中的时分复用(TDM))，也可能是在多核 CPU 上以真正的并行方式同时运行。 关于并发和并行，可以用下面这张有趣的图解释： 如果还是不能理解，或许应该看下这段准确的英文解释： Concurrency and parallelism are often mentioned together, so it’s worth a short explanation to distinguish them from each other. Separate parts of concurrent code can be executed “simultaneously”. However, it’s up to the system to decide how this happens — or if it happens at all. Multi-core devices execute multiple threads at the same time via parallelism; however, in order for single-cored devices to achieve this, they must run a thread, perform a context switch, then run another thread or process. This usually happens quickly enough as to give the illusion of parallel execution Although you may write your code to use concurrent execution under GCD, it’s up to GCD to decide how much parallelism is required. Parallelism requires concurrency, but concurrency does not guarantee parallelism. The deeper point here is that concurrency is actually about structure. When you code with GCD in mind, you structure your code to expose the pieces of work that can run simultaneously, as well as the ones that must not be run simulataneously. If you want to delve more deeply into this subject, check out this excellent talk by Rob Pike. 临界区(Critical Section) 不能被两个线程同时执行的一段代码叫做临界区。因为这段代码通常操控着一个共享的临界资源(一次仅允许一个线程使用的共享资源)，多个线程必须互斥的访问该临界资源。只能被单一线程/进程访问的共享资源，比如打印机等。 竞态条件(Race Condition) 软件系统的正确行为依赖于多个线程交替执行的时序时，就会发生竞态条件。常见的竟态条件为： 先检测后执行。执行依赖于检测的结果，而检测结果取决于多线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现问题。 对于 main 线程，如果文件a不存在，则创建文件a，但是在判断文件a不存在之后，Task线程创建了文件a，这时候先前的判断结果已经失效（main线程的执行依赖了一个错误的判断结果），此时文件a已经存在了，但是 main 线程还是会继续创建文件a，导致 Task 线程创建的文件a被覆盖、文件中的内容丢失等等问题。多线程环境中对同一个文件的操作要加锁。 延迟初始化（最典型即为单例） 12345678static MyObject *instance = nil;+ (instancetype)shareInstance&#123; if (instance == nil) &#123; instance = [[MyObject alloc] init]; &#125; return instance;&#125; 假如线程thread1和线程thread2同时执行 shareInstance，thread1 看到 instance 为空，创建了一个新的 Obj 对象，此时 thread2 也需要判断 instance 是否为空，此时的 instance 是否为空取决于不可预测的时序：包括 thread1 创建 Obj 对象需要多长时间以及线程的调度方式，如果 thread2 检测时，instance为空，那么 thread2 也会创建一个 instance 对象 死锁(Deadlock) Two (or sometimes more) threads are said to be deadlocked if they all get stuck waiting for each other to complete or perform another action. The first can’t finish because it’s waiting for the second to finish. But the second can’t finish because it’s waiting for the first to finish.(翻译水平有限，英文可以更好的理解) 线程安全(Thread Safe) 是指代码在多线程或者并发任务下能够被安全调用，而不会引起任何问题(data corruption, crashing, etc)。非线程安全代码必须只能运行在单线程环境下。 上下文切换(Context Switch) A context switch is the process of storing and restoring execution state when you switch between executing different threads on a single process(进程). iOS 和 OS X 中的并发编程苹果的移动和桌面操作系统中提供了相同的并发编程API。 这里会介绍 pthread 、 NSThread 、GCD 、NSOperationQueue，以及 NSRunLoop。实际上把 run loop 也列在其中是有点奇怪，因为它并不能实现真正的并行，不过因为它与并发编程有很大的关系，因此值得我们进行一些深入了解。 需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，也无法控制执行多长时间后将被暂停，以便轮换执行别的任务。开发者可以使用 POSIX 线程 API，或者 Objective-C 中提供的对该 API 的封装 NSThread，来创建自己的线程。下面这个小Demo利用 pthread 在一百万个数字中查找最小值和最大值，其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct inputInfo &#123; uint32_t *intputValues; size_t count;&#125;;struct resultInfo &#123; uint32_t min; uint32_t max;&#125;;void * findMinAndMax(void *arg)&#123; struct inputInfo const * const info = (struct inputInfo *)arg; uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i &lt; info-&gt;count; i++) &#123; uint32_t temp = info-&gt;intputValues[0]; min = MIN(temp, min); max = MAX(temp, max); &#125; free(arg); struct resultInfo *const result = (struct resultInfo *)malloc(sizeof(*result)); result-&gt;max = max; result-&gt;min = min; return result;&#125;int main(int argc, const char * argv[])&#123; // 使用随机数字填充 inputValues size_t const count = 1000000; uint32_t inputValues[count]; // 使用随机数字填充 inputValues for (size_t i = 0; i &lt; count; ++i) &#123; inputValues[i] = (uint32_t)i; &#125; // 开始4个寻找最小值和最大值的线程 size_t const threadCount = 5; pthread_t tid[threadCount]; for (size_t i = 0; i &lt; threadCount; ++i) &#123; struct inputInfo * const info = (struct inputInfo *) malloc(sizeof(*info)); size_t offset = (count / threadCount) * i; info-&gt;intputValues = inputValues + offset; info-&gt;count = MIN(count - offset, count / threadCount); int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info); NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err); &#125; // 等待线程退出 struct resultInfo * results[threadCount]; for (size_t i = 0; i &lt; threadCount; ++i) &#123; int err = pthread_join(tid[i], (void **) &amp;(results[i])); NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err); &#125; // 寻找 min 和 max uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i &lt; threadCount; ++i) &#123; min = MIN(min, results[i]-&gt;min); max = MAX(max, results[i]-&gt;max); free(results[i]); results[i] = NULL; &#125; NSLog(@&quot;min = %u&quot;, min); NSLog(@&quot;max = %u&quot;, max);&#125; return 0; NSThread 是 Objective-C 对 pthread 的封装，比直接使用 pthread 更方便些。但是不论使用 pthread 还是 NSThread 直接对线程操作，都是相对糟糕的编程体验。 直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。 下面介绍两种基于队列的并发编程API：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的线程池，来解决创建过多线程导致的问题。 Grand Central Dispatch为了让开发者更加容易的充分利用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。 通过GCD，开发者不必再直接跟线程打交道。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。 GCD中的两个核心概念是“任务”和“队列”，开发者只需专注于想要执行的“任务” block，然后添加到适当的“队列”中，这种形象的抽象方式更容易被人理解和使用。 GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 任务最终都将被放入到系统的全局队列和线程池中，如下图所示： 我们强烈建议，在大多数情况下使用默认优先级的队列就可以了，如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。 虽然 GCD 是一个低层级的 C 语言 API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱，这些将在后面并发编程带来的问题中进行讨论。 串行队列(Serial Queues) 串行队列中的任务，每次只执行一个，先前的任务执行完毕后，才会执行下一个。当然，你不会知道一个block结束与下一个block开始之间的时间间隔是多少，如下图所示： 这些任务的执行时间是在GCD的控制之下，你唯一能够确定的是：GCD每次只执行一个任务，任务执行顺序就是它们被加入队列的顺序。 因为在串行队列中两个任务不可能并发运行，所以就没有可能会同时访问同一个临界区的风险。所以仅对于这些任务而言，这种运行机制能够保护临界区避免发生竟态条件。所以，如果访问临界区的唯一方式是通过被提交到那个串行队列中的任务，那么你可以确保临界区是安全的。 并发队列(Concurrent Queues) 在并发队列中，你能够保证的仅有一件事：任务的执行顺序就是它们被添加到队列中的顺序。对于每个任务的完成顺序、下一个任务什么时候开始以及在任意给定时间内正在运行的 blocks 数量都是不清楚的，这些完全取决去 GCD。下图展示了在GCD下4个并发任务的执行： 上图表达的意思是，一个 block 什么时候开始执行完全取决于 GCD，如果一个 blcok 的执行时间与另一个重叠，由 GCD 决定这个 block 是需要运行在另一个核心上，还是在同一个核心上通过上下文切换(context switch)的方式执行。 队列类型系统提供了一个特殊的串行队列叫主队列(main queue)，像其他串行队列一样，主队列中的任务每次执行一个，但是能够确定的是，主队列中的所有任务都在主线程执行，主线程是唯一允许更新UI的线程。主队列用来向 UIViews 对象发送消息或者发送通知。 系统还提供了4种不同优先级的全局并发队列(Global Dispatch Queues)：background、low、default、high，优先级由低到高。需要注意的是，苹果的 API 也使用了这些队列，所以这些队列中并非只有你自己添加的任务。 最后，你还可以创建自定义串行/并发队列。也就是说，至少有五种队列可供选择：主队列、4个全局并发队列、自定义队列。 And that’s the big picture of dispatch queues! GCD 的“艺术”归根结底在于选择合适的队列派发函数(dispatch function)将任务提交到特定队列中。下面举例说明几种常用的 dispatch function。 (1). dispatch_async 12345678- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;First Log&quot;); // 1 &#125;); NSLog(@&quot;Second Log&quot;); // 2&#125; 下面这个动态图生动的呈现出究竟发生了什么，左侧是代码中的断点，右侧是相关队列的状态： 主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内； viewDidLoad 在主线程执行 现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_async dispatch_async 的 block 被添加到一个全局队列并且稍后将会执行它 在 dispatch_async 添加 block 到全局队列之后，viewDidLoad继续向下走，主线程把注意力放在剩余的任务上。与此同时，全局队列也正在并发的处理它的任务。再次提醒，全局队列中的任务将以 “FIFO” 的顺序出队(分发下去)，但是这些任务会被并发执行。 现在，被 dispatch_async 添加的 block 正在执行了 dispatch_async 的 block 执行完毕，所有的 NSLog 语句都已经将输出打印到了控制台。尽管在这个小例子中先执行了第二条打印任务，随后才执行第一条，不过 First Log 和 Second Log 打印顺序不定 —— 取决于在那个特定时间硬件正在处理的事情，你没有办法控制或者知晓哪条语句先执行。 什么时候以及怎样使用 dispatch_async 和各种队列 自定义串行队列：当你想在后台串行的执行任务并跟踪这个任务的执行状态时，使用自定义串行队列是一个好的选择。这样能消除资源竞争，因为在同一时刻仅有一个任务正在执行。 主队列(Serial)：通常，在并发队列中的一项任务处理完成后，就需要更新UI。此时你需要嵌套 block 把UI更新任务提交到主队列。如果你现在已经处于主队列，并调用 dispatch_async 将任务添加到主队列，此时你唯一能确保的是，这个新添加的任务将在当前方法执行完毕后的某个时间才被执行。 并发队列：通常使用并发队列在后台处理非UI操作。 (2). dispatch_sync 12345678- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;First Log&quot;); // 1 &#125;); NSLog(@&quot;Second Log&quot;); // 2&#125; 上图中各个步骤的说明如下： 主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内 viewDidLoad 在主线程执行 现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_sync dispatch_sync 的 block 被添加到一个 global queue 并且稍后将会执行它。主线程会被阻塞，直到 block 执行完毕。与此同时，global queue 正在并发的处理任务；在这个 global q ueue 中，所有 block 任务将按照 “FIFO” 的顺序出队，但是会被并发执行。 global queue 处理先前已经加入队列的任务(在 dispatch_sync block 之前添加到该全局队列中的任务) 开始执行 dispatch_sync 的 block block 执行完毕，dispatch_sync 函数返回，主线程恢复 viewDidLoad 方法执行完毕，主队列继续处理其他任务 dispatch_sync 函数将一个任务添加到一个队列中，会阻塞当前线程，直到该任务执行完毕。dispatch_async 不会等待任务执行完，当前线程会继续往下走，不会阻塞当前线程。使用 dispatch_sync 时应注意避免死锁(deadlock)！ Here’s a quick overview of when and where to use dispatch_sync: Custom Serial Queue: Be VERY careful in this situation; if you’re running in a queue and call dispatch_sync targeting the same queue, you will definitely create a deadlock. Main Queue (Serial): Be VERY careful for the same reasons as above; this situation also has potential for a deadlock condition. Concurrent Queue: This is a good candidate to sync work through dispatch barriers or when waiting for a task to complete so you can perform further processing. (3). dispatch_after 使用 dispatch_after 延迟执行某个任务。比如在1秒后执行某个block。代码如下：12345double delayInSeconds = 1.0; dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123; // 2 // your task delay to execute &#125;); dispatch_after works just like a delayed dispatch_async!! dispatch_after 在功能上就像延迟了的 dispatch_async，你没有办法掌控任务的实际执行时间，并且一旦 dispatch_after 函数返回，就没有办法取消任务。 怎样使用 dispatch_after: 自定义串行队列：在自定义串行队列中谨慎使用 dispatch_after 主队列(Serial)：主队列中使用 dispatch_after 是一个好的选择 并发队列：谨慎使用，一般你很少在自定义并发队列中使用 dispatch_after (4). Dispatch Group dispatch_group_create：创建 diapatch group1dispatch_group_t group = dispatch_group_create(); dispatch_group_async：提交 block 到 dispatch queue 中，并将 block 和 group 关联起来123dispatch_group_async(group, queue, ^&#123; // block&#125;); dispatch_group_wait：阻塞当前线程，等待 group 关联的所有 block 执行完毕或者到达指定时间。如果到达指定时间后，所有任务并没有全部完成，那么 dispatch_group_wait 返回一个非 0 的数，可以根据这个返回值，判断是否等待超时。如果设置为 DISPATCH_TIME_FOREVER ，意思是永远等待，直到所有 block 执行完毕。1dispatch_group_wait(group, DISPATCH_TIME_FOREVER); dispatch_group_notify：不阻塞当前线程，当 group 关联的所有 block 执行完毕后，回调通知123dispatch_group_notify(group, queue, ^&#123; // 所有 block 执行完毕的回调&#125;); 注意:123dispatch_group_async(group, queue, ^&#123; // block&#125;); 等价于12345dispatch_group_enter(group);dispatch_async(queue, ^&#123; // block dispatch_group_leave(group);&#125;); when and how to use dispatch groups with the various queue types: Custom Serial Queue: This is a good candidate for notifications when a group of tasks completes. Main Queue (Serial): This is a good candidate as well in this scenario. You should be wary of using this on the main queue if you are waiting synchronously for the completion of all work since you don’t want to hold up the main thread. However, the asynchronous model is an attractive way to update the UI once several long-running tasks finish such as network calls. Concurrent Queue: This as well is a good candidate for dispatch groups and completion notifications. (5). dispatch_apply 提交 block 到 dispatch queue，并重复调用多次 (Submits a block to a dispatch queue for multiple invocations.) dispatch_apply 就像 for 循环一样，并发执行每次的迭代任务。dispatch_apply 函数是同步的，直到所有任务执行完毕，才会返回。如果有大量迭代次数，并且每次迭代都仅处理少量工作，那么并不适合使用 dispatch_apply。 When is it appropriate to use dispatch_apply? Custom Serial Queue: A serial queue would completely negate the use of dispatch_apply; you might as well just use a normal for loop. Main Queue (Serial): Just as above, using this on a serial queue is a bad idea. Just use a normal for loop. Concurrent Queue: This is a good choice for concurrent looping, especially if you need to track the progress of your tasks. (6). 信号量 信号量是持有计数的信号，使用它控制对有限资源的使用和访问。假设有一间房子，它对应一个进程，房子里的两个人就对应两个线程。这个房子(进程)有很多资源，比如花园、客厅、卫生间等，是所有人(线程)共享的。但是有些地方，比卫生间，最多只能有1个人能进去。怎么办呢，在卫生间门口挂1把钥匙。进去的人(线程)拿着钥匙进去(信号量 -1)，外面的人(线程)没有钥匙就在门口等待，直到里面的人出来并把钥匙重新放回门口(信号量+1)，此时外面等待的人再拿着这个钥匙进去，所有人(线程)就按照这种方式依次访问卫生间这个有限的资源。门口的钥匙数量就称为信号量(Semaphore)。信号量为0时需要等待，信号量不为零时，减去1而且不等待。 The semantics for using a dispatch semaphore are as follows: When you create the semaphore using the dispatch_semaphore_create function, you can specify a positive integer indicating the number of resources available. In each task, call dispatch_semaphore_wait to wait on the semaphore. When the wait call returns, acquire the resource and do your work. When you are done with the resource, release it and signal the semaphore by calling the dispatch_semaphore_signal function. 举个栗子：12345678910111213141516171819202122232425dispatch_group_t group = dispatch_group_create(); dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); NSMutableArray *mutableArr = [NSMutableArray array]; for (NSInteger i = 0; i &lt; 10000; i++) &#123; dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; /* 某个线程执行到这,如果信号量值为1，执行了wait方法后，信号量的值变成了0。并开始执行下面的代码。 */ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /* 这时候信号量的值为0，其它线程都处于等待状态。这样对 mutableArr 进行修改的线程， 在任意时刻都只有一个，能够保证多线程下读写 mutableArr 的安全性 */ [mutableArr addObject:@(i)]; /* 执行结束，要调用signal方法，把信号量的值加1。 这样，其他等待的线程按照等待的先后顺序继续访问 mutableArr */ dispatch_semaphore_signal(semaphore); &#125;); &#125; dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;%@&quot;,mutableArr.lastObject); 信号量与互斥锁 信号量：关注的是信号，信号！可以使用在线程间和进程间。只要信号是允许的，线程就可以访问某个资源。互斥锁：只能用于线程间。使用时会锁住某个资源，只允许当前一个线程访问，其他线程无法访问，处于等待状态。解锁后其他处于等待状态的线程被唤醒，然后按照等待排队顺序继续访问。 (7). dispatch_barrier 栅栏函数 dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用，它等待所有位于 barrier 函数之前的队列中的任务执行完毕后，再执行barrier block 中的任务，并且等待 barrier block中的任务执行完毕之后，barrier函数后续的任务才会得到执行，该函数需要同dispatch_queue_create 函数生成的并发队列(concurrent queue) 一起使用。 举个栗子：12345678910111213141516171819202122232425- (void)barrier&#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;1&quot;); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;2&quot;); &#125;); dispatch_barrier_async(concurrentQueue, ^&#123; NSLog(@&quot;barrier&quot;); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;3&quot;); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;4&quot;); &#125;);&#125;输出：1 2 barrier 4 3 其中1 2 与 3 4 由于异步执行先后顺序可能有变，但是 barrier 一定位于他们中间。 看一段官方文档能够更好的理解： 调用 dispatch_barrier_async 函数总会在 block 任务提交后立即返回，而不等待 block 被调用。 When the barrier block reaches the front of a private concurrent queue, it is not executed immediately. Instead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes. The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_createfunction. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_asyncfunction. 多线程并发带来的陷阱使用并发编程会带来许多陷阱。一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。 关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务戛然而止，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为优先级反转，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。 并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性，一个对象，通用的内存、网络设备或者一个文件等等。在多线程中，任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计，以防止这种冲突的发生。 为了演示这类问题，我们举一个关于资源的简单示例：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。问题来了，你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。 我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。 这个问题被叫做竞态条件，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。 在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序。 互斥锁 互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的互斥锁，只有当某个线程对资源完成了操作，释放掉这个互斥锁，这样别的线程才有机会访问该共享资源。 除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入内存屏障(Memory barrier)。通过设置 Memory barrier，来确保没有无序执行的指令能跨过屏障而执行。 当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：底层并发技术。 从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。 在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。 锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(锁的竞争是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。 在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出临界区段（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。 我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 CPU strategy view 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。 死锁 互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。 看看下面的代码，它交换两个变量的值：1234567891011void swap(A, B)&#123; lock(lockA); lock(lockB); int a = A; int b = B; A = b; B = a; unlock(lockB); unlock(lockA);&#125; 大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：12swap(X, Y); // 线程 1swap(Y, X); // 线程 2 此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。 再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。 资源饥饿（Starvation) 当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起读写问题。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。 为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 writer preference，或者使用 read-copy-update 算法。Daniel 在底层并发编程 API 中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。 优先级反转 本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的优先级反转。 优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。 高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。 在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。 解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。 从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。 总结我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。 但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。 我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
