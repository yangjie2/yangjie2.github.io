<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Objective-C 如何hook block]]></title>
    <url>%2F2019%2F09%2F26%2FObjective-C-%E5%A6%82%E4%BD%95hook-block%2F</url>
    <content type="text"><![CDATA[利用 Objective-C 语言的 runtime 特性， 通过 Method Swizzling 技术可以实现 hook OC 类的某个方法，但是怎么 hook block 呢？比如想要修改 block 的实现我们该怎么做？ Block 是怎样实现的首先 Block 也是 OC 对象，它的 isa 指针在初始化时指向 &amp;_NSConcreteStackBlock 或者 &amp;_NSConcreteGlobalBlock，Block 的结构如下： 123456789101112131415161718struct Block_literal_1 &#123; void *isa; // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor_1 &#123; //记住这个变量和结构体，它很重要！ unsigned long int reserved; // NULL unsigned long int size; // sizeof(struct Block_literal_1) // optional helper functions void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25) void (*dispose_helper)(void *src); // IFF (1&lt;&lt;25) // required ABI.2010.3.16 const char *signature; // IFF (1&lt;&lt;30) &#125; *descriptor; // imported variables&#125;; 了解 Block 的结构之后，再来看下它从定义到运行是如何实现的。以下面这段源码为例： 123456789101112131415// example// file: main.mint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int integer = 10; void (^block)(int) = ^(int a) &#123; NSLog(@&quot;block is called: %d&quot;,a); &#125;; block(integer); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 终端定位到 main.m 文件目录，利用 Clang 命令，把 main.m 文件转化为 main.cpp 文件，并摘要如下： 1clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// file： main.cpp#ifndef BLOCK_IMPL#define BLOCK_IMPLstruct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;//static __NSConstantStringImpl __NSConstantStringImpl__var_folders_tv_p2zj_t2s1jlb5sl6zrf6mlf40000gp_T_main_4d4c05_mi_0 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = &#123;__CFConstantStringClassReference,0x000007c8,&quot;block is called: %d&quot;,19&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself, int a) &#123; int var2 = 22; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_tv_p2zj_t2s1jlb5sl6zrf6mlf40000gp_T_main_4d4c05_mi_0,a+var2);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; int var1 = 11; void (*block)(int) = ((void (*)(int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *, int))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, var1); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;AppDelegate&quot;), sel_registerName(&quot;class&quot;)))); &#125;&#125; 可以看到，经过 Clang 转化为c++代码之后，原先5行的源码增加了很多，但我们仍然可以从转化后的代码中找到原始代码的“痕迹”，尽管在形式上已经变得大不相同。 123456struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; 结构体 __block_impl 清晰的表明了 Block 的结构，Block 也是OC对象，所以它包含 isa 指针；Reserved 作为保留字段；函数指针 FuncPtr 指向 Block 的实现。 12345678910111213141516struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; //构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 结构体 __main_block_impl_0 包含两个变量以及一个构造函数。变量 impl 是 __block_impl 类型；指针变量 Desc 指向 __main_block_desc_0 类型的结构体；构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) 第一个参数 fp 是函数指针，指向Block的函数实现。 除了上面提到的三种结构体类型，从转换后的源码中还可以看到一个静态函数 __main_block_func_0 以及一个静态结构体变量 __main_block_desc_0_DATA。静态函数 __main_block_func_0 承载了 Block 要执行的真正任务；静态结构体变量 __main_block_desc_0_DATA 被初始化时的参数分别是 0 和 结构体 __main_block_impl_0 所占存储空间大小。 了解了 Block 相关的数据结构之后，我们开始看 main 函数中 Block 代码是如何调用运行的。首先是 Block 的定义代码： 12int var1 = 11;void (*block)(int) = ((void (*)(int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); 去除类型转换，上面的代码等价于： 123int var1 = 11;struct __main_block_impl_0 temp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);struct __main_block_impl_0 *block = &amp;temp; 这样就容易理解了，即栈上生成的 __main_block_impl_0 类型结构体实例的指针，复制给 __main_block_impl_0 结构体指针变量 block。 然后是 Block 的调用代码： 1((void (*)(__block_impl *, int))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, var1); 去除类型转换，上面的代码等价于：1(*block -&gt;impl.FuncPtr)(*block, var1) 这就是简单的使用函数指针进行函数调用。 所以，我们只要把 __main_block_impl_0 中的 impl 变量的 FuncPtr 函数指针修改掉，就可以达到替换 Block 所执行的函数的目的。 Hook Block 怎样实现？上面得出结论，只要把 __main_block_impl_0 中的 impl 变量的 FuncPtr 函数指针修改掉，就可以达到替换 Block 所执行的函数的目的。那么怎么修改 Block 的函数指针呢？跟着下面这个问题来一起看下。 问题1：实现下面的函数,将Block的实现修改成打印 “Hello world.”123void HookBlockToPrintHelloWorld(id block) &#123; &#125; 实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940//file：main.mtypedef struct hook_Block_Desc &#123; size_t reserved; size_t Block_size;&#125; hook_Block_Desc;struct hook_Block_impl &#123; //自己定义一个 hook_Block_impl，因为系统的你调不到 void *isa; int Flags; int Reserved; void *funPtr; hook_Block_Desc *desc;&#125;;void fun(struct hook_Block_impl * impl, ...) &#123; printf(&quot;Hello world.\n&quot;);&#125;void printHellpWorld(id block) &#123; struct hook_Block_impl *blockImpl = (__bridge struct hook_Block_impl *)(block); blockImpl -&gt;funPtr = &amp;fun;&#125;;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int var1 = 11; void (^block)(int) = ^(int a) &#123; int var2 = 22; NSLog(@&quot;block is called: %d&quot;,a+var2); &#125;; printHellpWorld(block); block(var1); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 问题2: 实现下面的函数,将Block的实现修改成打印所有入参,并调用原始实现.123456void(^block)(int a, NSString *b) = ^(int a, NSString *b) &#123; NSLog(@&quot;block invoke&quot;);&#125;HookBlockToPrintArguments(block);block(123,@&quot;aaa&quot;);//这里输出&quot;123, aaa&quot; 和 &quot;block invoke&quot;; 实现如下： 基本思路是将原始 Block 的实现函数，替换成我们自定义的函数，然后将参数打印，最后回调原始 Block 的实现函数。简单实现方法如下（只针对固定的入参，不具备通用性）：123456789101112131415161718192021222324252627282930313233343536373839404142434445//file: main.mtypedef struct hook_Block_Desc &#123; size_t reserved; size_t Block_size;&#125; hook_Block_Desc;struct hook_Block_impl &#123; void *isa; int Flags; int Reserved; void *funPtr; hook_Block_Desc *desc;&#125;;//函数指针静态变量，保存 Block 的原始函数实现static void (* orig_func)(void *block, int a, NSString *b);void hookBlock(void *block, int a, NSString *b) &#123; NSLog(@&quot;%d, %@&quot;,a, b); orig_func(block, a, b);&#125;;void HookBlockToPrintArguments(id block) &#123; struct hook_Block_impl *blockImpl = (__bridge struct hook_Block_impl *)block; orig_func = blockImpl-&gt;funPtr; blockImpl-&gt;funPtr = &amp;hookBlock;&#125;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int a = 123; NSString *b = @&quot;abc&quot;; void (^block)(int, NSString *) = ^(int a, NSString *b) &#123; NSLog(@&quot;block invoke.&quot;); &#125;; HookBlockToPrintArguments(block); block(a, b); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 下面是通用实现方法，因为要接收不确定的参数类型和个数，所以需要循环判断参数类型然后赋值，而且需要深拷贝一份原始 Block 作为参数传递： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123struct hook_Block_impl;typedef struct hook_Block_Desc &#123; size_t reserved; size_t Block_size; void (*copy)(struct hook_Block_impl*, struct hook_Block_impl*); void (*dispose)(struct hook_Block_impl*);&#125; hook_Block_Desc;typedef struct hook_Block_impl &#123; void *isa; int Flags; int Reserved; void *funPtr; hook_Block_Desc *desc;&#125; hook_Block_impl;hook_Block_impl *orig_Block;void hookBlockArgs(hook_Block_impl *impl, ...) &#123; va_list arg_ptr; va_start(arg_ptr, impl); NSObject *tempBlock = CFBridgingRelease(orig_Block); const char *_Block_signature(void *); const char *hookBlockSignature = _Block_signature((__bridge void *)(tempBlock)); NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:hookBlockSignature]; NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:methodSignature]; [blockInvocation setArgument:&amp;tempBlock atIndex:0]; NSMutableArray *argumentTypeArr = [[NSMutableArray alloc] init]; for (NSInteger i = 1; i &lt; methodSignature.numberOfArguments; ++i) &#123; const char *ch = [methodSignature getArgumentTypeAtIndex:i]; NSString *arg = [NSString stringWithUTF8String:ch]; [argumentTypeArr addObject:arg]; &#125; NSInteger arg_count = 1; for (NSString *argType in argumentTypeArr) &#123; if ([argType isEqualToString:@&quot;i&quot;]) &#123; int arg = va_arg(arg_ptr, int); NSLog(@&quot;int param %d&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;I&quot;]) &#123; unsigned int arg = va_arg(arg_ptr, unsigned int); NSLog(@&quot;unsigned int param %d&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125;else if ([argType isEqualToString:@&quot;f&quot;]) &#123; double arg = va_arg(arg_ptr, double); NSLog(@&quot;float param %lf&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;d&quot;]) &#123; double arg = va_arg(arg_ptr, double); NSLog(@&quot;double param %lf&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;B&quot;]) &#123; int arg = va_arg(arg_ptr, int); NSLog(@&quot;BOOL param %d&quot;, arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;c&quot;]) &#123; char arg = va_arg(arg_ptr, int); NSLog(@&quot;char param %c&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;l&quot;]) &#123; long arg = va_arg(arg_ptr, long); NSLog(@&quot;long param %ld&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;L&quot;]) &#123; unsigned long arg = va_arg(arg_ptr, unsigned long); NSLog(@&quot;long param %lu&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;q&quot;]) &#123; long long arg = va_arg(arg_ptr, long long); NSLog(@&quot;long long param %lld&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;Q&quot;]) &#123; unsigned long long arg = va_arg(arg_ptr, unsigned long long); NSLog(@&quot;unsigned long long param %llu&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if ([argType isEqualToString:@&quot;*&quot;]) &#123; void *arg = va_arg(arg_ptr, void *); NSLog(@&quot;pointer param %p&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else if (argType.length &gt; 2) &#123; id arg = va_arg(arg_ptr, id); NSLog(@&quot;%@ %@&quot;,[arg class], arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; else &#123; //unknow 指针 void *arg = va_arg(arg_ptr, void *); NSLog(@&quot;%p&quot;,arg); [blockInvocation setArgument:&amp;arg atIndex:(arg_count)]; &#125; arg_count += 1; &#125; va_end(arg_ptr); [blockInvocation invokeWithTarget:tempBlock]; //&#125;;void HookBlockToPrintArguments(id block) &#123; struct hook_Block_impl *blockImpl = (__bridge struct hook_Block_impl *)block; //拷贝一份原始 Blcok 副本 orig_Block = malloc(blockImpl -&gt;desc -&gt;Block_size); memcpy(orig_Block, blockImpl, blockImpl -&gt;desc -&gt;Block_size); //将当前 Block 的函数指针指向我们自己定义的函数 blockImpl -&gt;funPtr = &amp;hookBlockArgs;&#125;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int a = 123; NSString *b = @&quot;abc&quot;; void (^block)(int, NSString *) = ^(int a, NSString *b) &#123; NSLog(@&quot;block invoke.&quot;); &#125;; HookBlockToPrintArguments(block); block(a, b); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 总结以上介绍了 Block 的数据结构以及 OC 语言是怎样实现 Block 定义与调用的。理解了 Block 的原理，就能够实现 Hook Block，并针对提出的两个问题，做出了解答。]]></content>
  </entry>
  <entry>
    <title><![CDATA[现代IM系统中的消息架构设计]]></title>
    <url>%2F2019%2F07%2F20%2F%E7%8E%B0%E4%BB%A3IM%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[IM全称是『Instant Messaging』，中文名是即时通讯。在移动互联网时代，IM产品已经成为工作和生活中必不可少的工具，比如QQ，微信，钉钉等。还有一些非以IM系统为核心的应用，最典型的如一些在线游戏、社交应用，IM也是其重要的功能模块。可以说，IM系统已经是任何一个带有社交属性的应用需要具备的基础功能，网络上对于这类系统的设计与实现的讨论也越来越多。 前言IM系统在互联网初期即存在，其基础技术架构在这十几年的发展中更新迭代多次，从早期的CS、P2P架构，到现在后台已经演变为一个复杂的分布式系统，涉及移动端、网络通信、协议、安全、存储和搜索等技术的方方面面。IM系统中最核心的部分是消息系统，消息系统中最核心的功能是消息的同步、存储和检索： 消息的同步：将消息完整的、快速的从发送方传递到接收方，就是消息的同步。消息同步系统最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。从功能上来说，一般至少要支持在线和离线推送，高级的IM系统还支持『多端同步』。 消息的存储：消息存储即消息的持久化保存，传统消息系统通常只能支持消息在接收端的本地存储，数据基本不具备可靠性。现代消息系统能支持消息在服务端的在线存储，功能上对应的就是『消息漫游』，消息漫游的好处是可以实现账号在任意端登陆查看所有历史消息。 消息的检索：消息一般是文本，所以支持全文检索也是必备的能力之一。传统消息系统通常来说也是只能支持消息的本地检索，基于本地存储的消息数据来构建。而现在消息系统在能支持消息的在线存储后，也具备了消息的『在线检索』能力。 本文主要涉及IM系统中的消息系统架构，会介绍一种基于阿里云 Timeline 模型构建的消息系统。基于 Timeline 构建的现代消息系统，能够同时支持消息系统的众多高级特性，包括『多端同步』、『消息漫游』和『在线检索』。在性能和规模上，能够做到全量消息云端存储和索引，百万TPS写入以及毫秒级延迟的消息同步和检索能力。 传统架构下，消息是先同步后存储。对于在线的用户，消息会直接实时同步到在线的接收方，消息同步成功后，并不会在服务端持久化。而对于离线的用户或者消息无法实时同步成功时，消息会持久化到离线库，当接收方重新连接后，会从离线库拉取所有未读消息。当离线库中的消息成功同步到接收方后，消息会从离线库中删除。传统的消息系统，服务端的主要工作是维护发送方和接收方的连接状态，并提供在线消息同步和离线消息缓存的能力，保证消息一定能够从发送方传递到接收方。服务端不会对消息进行持久化，所以也无法支持消息漫游。消息的持久化存储及索引同样只能在接收端本地实现，数据可靠性极低。 现代架构下，消息是先存储后同步。先存储后同步的好处是，如果接收方确认接收到了消息，那这条消息一定是已经在云端保存了。并且消息会有两个库来保存，一个是消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游。另一个是消息同步库，主要用于「接收方」的多端同步。消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，后保存到消息同步库。完成以上两步消息持久化保存后，对于在线的接收方，会直接选择在线推送（在线推送并不是一个必须路径，只是一个更优的消息传递路径）。对于在线推送失败或者离线的接收方，会有另外一个统一的消息同步方式。接收方会主动的向服务端拉取所有未同步消息，但接收方何时来同步以及会在哪些端来同步消息对服务端来说是未知的，所以要求服务端必须保存所有需要同步到接收方的消息，这是消息同步库的主要作用。对于新的设备，会有消息漫游的需求，这是消息存储库的主要作用，在消息存储库中，可以拉取任意会话的全量历史消息。消息检索的实现依赖于对「消息存储库」内消息的索引，通常是一个近实时（NRT，near real time）的索引构建过程，这个索引同样是在线的。 以上就是传统架构和现代架构的一个简单的对比，现代架构上整个消息的同步、存储和索引流程，并没有变复杂太多。现代架构的实现本质上是把传统架构内本地存储和索引都搬到云上，最大挑战是需要集中管理全量消息的存储和索引，带来的好处是能实现多端同步、消息漫游以及在线检索。可以看到现代架构中最核心的就是两个消息库:『消息同步库』和『消息存储库』，以及对『消息存储库』的『消息索引』的实现，接下来我们逐步拆解这几个核心的设计和实现。 Timeline 模型在深入讲解消息系统的设计和实现之前，需要对消息系统内的几个基本概念和基础模型有一个理解。网上分析的很多的不同类型的消息系统实现，实现差异上主要在消息同步和存储的方案上，在消息的数据模型上其实有很大的共性。围绕数据同步模型的讨论主要在『读扩散』、『写扩散』和『混合模式』这三种方案，目前还没有更多的选择。而对于数据模型的抽象，还没有一个标准的定义。 Timeline模型，是一个对消息系统内消息模型的一个抽象，能简化和更好的让开发者理解消息系统内的消息同步和存储模型，而消息同步库和消息存储库的设计和实现也是围绕 Timeline 的特性和需求来展开。 如图是Timeline模型的一个抽象表述，Timeline 可以简单理解为是一个消息队列，但这个消息队列有如下特性： 每条消息对应一个顺序ID：每个消息拥有一个唯一的顺序ID（称为顺序ID，是因为队列中的消息会按照这个ID的顺序进行排序） 新消息写入能自动分配递增的顺序ID，保证永远插入队尾：Timeline 中是根据同步位点也就是顺序ID来同步消息，所以需要保证新写入的消息数据的顺序ID绝对不能比已同步的消息的顺序ID还小，否则会导致数据漏同步，所以需要支持对新写入的数据自动分配比当前已存储的所有消息的顺序ID更大的顺序ID。 新消息写入也能自定义顺序ID，满足自定义排序需求：上面提到的自动分配顺序ID，主要是为了满足消息同步的需求，消息同步要求消息是根据『已同步』或是『已写入』的顺序来排序。而消息的存储，通常要求消息能根据会话顺序来排序，会话顺序通常由端的会话时间戳来决定，而不是服务端的同步顺序来定，这是两种顺序要求。 支持根据顺序ID的随机定位：可根据顺序ID随机定位到 Timeline 中的某个位置，从这个位置开始正序或逆序的读取消息，也可支持读取指定顺序ID的某条消息。 支持对消息的自定义索引：消息体内数据根据业务不同会包含不同的字段，Timeline 需要支持对不同字段的自定义索引，来支持对消息内容的全文索引，或者是任意字段的灵活条件组合查询。 消息同步可以基于 Timeline 很简单的实现，上图中的例子中，消息发送方是A，消息接收方是B，同时B存在多个接收端，分别是B1、B2和B3。A向B发送消息，消息需要同步到B的多个端，待同步的消息通过一个 Timeline 来进行交换。A向B发送的所有消息，都会保存在这个 Timeline 中，B的每个接收端都是独立的从这个 Timeline 中拉取消息。每个接收端同步完毕后，都会在本地记录下最新同步到的消息的顺序ID（同步key），即最新的一个位点，作为下次消息同步的起始位点。服务端不会保存各个端的同步状态，各个端均可以在任意时间从任意点开始拉取消息。 消息存储也是基于 Timeline 实现，和消息同步唯一的区别是，消息存储要求服务端能够对 Timeline 内的所有数据进行持久化，并且消息采用会话顺序来保存(顺序ID为会话时间戳)。 消息检索基于 Timeline 提供的消息索引来实现，能支持比较灵活的多字段索引，根据业务的不同可有自由度较高的定制。 消息存储模型 如图是基于Timeline的消息存储模型，消息存储要求每个会话都对应一个独立的Timeline。如图例子所示，A与B/C/D/E/F均发生了会话，每个会话对应一个独立的Timeline，每个Timeline内存有这个会话中的所有消息，消息根据会话顺序排序，服务端会对每个Timeline进行持久化存储，也就拥有了消息漫游的能力。 消息同步模型消息同步模型会比消息存储模型稍复杂一些，消息的同步一般有读扩散（也叫拉模式）和写扩散（也叫推模式）两种不同的方式，分别对应不同的 Timeline 物理模型。 如图是读扩散和写扩散两种不同同步模式下对应的不同的 Timeline 模型，按图中的示例，A作为消息接收者，其与B/C/D/E/F发生了会话，每个会话中的新的消息都需要同步到A的某个端，看下读扩散和写扩散两种模式下消息如何做同步。 读扩散：「消息存储模型」中，每个会话的 Timeline 中保存了这个会话的全量消息。读扩散的消息同步模式下，每个会话中产生的新的消息，只需要写一次到消息存储的 Timeline 中，接收端从这个 Timeline 中拉取新的消息。优点是消息只需要写一次，相比写扩散的模式，能够大大降低消息写入次数，特别是在群消息这种场景下。但其缺点也比较明显，接收端去同步消息的逻辑会相对复杂和低效。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。 写扩散：写扩散的消息同步模式，需要有一个额外的 Timeline 来专门用于消息同步，通常是每个接收端都会拥有一个独立的同步 Timeline（或者叫收件箱），用于存放需要向这个接收端同步的所有消息。每个会话中的消息，会产生多次写，除了写入用于消息存储的会话Timeline，还需要写入需要同步到的接收端的同步 Timeline。在个人与个人的会话中，消息会被额外写两次，除了写入这个会话的存储 Timeline，还需要写入参与这个会话的两个接收者的同步 Timeline。而在群这个场景下，写入会被更加的放大，如果这个群拥有N个参与者，那每条消息都需要额外的写N次。写扩散同步模式的优点是，在接收端消息同步逻辑会非常简单，只需要从其消息同步 Timeline 中读取一次即可，大大降低了消息同步所需的读的压力。其缺点就是消息写入会被放大，特别是针对群这种场景。Timeline模型不会对选择读扩散还是写扩散做约束，而是能同时支持两种模式，因为本质上两种模式的逻辑数据模型并无差别，只是消息数据是用一个 Timeline 来支持多端读还是复制到多个 Timeline 来支持多端读的问题。 针对IM这种应用场景，消息系统通常会选择写扩散这种消息同步模式。IM场景下，一条消息只会产生一次，但是会被读取多次，是典型的读多写少的场景，消息的读写比例大概是10:1。若使用读扩散同步模式，整个系统的读写比例会被放大到100:1。一个优化的好的系统，必须从设计上去平衡这种读写压力，避免读或写任意一维触碰到天花板。所以IM系统这类场景下，通常会应用写扩散这种同步模式，来平衡读和写，将100:1的读写比例平衡到30:30。当然写扩散这种同步模式，还需要处理一些极端场景，例如万人大群。针对这种极端写扩散的场景，会退化到使用读扩散。一个简单的IM系统，通常会在产品层面限制这种大群的存在，而对于一个高级的IM系统，会采用读写扩散混合的同步模式，来满足这类产品的需求。采用混合模式，会根据数据的不同类型和不同的读写负载，来决定用写扩散还是读扩散。 典型架构设计 如图是一个典型的消息系统架构，架构中包含几个重要组件： 端：作为消息的发送和接收端，通过连接消息服务器来发送和接收消息。消息服务器：一组无状态的服务器，可水平扩展，处理消息的发送和接收请求，连接后端消息系统。 消息队列：新写入消息的缓冲队列，消息系统的前置消息存储，用于削峰填谷以及异步消费。 消息处理：一组无状态的消费处理服务器，用于异步消费消息队列中的消息数据，处理消息的持久化和写扩散同步。 消息存储和索引库：持久化存储消息，每个会话对应一个Timeline进行消息存储，存储的消息建立索引来实现消息检索。 消息同步库：写扩散形式同步消息，每个用户的收件箱对应一个Timeline，同步库内消息不需要永久保存，通常对消息设定一个生命周期。新消息会由端发出，通常消息体中会携带消息ID（用于去重）、逻辑时间戳（用于排序）、消息类型（控制消息、图片消息或者文本消息等）、消息体等内容。消息会先写入消息队列，作为底层存储的一个临时缓冲区。消息队列中的消息会由消息处理服务器消费，可以允许乱序消费。消息处理服务器对消息先存储后同步，先写入发件箱Timeline（存储库），后写扩散至各个接收端的收件箱（同步库）。消息数据写入存储库后，会被近实时的构建索引，索引包括文本消息的全文索引以及多字段索引（发送方、消息类型等）。 对于在线的设备，可以由消息服务器主动推送至在线设备端。对于离线设备，登录后会主动向服务端同步消息。每个设备会在本地保留有最新一条消息的顺序ID（同步key），向服务端同步该顺序ID后的所有消息。 总结本篇文章主要介绍了现代IM系统中消息系统所需要具备的能力，对比了传统架构和现代架构。介绍了 Timeline 模型，以及在IM系统中消息存储和消息同步模型的基本概念和策略，最后介绍了一个典型的架构设计。]]></content>
      <categories>
        <category>IM</category>
      </categories>
      <tags>
        <tag>IM</tag>
        <tag>即时通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C autorelease]]></title>
    <url>%2F2019%2F07%2F08%2Fautorelease%2F</url>
    <content type="text"><![CDATA[Objective-C 内存管理中的一个重要概念是 autorelease，自动释放。它类似于C语言中的自动变量的特性。回忆一下C语言中的自动变量：程序执行时，若某个自动变量超出其作用域，该自动变量将被自动废弃，不可再访问。autorelease 会像C语言的自动变量那样来对待对象实例，当超出变量作用域时，对象实例的 release 方法被调用。 autorelease 的具体使用方法如下： 生成并持有 NSAutoreleasePool 对象 调用对象实例的 autorelease 方法 废弃 NSAutoreleasePool 对象 NSAutoreleasePool 对象的生命周期相当于C语言变量的作用域。在废弃 NSAutoreleasePool 对象时，所有调用过 autorelease 的实例对象都将调用 release 方法。如下图所示： 使用代码表示如下：1234567//非ARC下NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];....[pool drain]; 最后一行的 [pool drain]等同于 [obj release]。 NSAutoreleasePool 是与线程紧密相关的，每个线程都会维护一个自己的 NSAutoreleasePool 栈。在主线程 NSRunLoop 的每个 Loop 开始前，系统会自动创建一个 NSAutoreleasePool 对象 ，并在这个 Loop 结束时 drain 。所以在通常情况下，开发者不需要非得自己使用 NSAutoreleasePool 来进行开发工作。 自动释放池提供了一种机制，通过这种机制，你可以放弃对象的所有权，但又能避免对象被立即释放的可能性。通常你不需要创建自己的 autorelease pool ，但是某些场景下你必须这么做。 About Autorelease Pool Blocks在 ARC 下，autorelease pool 使用关键字 @autoreleasepool 标记123@autoreleasepool &#123; // Code that creates autoreleased objects.&#125; 像其他代码一样，autorelease pool 也是可以嵌套的：1234567@autoreleasepool &#123; // . . . @autoreleasepool &#123; // . . . &#125; . . .&#125; Cocoa 总是希望代码能够在 autorelease pool 中执行，否则 autorelease 对象将不会被释放，应用程序内存泄露。如果你在 autorelease pool block 之外向对象发送 autorelease 消息，Cocoa 会打印一条错误信息。AppKit 与 UIKit 框架会在 autorelease pool 中处理每个 event-loop 循环(比如鼠标按下事件或者一次点击)，因此你通常不需要自己创建一个 autorelease pool，甚至很难见到这样的代码。然而，以下三种情况需要创建你自己的 autorelease pool： 你写的程序不是基于 UI framework 的，比如命令行工具 在一个循环中，你创建了大量临时对象. 你可以在循环内使用 autorelease pool 在下一次迭代之前处理这些对象，在循环中使用 autorelease pool 有助于减少应用程序的最大内存占用量 Cocoa应用中的每个线程都维护自己的自动释放池堆栈。 如果您正在编写仅基于 Foundation 的程序或者分离线程，则需要创建自己的autorelease pool 使用 autorelease pool 来减少峰值内存占用量许多应用创建的临时对象都是 autorelease 的，这些对象会持续添加到应用内存中，直到代码块结束。在大多数情况下，允许临时对象累积直到当前事件循环迭代结束不会导致过多的内存开销。 但是在少数情况下，你可能会创建大量临时对象，这些对象会大大增加内存占用，所以你希望快速的处理这些对象。此时你需要创建自己的 autorelease pool 。下面示例怎样在一个 for 循环中使用 autorelease pool12345678910NSArray *urls = &lt;# An array of file URLs #&gt;;for (NSURL *url in urls) &#123; @autoreleasepool &#123; NSError *error; NSString *fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; /* Process the string, creating and autoreleasing more objects. */ &#125;&#125; 上述 for 循环每次处理一个文件，在 autorelease pool block 中的任何对象(比如 fileContents)会发送一个 autorelease 消息，在代码块结束时对象被 release。 在 autorelease pool block 结尾之后，应当认为上面所有的 autorelease 对象都已被处理。不要再向该对象发送消息或将其返回给方法调用者。如果你必须在 autorelease pool block 之外使用临时对象，可以在代码块内发送 retain 消息，然后在代码块结束之后向该对象发送 autorelease 消息，示例如下：1234567891011121314151617– (id)findMatchingObject:(id)anObject &#123; id match; while (match == nil) &#123; @autoreleasepool &#123; /* Do a search that creates a lot of temporary objects. */ match = [self expensiveSearchForObject:anObject]; if (match != nil) &#123; [match retain]; /* Keep match around. */ &#125; &#125; &#125; return [match autorelease]; /* Let match go and return it. */&#125; 其他涉及到 autoreleasepool 的地方以下是创建非自己生成、非自己持有的对象时，调用的类方法的源码示例： 1234+ (id)array&#123; return [[NSMutableArray alloc] init];&#125; 上述代码可以写成如下形式： 1234567891011+ (id)array&#123; /* * 自己生成并自己持有对象 */ id obj = [[NSMutableArray alloc] init]; return obj; /* * 变量 obj 超出其作用域，编译器将它自动注册到 autoreleasepool */&#125; 没有显式制定所有权修饰符，所以 obj 默认是 __strong 的。由于 return 使得 obj 对象超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但是，该对象作为函数的返回值，编译器会自动将其注册到 autoreleasepool 。这也就是为什么 [NSMutableArray array] 会生成非自己生成、非自己持有的对象。 我们知道， weak 修饰符是为了避免循环引用而使用的，但是在访问附有 weak 修饰符的变量时，实际上必定要访问注册到 autoreleasepool 中的对象。比如有如下源码： 123id obj0 = [[NSArray alloc] init];id __weak obj1 = obj0;NSLog(@&quot;class=%@&quot;, [obj1 class]); 上述代码等价于： 1234id obj0 = [[NSArray alloc] init];id __weak obj1 = obj0;id __autoreleasing tmp = obj1;NSLog(@&quot;class=%@&quot;, [tmp class]); 为什么在访问附有 weak 修饰符的变量时必须访问注册到 autoreleasepool 的对象呢？这是因为， weak 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C和swift混编]]></title>
    <url>%2F2019%2F01%2F31%2FObjective-C%E5%92%8Cswift%E6%B7%B7%E7%BC%96%2F</url>
    <content type="text"><![CDATA[最近对一个现有项目进行重构，感觉swift出来这么久了，还没用它进行实际项目的编写，所以打算利用这次机会重新熟悉下swift。由于项目依赖的私有库或者开源库大都是由Objective-C写的，当我创建一个swift项目后，首先考虑的是怎么在swfit项目中调用Objective-C接口(项目使用cocoapods管理)。 在swift项目中调用OC接口，只需要创建一个桥接文件，文件名为：ProjiectName-Bridging-Header.h 。有两种方式可以创建该桥接文件： 在swift项目中，新建一个OC类，此时会自动弹出一个提示框，提示是否创建Objective-C桥接文件，点击创建即可。 手动创建该桥接文件，创建完之后还需要配置桥接文件路径：TARGETS -&gt; Build Setting -&gt; Swift Compiler-General -&gt; Objective-C Bridging Header，这里设置相对路径就好，比如 ProjiectName/ProjiectName-Bridging-Header.h 创建桥接文件之后，在该文件内import你需要的OC头文件。 如果发现还是调用不了OC接口，或者识别不了桥接文件中的OC头文件，你还需要进行下面的配置： TARGETS-&gt; Build Phases -&gt; Link Binary With Libraries 进入到这里，点击+号，把我们需要的第三方库添加进去；然后到 TARGETS-&gt; Build Setting -&gt; User Header Search Paths， 设置为 recursive。 这样就OK了。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Objective-C：方法调用]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Objective-C%EF%BC%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们知道，Objective-C 是一门面向对象的动态语言，是C语言的超集。而 OC 之所以具有这些特性，本质上在于 Runtime 库。Runtime 由C语言和汇编语言编写，是 OC 语言的“基石”，它定义了 OC 语言的基础数据结构；类与对象的相关操作函数；方法调用、消息机制；Protocol 和 Category 等。理解 Objective-C 的 Runtime 可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。本文从 Runtime 层研究 OC 语言的方法调用、消息机制。 先看下与 runtime 密切相关的几个数据类型: Class, SEL, IMP, Method，他们都定义在 objc/objc.h 文件中。 Class, Method, SEL, IMP12345678910111213141516171819202122232425262728293031/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// A pointer to an instance of a class.typedef struct objc_object *id;typedef struct objc_object &#123; Class isa; &#125; *id;/*可以看到,iOS 中的 id 类型实际上就是指向 objc_object 结构体的指针， objc_object 持有一个 Class 类型的 isa 变量。 NSObject 的定义 @interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY; &#125; NSObject 同样也持有一个 Class 类型的 isa 变量，但是额外遵循 NSObject 协议。 因此 id 可以泛指所有 NSObject 以及继承自 NSObject 的对象， 但是 NSObject * 指针却不能指向 id 类型。*/typedef struct objc_selector *SEL; #if !OBJC_OLD_DISPATCH_PROTOTYPES typedef void (*IMP)(void /* id, SEL, ... */ ); #else typedef id (*IMP)(id, SEL, ...); #endif 1. ClassClass 被定义为一个指向 objc_class 的结构体指针。objc_class 在 objc/objc_class.h 中定义如下: 1234567891011121314151617struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 我们发现，Class 本身也有一个 isa 指针，指向的是它的 MetaClass。下面这张图说明了 OC 对象体系 isa 以及 super_class 指针的指向： 2. SELSEL 的定义如下： 1typedef struct objc_selector *SEL; 在源码中没有直接找到 objc_selector 的定义，从一些书籍上与 Blog 上看到可以将 SEL 理解为一个 char* 指针：1234struct objc_selector &#123; char *name; OBJC2_UNAVAILABLE; char *types; OBJC2_UNAVAILABLE;&#125;; 3. IMPIMP 定义如下： 1typedef id (*IMP)(id, SEL, ...); IMP 可以理解为函数指针，指向了函数的实现代码。这个被指向的函数的参数包含一个接收消息的 id 对象、 SEL、以及不定个数的参数，并返回一个 id 类型的对象，我们可以像在Ｃ语言里面一样使用这个函数指针。 SEL 与 IMP 的关系非常类似于 HashTable 中 key 与 value 的关系。OC 中不支持函数重载的原因就是因为一个类的方法列表中不能存在两个相同的 SEL 。但是不同的类中可以拥有相同的 SEL，不同类的实例对象执行相同的 SEL 时，会在各自的方法列表中去根据 SEL 去寻找自己对应的IMP。这使得OC可以支持函数重写。 4. MethodMethod 的定义如下： 12345678/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; Method = SEL + IMP + method_types，相当于在SEL和IMP之间建立了一个映射。 方法调用我们都知道，在 Objective-C 里调用一个方法是这样的： 1[obj method]; 表示我们要调用对象 obj 的方法 method。Runtime 层会将这个调用翻译成objc_msgSend(self, _cmd)，其函数原型为： 1id objc_msgSend(id self, SEL op, ...); 也就是说，对象的方法调用，在 runtime 层表达为向该对象发送消息，消息机制也是OC动态特性的本质，类似于 Ruby。而 objc_msgSend具体又是如何分发的呢?通过阅读它的源码文件objc-msg-arm64.s ，可以看到，objc_msgSend 的消息分发有以下几个步骤：: 苹果开源的项目中共有 6 种对不同平台的汇编实现，本节选取其在 arm64 下的源码文件 判断 receiver（objc_msgSend的第一个参数self） 是否为 nil。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉 从 cache 中查找 SEL 对应的 IMP，若找到，则执行，否则 从对象的方法链表中根据 SEL 去查找 IMP，找到后加入到缓存。查找过程如下： 如果支持GC，忽略掉非GC环境的方法（retain等） 从对象的 Class 的 method_list 寻找 selector，如果找到，填充到缓存中，并返回 selector，否则 从对象的超类的 method_list 寻找，并依次往上寻找，直到找到 selector，填充到缓存中，并返回 selector，否则 调用 _class_resolveMethod，动态方法决议，若找到 selector 对应的方法实现 IMP，不缓存，方法返回，否则 转发这个 selector，否则 报错，抛出异常 以上便是方法调用的整个过程，下面重点说下动态方法决议以及消息转发。 动态方法决议当无法从对象(类对象或实例对象)以及对象父类的 cache 和 method_list 中找到 selector 对应的 IMP 时，就会进入动态方法决议阶段，在这个阶段，如果能够提供 seltctor 的方法实现，并反回YES，则成功处理该消息，本次方法调用结束，不会再进行后续的消息转发。 12345678910111213141516//Dynamically provides an implementation for a given selector for an instance method.+ (BOOL)resolveInstanceMethod:(SEL)sel;or//Dynamically provides an implementation for a given selector for a class method.+ (BOOL)resolveClassMethod:(SEL)sel;return value：YES if the method was found and added to the receiver, otherwise NO.返回 YES 表示不进行后续的消息转发，返回 NO 则表示要进行后续的消息转发。如果在该函数内为指定的 selector 提供实现，无论返回 YES 还是 NO，编译运行都是正确的；但如果在该函数内并不真正为 selector 提供实现，无论返回 YES 还是 NO，运行都会 crash resolveInstanceMethod: 以及 resolveClassMethod:允许你动态提供给定 selector 的 IMP 实现。 简单的说，Objective-C 方法(method)就是至少带有两个参数：self、_cmd 的 C 函数。使用 class_addMethod 函数可以将 C 函数添加到某个类中作为该类的一个方法。 比如有下面这样一个C函数：1234void dynamicMethodIMP(id self, SEL _cmd, NSString *str)&#123; // implementation ....&#125; 可以使用 resolveInstanceMethod: 动态的将这个函数添加到类中作为该类的一个方法（假设方法名为：resolveThisMethodDynamically）： 123456789+ (BOOL) resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:@&quot;); return YES; &#125; return [super resolveInstanceMethod:aSel];&#125; 其中 class_addMethod 的函数原型如下：1BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); 刚开始让我不太明白的是最后一个参数 types ，查阅资料后得知其是一个定义该函数返回值类型和参数类型的字符串。本例中 types 为 &quot;v@:@&quot;，按照顺序表示如下：1234v : 返回值为 void@ ： 参数id(self): : SEL(_cmd)对象@ ： 参数id(str) 也就是说，types 描述了一个函数的返回值类型以及参数类型。: 表示 SEL 类型，@ 表示 OC 对象类型。其他类型见下表： 字符 表示的意义 c char 类型 i int 类型 s short 类型 l long 类型 q long long 类型 C unsigned char 类型 I unsigned int 类型 S unsigned short 类型 L unsigned long 类型 Q unsigned long long 类型 f float 类型 d double 类型 B C++ bool or C99 _Bool 类型 v void 类型 * character string （char *） 类型  特别注意：resolveInstanceMethod: and resolveClassMethod: is called before the Objective-C forwarding mechanism is invoked. If respondsToSelector: or instancesRespondToSelector: is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the given selector first. 消息转发如果动态方法决议不能处理当前消息（返回 NO），那么就会走到消息转发阶段。 123456789//Returns the object to which unrecognized messages should first be directed.- (id)forwardingTargetForSelector:(SEL)aSelector;Parameters：aSelectorA Selector for a method that the receiver does not implement.Return Value：The object to which unrecognized messages should first be directed. 如果你在一个类实现了该方法，并返回一个非空对象（非 self），那么返回的对象作为新的消息接收对象，这条消息会重新发送给该对象。很显然，如果你在上述方法中返回 self ，代码会进入死循环。 如果你在一个类（非基类）中实现了该方法，并且对于给定的 selector 没有给出返回对象，那么你应该返回超类的方法调用结果:return [super forwardingTargetForSelector:aSelector]。 这个方法给对象一次重定向(redirect)未知消息的机会，这先于代价更高的 forwardInvocation: 。当你想简单的把消息重定向到另一个对象时，使用这个方法会非常有用，而且效率会比通常的消息转发 forwardInvocation 快一个数量级。 如果上面的一波操作还是没能处理该消息，就会进入下面的步骤。 12345//Overridden by subclasses to forward messages to other objects. -(void)forwardInvocation:(NSInvocation *)invocationParameters:anInvocation : The invocation to forward. 如果一个对象（receiver）收到一个自己不能处理的消息（找不到对应的方法），runtime 会给这个对象一次机会将该消息委托给另外一个/多个接收者(another receivers)去处理。首先 runtime 会创建一个 NSInvocation 对象(它包含这个消息的完整信息)，并向 receiver 发送 forwardInvocation: 消息，参数为刚才创建的 NSInvocation 对象。receiver 对象的 forwardInvocation: 方法就可以将这个消息转发给 another receivers (如果这个对象还是不能响应该消息，它仍有机会去转发)。 forwardInvocation: 让一个对象（receiver）和另外的对象（another receivers）建立起联系，另外的对象会代其行事。所以，在某种意义上，进行转发的对象(receiver)便“继承”了将消息转发到的对象（another receivers）的某些特性。 注意： 刚才提到，当对象（receiver）不能处理某个消息（aSelector）时，runtime 在发送 forwardInvocation: 消息给这个对象(receiver)之前，会创建一个 NSInvocation 对象用于转发传参。但是创建 NSInvocation 对象需要的信息要从 methodSignatureForSelector: 中获取。所以除了 forwardInvocation: 之外，你还必须额外重写 methodSignatureForSelector: 方法来获取该 SEL 的方法签名。 实现 forwardInvocation: 方法需要做两件事： 找到一个能够响应封装在 anInvocation 中的消息的对象 使用 anInvocation 将消息发送给上一步的对象，anInvocation 会保留消息处理结果，runtime 获取这个结果并发送给原始的消息接收者 举个简单的例子：一个对象仅仅将消息转发给另外一个对象（假设为 friend 实例对象），forwardInvocation: 方法的实现如下： 12345678910111213141516171819-(NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:selector]; if (! signature) &#123; //生成方法签名 signature = [friend methodSignatureForSelector:selector]; &#125; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)invocation&#123; SEL aSelector = [invocation selector]; if ([friend respondsToSelector:aSelector]) [invocation invokeWithTarget:friend]; else [super forwardInvocation:invocation];&#125; 被转发的消息必须有固定个数的参数，可变个数的参数（比如 printf()）是不支持的。 被转发的消息的返回值，会被返回得到原始消息接收者，也就是 forwardInvocation: 消息的原始发送者，所有类型的返回值都支持，比如id类型，结构体，double等。 NSObject 类对 forwardInvocation： 方法的实现是：简单的调用 doesNotRecognizeSelector: 方法，它不转发任何消息。因此，如果你没有实现 forwardInvocation：，并且给对象发送了一个不能识别的消息，就会发生异常。 动态方法决议和消息转发流程可总结为下面这张图： self 与 super 的含义在进行方法调用时，我们通常这样写（假设当前类和其超类都有 method 实例方法）: 12345[self method]or[super method] 按照我最初模糊的理解，self 代表当前接收这个消息的对象，super 代表超类。但是仔细想下，这样理解是有问题的，如果 super 代表超类，那 super method 就表示调用了超类的类方法 method，但是这个方法明明是实例方法呀。而且 super 更不可能代表超类的实例对象，因为你都没创建。带着疑惑，我决定仔细研究下。 根据官方文档的解释： self 代表当前接收这个消息的对象 向 super 发送一个消息，表示去当前对象的超类中调用某个方法。 所以说，self 代表的是一个真实的对象；super 仅表示“去当前对象的超类中调用某个方法”，它是编译器的一个符号，不是对象。 理解了他们的含义，那么在向 self 和 super 发送消息时，在 runtime 层是怎样区别的？ 向 self 发送消息，runtime 会调用下面这个函数:1id objc_msgSend(id self, SEL op, ...); 向 super 发送消息时，runtime 会调用下面的函数：1id objc_msgSendSuper(struct objc_super *super, SEL op, ...); 结构体 objc_super 的定义如下：1234struct objc_super &#123;id receiver;Class superClass;&#125;; 所以，向 super 发送消息时，消息的接收者，依然是当前对象 self。只不过是从超类的 method_list 中查找方法实现。 到这里，应该就理解下面这个问题的答案了：12345678910@implementation Dog : Animal- (id)init &#123; self = [super init]; if (self) &#123; NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); &#125; return self;&#125;@end 会分别打印出来什么？ 肯定都是打印 Dog 。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git:纯函数式数据结构]]></title>
    <url>%2F2018%2F10%2F12%2FGit-%E7%BA%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[看到一篇有趣的文章《Git is a purely functional data structure》，作者：Philip Nilsson。它从函数式数据结构的角度讲解了Git的原理，把 Git 的 commit，branch 等操作和数据的不变性做了类比。本文将这篇文章搬过来，做个记录。 不变性函数式数据层结构本质上是不可变的数据结构，也就是具有不变性（immutable），它的值不会发生变化。然而函数式数据结构又支持比如插入、删除等操作，这些操作会创建一个全新的更新过的数据结构，而原始数据保持不变。 比如有个list 是 [3,2,1]，如果它是可变的，那我们就可以向头部插入一个元素4, 从而让这个列表变成 [4,3,2,1]。之前的 list 对我们来说丢失了，我们只能看到新的列表。在函数式编程中，这是不应该发生的，当我们插入一个元素4的时候， 并不会修改老的列表，相反，我们会创建一个全新的列表：[4,3,2,1]， 老的列表 [3,2,1] 依然存在。 那这种“不变性”有什么好处呢？很重要的一点就是线程安全，一个线程对数据的修改不会影响到另外一个线程，这样就不需要加锁的操作了。但是每次添加/删除一个元素就要创建一个新的列表出来，这样做是很低效和浪费内存的。那就做点优化，对原列表进行复用，比如： 老的列表和新的列表复用了内存中的元素，但是从外界的使用者看来，这是两个不同的列表。此时，如果线程再次在老列表 [3,2,1] 之前插入新的元素 9 ，怎么处理？ 同样，还是可以复用： 如果我想把 new list 1 中的元素 3 更新成元素 5， 这就有点难办了，因为它会影响到两个新的列表，new list 1 和 new list 2。 没办法，只有把元素 copy 一下了： 经过以上若干次操作，形成了四个列表： 老的列表： [3,2,1] new list 1: [4,3,2,1] new list 2: [9,3,2,1] new list 3: [4,5,2,1] 这四个列表对外界而言是完全独立的，只不过内部的数据是复用的。 Git 与 不变性函数式结构的不变性和 Git 有什么关系？对比下函数式数据结构不变性和版本控制： 版本控制的目的： 用新版本的文件来更老版本文件，老版本文件还要保留。 大家在同一个仓库中同时操作的时候，需要互不干涉。 不可变的数据结构能让我们： 保持老的数据结构不变的情况下，更新数据结构 一个线程对数据结构的更改不会影响另外一个线程 两者是不是很像？所以可以确切的说，Git 是一个纯函数式的数据结构，允许你在命令行使用命令进行各种”不变性”操作。 为了更好的进行类比，需要将上面例子中的数字换成 commit。Git 中的一个 commit 是对某个历史时间点完整的工作状态的一次拷贝；是你当前工作路径的一个完整“快照”。 比如一个仓库的 master 分支按时间先后顺序有 A、B、C 三次 commit，所以 Git 对我们工作路径下的全部状态进行存储了三次。看下图： Git commit如果我们再执行一次 commit，就变成下图这样： Git 将master指针指向 [D,C,B,A]，老的 history 指针（即 master^）还在，仍然指向 [C,B,A]。我的这次提交不会影响其他人，因为老的 mater^ 依然不变。 Git amend如果你用过Git的话，你也许知道可以使用 commit –amend 来更新最近一次的 Commit (图 D), 但是你真的把那个 Commit (图 D) 给更新了吗？ 实际上并没有，Git只是创建了一个新的 Commit（下图中的E），并且让 master 指针指向 E 而已。 通过git reflog 命令，你依然能看到修改前的那个 Commit （图 D）（假设它的hash value 是 33b90b7）。 Git branch正如你在上面看到的，每次你使用 commit –amend ， 你实际上创建了一个新的分支！分支实际上就是给一个我们想引用的 commit 起了个名字而已。我们甚至可以使用那个“被替换掉的”，“废弃的” Commit (33b90b7)来创建一个分支，比如起个名字叫 “dev”： 1git checkout -b mybranch 33b90b7 所以，只要你理解了Git 是函数式数据结构的本质，你就可以从任何 commit 上来创建分支了。原文还讲了Rebase/Merge和不变性的比较，我觉得就不是很贴切了，这里不再展开，感兴趣的同学可以看下原文。 与其把Git描述成一个版本控制系统，不如说版本控制是“不变性”数据结构的一个自然属性。如果以这种方式来思考的话，Git在概念上比SVN, CVS等要简单。 大家认为Git更加复杂可能是因为这种复杂性能支持更有趣的workflow。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关即时通讯的基本概念]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%9C%89%E5%85%B3%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[刚接触开发IM时，几个基本的概念把我搞得晕头转向，比如： Socket 和 WebSocket 有哪些区别和联系？ WebSocket 和 HTTP 有什么关系？ WebSocket 和 HTML5 是什么关系？ 什么是 长连接/短连接、长轮询/短轮询? WebSocket在哪些场景下使用？ 如果想做IOS的即时通讯，是使用Socket还是WebSocket? 通过google查找了大量资料，觉得有必要把相关内容做一个整理，上面几个问题也会在叙述中逐渐清晰。 1. Socket 和 WebSocket 有哪些区别和联系？就像Java和JavaScript，北大和北大青鸟，雷锋和雷峰塔一样，没有什么关系，除了在名字上沾亲带故的以外，就是两个完全不同的东西。 WebSocket WebSocket一种在单个TCP连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范。WebSocket API也被W3C定为标准。——维基百科 背景： 现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的时间间隔（如每1秒）由客户端对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端。这种传统的模式带来很明显的缺点，即客户端需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 而比较新的技术去做轮询的效果是Comet)。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。如：12ws://example.com/wsapiwss://secure.example.com/ Websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。 WebSocket出现的目的：即时通讯，替代HTTP轮询WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 最初的轮询(polling)阶段 上图表明，客户端发送一个request，服务器不管有没有新消息，都会立即返回一个response，然后关闭连接，这次HTTP请求结束。请记住 Request = Response ， 在HTTP1.0和HTTP1.1中都是这样，也就是说一个request只能有一个response对应。客户端需要不断执行这个请求过程(也就是轮询)，查询服务端有没有新的消息(数据)。1234567891011121314轮询场景：Client：亲亲，有没有新消息(Request)Server：木有（Response）Client：亲亲，有没有新消息(Request)Server：木有。。（Response）Client：亲亲，有没有新消息(Request)Server：好烦，没有。。（Response）Client：那个。。有没有新消息（Request）Server: 有啦，给你（Response）Client：亲亲，有没有新消息（Request）Server：。。没。。。没有（Response）...... 从上面可以看出来，客户端不断的建立HTTP连接，然后等待服务端处理，可以提现HTTP协议的另一个缺陷：被动性，也就是服务端不能主动联系客户端，只能有客户端发起。而且，HTTP request的Header是很长的，为了传输一个很小的数据却占用了很多的带宽流量去传输Header。可见，轮询需要服务器有很快的处理速度，且非常消耗资源，也不具备即时性。 长轮询 (Long polling) 阶段 Long Polling 是对 Polling 的改进，原理跟 Polling 相似，都是采用轮询的方式，不过Long Polling 采取的是阻塞模型：客户端发起连接后，如果服务端没有新消息，就一直不返回Response给客户端。直到有新消息或者超时才返回给客户端，返回之后这次请求结束。客户端再次建立连接，重复这个过程。。。。 12345情景：Client：亲亲，有没有新消息? 没有的话，等有了再给我吧 (Request)Server：额。。。~~~ (1小时后) ~~~ 有新消息了，给你 (Response)...... 相比于 Polling ，Long Polling 在某种程度上减小了对网络宽带的消耗等问题，但缺陷也很明显：假设服务器端的数据更新速度很快，服务器在传送一个数据包给客户端后必须等待客户端的下一个Get请求到来，才能传递第二个更新的数据包给客户端，那么这样的话，客户端显示实时数据最快的时间为2×RTT（往返时间），而且如果在网络拥塞的情况下，这个时间用户是不能接受的，比如在股市的的报价上；另外，由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费；而且 Long Polling 要求服务器具有高并发性，也就是同时接待大量客户端的能力。 WebSocket从上面分析可以看出，Polling ，Long Polling 不是最好的方式，Polling 需要服务端更快的处理速度，Long Polling 需要高并发性。在这种情况下，WebSocket出现，解决了上面提到的 HTTP 协议存在的几个缺陷。 下面三张图，是WebSocket建立连接、传输数据以及关闭连接的模型，至于为什么放三张相似的图，因为。。。我觉得这三张图都挺好看的 –123456789情景：Client：亲亲，我要建立WebSocket协议，需要的服务：chat，WebSocket协议版本:17 （HTTP Request）Server：ok，确认，已升级为WebSocket协议 （HTTP Protocols Switched）Client：麻烦你有新消息的时候推送给我哦。。Server：ok，有的时候会告诉你的。Server：balabalabalabalaServer：balabalabalabalaServer：我看到一个笑话，哈哈哈Server：哈哈哈哈哈哈哈。。。。。 Websocket是应用层第七层上的一个应用层协议，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。Websocket的数据传输是以 frame (帧) 形式传输的，比如会将一条消息分为几个 frame，按照先后顺序传输出去。这样做会有几个好处： 大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。 和 HTTP 的chunk一样，可以边生成数据边传递消息，即提高传输效率。 一个典型的Websocket握手请求如下：12345678客户端请求GET / HTTP/1.1Upgrade: websocketConnection: UpgradeHost: example.comOrigin: http://example.comSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==Sec-WebSocket-Version: 13 123456服务器回应HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Location: ws://example.com/ 字段说明: Connection必须设置Upgrade，表示客户端希望连接升级。 Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。 Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。 Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当被弃用。 Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，于Referer不同的是，Origin只包含了协议和主机名称。 其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。 SocketSocket并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。如果你要使用HTTP来构建服务，那么就不需要关心Socket，如果你想基于TCP/IP来构建服务，那么Socket可能就是你会接触到的API。 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。—— 百度百科 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 —— XX百科 当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。WebSocket则是一个典型的应用层协议。 2. WebSocket 和 HTTP 有什么关系？先看一下这两个概念在维基百科中的解释： WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011, and the WebSocket API in Web IDL is being standardized by the W3C.WebSocket is designed to be implemented in web browsers and web servers, but it can be used by any client or server application. The WebSocket Protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.[1] The WebSocket protocol enables interaction between a browser and a web server with lower overheads, facilitating real-time data transfer from and to the server. This is made possible by providing a standardized way for the server to send content to the browser without being solicited by the client, and allowing for messages to be passed back and forth while keeping the connection open. In this way, a two-way (bi-directional) ongoing conversation can take place between a browser and the server. The communications are done over TCP port) number 80 (or 443 in the case of TLS-encrypted connections), which is of benefit for those environments which block non-web Internet connections using a firewall). —— From Wikipedia, the free encyclopedia The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, and hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web.Hypertext is structured text that uses logical links (hyperlinks) between nodes) containing text. HTTP is the protocol to exchange or transfer hypertext.Development of HTTP was initiated by Tim Berners-Lee at CERN in 1989. Standards development of HTTP was coordinated by the Internet Engineering Task Force (IETF) and the World Wide Web Consortium (W3C), culminating in the publication of a series of Requests for Comments (RFCs). The first definition of HTTP/1.1, the version of HTTP in common use, occurred in RFC 2068 in 1997, although this was obsoleted by RFC 2616 in 1999 and then again by RFC 7230 and family in 2014.A later version, the successor HTTP/2, was standardized in 2015, and is now supported by major web servers. —— From Wikipedia, the free encyclopedia 相同点：WebSocket 和 HTTP 都是基于TCP的应用层协议，都是可靠性传输协议。 不同点： 本来就是两种完全不同的协议。。。 WebSocket 是全双工协议，可以双向发送或接受信息，连接建立之后，通信双方都可以在任何时刻向另一方发送数据。HTTP请求需要等待客户端发起请求服务端才能响应。 与 HTTP 不同的是，Websocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等） Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。 HTTP 协议要不断的建立，关闭Request，由于HTTP是无状态协议，每一次发送都是一次新的开始，所以每次都要重新传输identity info (鉴别信息)，来告诉服务端你是谁。Websocket 只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就可以避免反复解析HTTP协议，还要查看identity info（鉴别信息）。 联系：Websocket 通过 HTTP/1.1 协议的101状态码进行握手。为了创建Websocket连接，需要通过客户端发出请求，之后服务器进行回应，这个过程通常称为“握手)”（handshaking）。 虽然WebSocket在握手的时候是通过 HTTP 进行的（为了兼容性考虑，也许以后WebSocket会有自己的握手方式），但也仅仅是这样而已，它们就是两种不同的应用层协议。 3. WebSocket 和 HTML5 是什么关系？HTML5是指的一系列新的API，或者说新规范，新技术。而WebSocket就是HTML5中出的的一种协议。 4. 什么是 长连接/短连接、长轮询/短轮询?查了许多资料，于是总结一下自己的理解： 长连接/短连接，长轮询/短轮询 本身就是不通层次的概念。 长/短连接 是针对TCP传输层的概念，也就是，TCP连接才有长/短连接之说。 短连接是指通讯双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。 长连接指在一个TCP连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要TCP keep alive。TCP keep alive 的两种方式： 应用层面的心跳机制自定义心跳消息头 ： 一般客户端主动发送, 服务器接收后进行回应(也可以不回应). TCP协议自带的 keep alive：打开keep-alive功能即可. 具体属性也可以通过API设定. TCP KeepAlive 是用于检测TCP连接的状态，而心跳机制有两个作用：一是检测TCP的状态，二是检测通讯双方的状体。 考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。 从上面我们可以知道，KeepAlive 并不适用于检测双方存活的场景，这种场景还得依赖于应用层的心跳。应用层心跳有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息。从这个角度而言，应用层的心跳的确是最佳实践。 写到这顺便说一下 HTTP Keep Alive 和 TCP keep alive 这两个看上去肯定有点儿啥关系的概念。事实上，HTTP keep-alive与TCP keep-alive 是两个完全没有关系的东西。 HTTP keep-alive是HTTP协议的一个特性，目的是为了让TCP连接保持的更久一点，以便客户端/服务端在同一个TCP连接上可以发送多个HTTP request/response。 TCP keep-alive是一种检测连接状况的保活机制。It keeps TCP connection opened by sending small packets. 当网络两端建立了TCP连接之后，闲置idle（双方没有任何数据流发送往来）了tcp_keepalive_time后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 tcp_keepalive_intvl后再次尝试发送侦测包，直到收到对对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试tcp_keepalive_probes,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。 既然长/短连接是针对TCP的概念，但是我们却经常看到HTTP 长连接（HTTP persistent connection）这样的说法，到底什么鬼？憋急，先看一段解释： HTTP persistent connection, also called HTTP keep-alive, or HTTP connection reuse, is the idea of using a single TCP connection to send and receive multiple HTTP requests/responses, as opposed to opening a new connection for every single request/response pair. The newer HTTP/2 protocol uses the same idea and takes it further to allow multiple concurrent requests/responses to be multiplexed over a single connection. —— From Wikipedia, the free encyclopedia 可以发现，HTTP persistent connection就是上面我们解释的HTTP Keep Alive。其实很简单，TCP长连接是针对TCP层的概念，就是让一个TCP连接长时间保持不要断开。HTTP的长连接(keep alive)是HTTP协议的一个特性，也是希望保持住长时间的TCP连接，才能在这个TCP通道上发送多个HTTP请求，而不必每次请求都打开一个新的TCP连接。 长轮询/短轮询 在上文已经介绍了，它是服务器的实现方式！由服务端编写的代码决定。 5. WebSocket在哪些场景下使用？1.社交聊天 最著名的就是微信，QQ，这一类社交聊天的app。这一类聊天app的特点是低延迟，高即时。即时是这里面要求最高的，如果有一个紧急的事情，通过IM软件通知你，假设网络环境良好的情况下，这条message还无法立即送达到你的客户端上，紧急的事情都结束了，你才收到消息，那么这个软件肯定是失败的。 2.弹幕 说到这里，大家一定里面想到了A站和B站了。确实，他们的弹幕一直是一种特色。而且弹幕对于一个视频来说，很可能弹幕才是精华。发弹幕需要实时显示，也需要和聊天一样，需要即时。 3.多玩家游戏 4.协同编辑 现在很多开源项目都是分散在世界各地的开发者一起协同开发，此时就会用到版本控制系统，比如Git，SVN去合并冲突。但是如果有一份文档，支持多人实时在线协同编辑，那么此时就会用到比如WebSocket了，它可以保证各个编辑者都在编辑同一个文档，此时不需要用到Git，SVN这些版本控制，因为在协同编辑界面就会实时看到对方编辑了什么，谁在修改哪些段落和文字。 5.股票基金实时报价 金融界瞬息万变——几乎是每毫秒都在变化。如果采用的网络架构无法满足实时性，那么就会给客户带来巨大的损失。几毫秒钱股票开始大跌，几秒以后才刷新数据，一秒钟的时间内，很可能用户就已经损失巨大财产了。 6.体育实况更新 全世界的球迷，体育爱好者特别多，当然大家在关心自己喜欢的体育活动的时候，比赛实时的赛况是他们最最关心的事情。这类新闻中最好的体验就是利用Websocket达到实时的更新！ 7.视频会议/聊天 视频会议并不能代替和真人相见，但是他能让分布在全球天涯海角的人聚在电脑前一起开会。既能节省大家聚在一起路上花费的时间，讨论聚会地点的纠结，还能随时随地，只要有网络就可以开会。 8.基于位置的应用 越来越多的开发者借用移动设备的GPS功能来实现他们基于位置的网络应用。如果你一直记录用户的位置(比如运行应用来记录运动轨迹)，你可以收集到更加细致化的数据。 9.在线教育 在线教育近几年也发展迅速。优点很多，免去了场地的限制，能让名师的资源合理的分配给全国各地想要学习知识的同学手上，Websocket是个不错的选择，可以视频聊天、即时聊天以及其与别人合作一起在网上讨论问题… 10.智能家居 这也是我一毕业加入的一个伟大的物联网智能家居的公司。考虑到家里的智能设备的状态必须需要实时的展现在手机app客户端上，毫无疑问选择了Websocket。 从上面我列举的这些场景来看，一个共同点就是，高实时性！ ###6 . 如果做即时通讯，是使用Socket还是WebSocket? 使用 Socket 和 WebSocket 都可以做即时通讯。具体怎么做呢？公司项目IOS端使用了第三方库 CocoaAsynSocket ，它是对socket的OC封装，支持TCP、UDP连接。CocoaAsynSocket 的使用非常简单，也有官方和其他资料可以查找，这里就不啰嗦了。这篇文章只是对即时通讯涉及的一些基本概念，根据我自己的理解做一个总结和记录.]]></content>
      <categories>
        <category>IM</category>
      </categories>
      <tags>
        <tag>IM</tag>
        <tag>socket</tag>
        <tag>webSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用cocoapods插件打包静态库——适用于项目依赖私有库、开源库，私有库又依赖静态库等复杂场景]]></title>
    <url>%2F2018%2F08%2F07%2F%E4%BD%BF%E7%94%A8cocoapods%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E5%BA%93%E2%80%94%E2%80%94%E9%80%82%E7%94%A8%E4%BA%8E%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%A7%81%E6%9C%89%E5%BA%93%E3%80%81%E5%BC%80%E6%BA%90%E5%BA%93%EF%BC%8C%E7%A7%81%E6%9C%89%E5%BA%93%E5%8F%88%E4%BE%9D%E8%B5%96%E9%9D%99%E6%80%81%E5%BA%93%E7%AD%89%E5%A4%8D%E6%9D%82%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[我们小组需要持续向其他公司或部门提供一套IM（即时通讯）SDK，为了隐藏源码实现，就需要将它打包为静态库（.a/.framework）的形式。该项目使用cocoapods管理，依赖许多私有库，并且私有库又依赖私有库、开源库等，这些私有库又会涉及频繁更新，每次打包静态库时都需要保证是最新的代码，并且还要解决各个库的依赖问题。在这种情况下，怎么才能方便快速的打包静态库呢？幸好 cocoapods 已经给我们提供了一个打包插件:Cocoapods-package，这让打包静态库的任务变得简单许多。 基础理论xcode中的 workspace, project, target, scheme概念wrokspace A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets. workspace 是最大的集合，包含一个或多个 project，同时 workspace 可以管理它所包含的 project 之间隐式或显式的关系。workspace 是以 xcworkspace 的文件形式存在的（这点和 project 一致）。workspace 的存在是为了解决不同 project 之间引用和调用困难的问题. By default, all the Xcode projects in a workspace are built in the same directory, referred to as the workspace build directory. Each workspace has its own build directory. Because all of the files in all of the projects in a workspace are in the same build directory, all of these files are visible to each project. Therefore, if two or more projects use the same libraries, you don’t need to copy them into each project folder separately. 同一个 workspace 下的所有 project 共用同一个编译路径。 project An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings). 一个 xcode project 包含了这个项目所有的文件、资源以及构建一个或多个 product 所需的信息。project 包含了构建你的应用所需要的所有元素，并维护这些元素之间的关系。project 包含一个或者多个 target，target 描述了怎样去构建 product。project 定义了其包含的所有 project 的 target 的默认编译设置，每个 target 都可以自定义编译选项，自定义配置会覆盖掉 project 的默认配置。 一个 project 可以是独立存在的，也可以被包含到 workspace 中。一个 xcode project 文件包含如下信息： References to source files: Source code, including header files and implementation files Libraries and frameworks, internal and external Resource files Image files Interface Builder (nib) files Groups used to organize the source files in the structure navigator Project-level build configurations.You can specify more than one build configuration for a project; for example, you might have debug and release build settings for a project. Targets, where each target specifies: A reference to one product built by the project References to the source files needed to build that product The build configurations that can be used to build that product, including dependencies on other targets and other settings; the project-level build settings are used when the targets’ build configurations do not override them The executable environments that can be used to debug or test the program, where each executable environment specifies: What executable to launch when you run or debug from Xcode Command-line arguments to be passed to the executable, if any Environmental variables to be set when the program runs, if any You use Xcode schemes to specify which target, build configuration, and executable configuration is active at a given time. target A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product. 字面意思是“目标”，target 指定了如何编译 product ，它负责向编译系统提供”输入”(源文件以及编译这些源文件的配置说明)。 如果你现在有一个产品，你要做不同的环境出来，包括线上、预发、日常等等。这个时候你就可以来建立多个Target来实现。你先选中Targets里面的默认的第一个，然后右击弹出一个小列表：（Duplicate、Delete、Project Editor Help），顾名思义，Duplicate就是复制的意思，你可以选择一个Target进行复制，然后通过修改其General、Build Settings以及Build Phases来进行定制化修改，在Build Settings里面有一个Preprocessor Macros的选项，你可以直接设置定义宏的方式来对不同的Target进行区分。 scheme An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.You can have as many schemes as you want, but only one can be active at a time. You can specify whether a scheme should be stored in a project—in which case it’s available in every workspace that includes that project, or in the workspace—in which case it’s available only in that workspace. When you select an active scheme, you also select a run destination (that is, the architecture of the hardware for which the products are built). 静态库和动态库库（library）是共享程序代码的方式，一般分为静态库和动态库。 静态库: 即静态链接库，是一系列从源码编译得到的目标文件的集合，是你的源码的实现所对应的二进制。链接时，静态库会被完整地复制到目标程序中，被多次使用就有多份冗余拷贝。 在 iOS 8 之前，iOS 只支持以静态库的方式来使用第三方的代码。 静态库的优点是，编译完成之后，原始静态库实际上就没有作用了，应用程序没有外部依赖(因为依赖的静态库已经被完整的拷贝进来)，直接就可以运行。当然其缺点也很明显，就是会使用应用程序的体积增大。 不同平台下的静态库文件格式如下表： 系统 静态库文件 Windows .lib Linux .a MacOS／iOS .a  动态库: 一个没有main函数的可执行文件。动态库在链接时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进内存，这也是叫做动态库的原因。 动态库的优点是，不影响目标程序的体积，可以随时对库进行升级替换而不需要重新编译。 不同平台下的动态库文件格式如下表： 系统 动态库文件 Windows .dll Linux .so MacOS／iOS .dylib –MacOS/iOS 里的 Framework 除了上面提到的 .a 和 .dylib/.tbd 之外，Mac OS/iOS 平台还可以使用 Framework。Framework 是一种特殊的文件夹，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。 系统的 framework 是存在于系统内部，而不会打包进 app 中。app 的启动的时候会检查所需要的动态框架是否已经加载。像 UIKit 之类的常用系统框架一般已经在内存中，就不需要再次加载，这可以保证 app 启动速度。相比静态库，framework 是自包含的，你不需要关心头文件位置等，使用起来很方便。 在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。 iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 App Extension 的出现,可以为一个应用创建插件。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 沙盒中（App 和 App Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。 由于 iOS 的沙盒机制，自己创建的 Framework 和系统 Framework 不同，App 中使用的 Framework 运行在沙盒里，而不是系统中。每个 App 都只能用自己对应签名的动态库，做不到多个 App 使用一个动态库。也就是说，如果不同的 App 使用了同一个动态库 Framework，那该 Framework 会被分别签名、打包和加载。所以，iOS 上我们自己创建的动态库只能是私有的，无法将动态库放置在除了自身沙盒以外的地方。 swift 项目支持静态库 Xcode9 之前 Swift 项目不支持静态库。所以如果你使用的依赖中包含 Swift 代码，又想使用 CocoaPods 来管理的话，必须选择开启 user_frameworks!。use_frameworks! 会把项目的依赖全部改为 framework。也就是说这是一个 none or all 的更改。你无法指定某几个框架编译为动态，某几个编译为静态。 终于在 Xcode 9 版本，swift 带来对静态库的原生支持。并且，CocoaPods 在前一段时间发布了 1.5 版本，其中有一个对于使用了 Swift 的项目非常重要的 feature，那就是支持了 Swift 的 Static Library。 With CocoaPods 1.5.0, developers are no longer restricted into specifying use_frameworks! in their Podfile in order to install pods that use Swift. Interop with Objective-C should just work. However, if your Swift pod depends on an Objective-C, pod you will need to enable modular headers (see below) for that Objective-C pod. As a pod author, you can add DEFINES_MODULE =&gt; &#39;YES&#39; to your pod_target_xcconfig. Alternatively, in your Podfile you can add use_modular_headers! to enable the stricter search paths and module map generation for all of your pods, or you can add :modular_headers =&gt; true to a single pod declaration to enable for only that pod. 以上补充了几点基础知识，能够让你对xcode文件结构和各个文件的作用有了比较清晰的了解，也知道了静态库、动态库，以及为什么之前需要在 podfile 中添加那句 use_frameworks!。现在可以开始打包静态库的工作了。 打包静态库创建一个 pod如果当前已经存在一个 project，创建pod也非常简单： 123$ pod spec create [POD_NAME]]$ edit POD_NAME.podspec$ pod spec lint POD_NAME.podspec 然而创建并配置工程这种费力的活交给 cocoapods 会更好。 Running pod lib create [pod name] will set you up with a well thought out library structure allowing you to easily include your files and get started quickly. 所以我们这里使用 pod lib create [pod name] 去创建一个pod，过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152$ pod lib create YJDemoSDK Cloning `https://github.com/CocoaPods/pod-template.git` into `YJDemoSDK`. Configuring YJDemoSDK template.------------------------------To get you started we need to ask a few questions, this should only take a minute.If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and double click links to open in a browser. )What platform do you want to use?? [ iOS / macOS ] &gt; iOSWhat language do you want to use?? [ Swift / ObjC ] &gt; Objc Would you like to include a demo application with your library? [ Yes / No ] &gt; YesWhich testing frameworks will you use? [ Specta / Kiwi / None ] &gt; NoneWould you like to do view based testing? [ Yes / No ] &gt; NoWhat is your class prefix? &gt; YJRunning pod install on your new library.Analyzing dependenciesFetching podspec for `YJDemoSDK` from `../`Downloading dependenciesInstalling YJDemoSDK (0.1.0)Generating Pods projectIntegrating client project[!] Please close any current Xcode sessions and use `YJDemoSDK.xcworkspace` for this project from now on.Sending statsPod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.[!] Automatically assigning platform ios with version 9.3 on target YJDemoSDK_Example because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`. Ace! you&apos;re ready to go! We will start you off by opening your project in Xcode open &apos;YJDemoSDK/Example/YJDemoSDK.xcworkspace&apos;To learn more about the template see `https://github.com/CocoaPods/pod-template.git`.To learn more about creating a new pod, see `http://guides.cocoapods.org/making/making-a-cocoapod`. 创建完成之后，会自动打开这个pod工程，文件结构如下图所示： podspec .podspec 文件描述了一个 pod 库的版本。它详细说明了这个 pod 库中源码应该从哪里取出、应用怎样的构建设置以及其他基本的信息，比如名称、版本、描述等。 podspec 文件的内容如下，并做了简要注释，不过还是强烈建议阅读下官方文档: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Pod::Spec.new do |s|s.name = &apos;YJDemoSDK&apos; #项目名s.version = &apos;0.1.0&apos; #相应的版本号s.summary = &apos;A short description of YJDemoSDK.&apos; #简述s.description = &lt;&lt;‐ DESC #详细描述TODO: Add long description of the pod here.DESCs.homepage = &apos;https://github.com/yangjie2/YJDemoSDK&apos; #项目主页s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; #开源协议s.author = &#123; &apos;yangjie2&apos; =&gt; &apos;yangjie2107@hotmail.com&apos; &#125; #作者s.platform = :ios, &apos;8.0&apos; #支持的平台s.requires_arc = true #arc和mrc选项spec.compiler_flags = &apos;-DOS_OBJECT_USE_OBJC=0&apos;, &apos;-Wno-format&apos; #A list of flags which should be passed to the compiler.s.libraries = &apos;z&apos;, &apos;sqlite3&apos; #表示依赖的系统类库，比如libz.dylib等s.frameworks = &apos;UIKit&apos;,&apos;AVFoundation&apos; #表示依赖的系统frameworks.ios.vendored_frameworks = &apos;YJDemoSDK/Classes/YJKit.framework&apos; # 依赖的第三方/自己的frameworks.vendored_libraries = &apos;YJDemoSDK/Classes/libWeChatSDK.a&apos; #表示依赖第三方/自己的 .a 库#依赖的第三方的或者自己的静态库文件必须以lib为前缀进行命名，否则会出现找不到的情况，这一点非常重要s.preserve_paths = &quot;IMPORTANT.txt&quot;,&quot;Frameworks/*.framework&quot; #Any file that should not be removed after being downloaded.#平台信息s.platform = :ios, &apos;7.0&apos; s.ios.deployment_target = &apos;7.0&apos;#文件配置项s.source = &#123; :git =&gt; &apos;https://github.com/yangjie2/YJDemoSDK.git&apos;, :tag =&gt; s.version.to_s &#125; #配置项目的目标路径，如果不是本地开发，pod init/update会从这个路去拉去代码s.source_files = &apos;YJDemoSDK/Classes/**/*.&#123;h,m&#125;&apos; #你的源码位置# cocoapods 官方推荐使用 resource_bundles，因为 resources 指定的资源会被直接拷贝到目标应用中，因此不会被 Xcode 优化，在编译生成 product 时，与目标应用的图片资源以及其他同样使用 resources 的 Pod 的图片一起打包为一个 Assets.car 文件。这样全部混杂在一起，就使得资源文件容易产生命名冲突。而 resource_bundles 指定的资源，会被编译到独立的 bundle 中，bundle 名就是你的 pod 名，这样就很大程度上减小了资源名冲突问题，并且 Xcode 会对 bundle 进行优化。一个 bundle 包含一个 Assets.car，获取图片的时候要严格指定 bundle 的位置，很好的隔离了各个库或者一个库下的资源文件。# s.resources = [&apos;YJDemoSDK/Assets/*.png&apos;] #资源，比如图片，音频文件，xib等资源s.resource_bundles = &#123; &apos;WYAVChatKit&apos; =&gt; [&apos;YJDemoSDK/Assets/*.png&apos;,&apos;WYAVChatKit/Assets/Audio.wav&apos;] &#125;s.public_header_files = &apos;YJDemoSDK/Classes/YJDemoSDK.h&apos; #需要对外开放的头文件#依赖的项目内容 可以多个s.dependency &apos;YYModel&apos;s.dependency &apos;AFNetworking&apos; &apos;2.3&apos; Development Pods Development Pods are different from normal CocoaPods in that they are symlinked files, so making edits to them will change the original files, so you can work on your library from inside Xcode. Your demo &amp; tests will need to include references to headers using the #import &lt;MyLib/XYZ.h&gt; format. Note: Due to a Development Pods implementation detail, when you add new/existing files to Pod/Classes or Pod/Assets or update your podspec, you should run pod install or pod update. Development Pods 是符号链接文件，所以对它的编辑也会改变原始文件。这样就能在xcode内开发你的pod库。当你向 Pod/Classes 或 Pod/Assets 添加新的/已经存在的文件，或者更新你的 .podspec 时，需要再次运行 pod install 或者 pod update。 配置完 podspec 之后，需要对它进行验证，没有错误和警告就能通过验证了。 12345pod lib lint ***.podspec //仅本地验证或者 pod spec lint [NAME.podspec|DIRECTORY|http://PATH/NAME.podspec ...] //使用网络验证远端 在实际使用中，我们的pod库依赖私有库，开源库，并且依赖静态库，所以验证时需要指定 sources ，私有Repo地址和cocoapods官方的 Repo 地址，并且默认是 master 分支。 1pod lib lint PODNAME.podspec --sources=git@*******:yangjie2/snowRepo.git,https://github.com/CocoaPods/Specs.git --use-libraries --allow-warnings –use-libraries表示依赖了静态库，–allow-warnings忽略警告。 验证过程也许会比较艰难，因为总会出现各种 errors，不过基本上 google 下都能解决，这里简单记录下我遇到的两个问题: pod本地缓存引起的 build error，明明 xcode 都能编译通过，并且远端服务器上的代码也同步了最新的，但就是执行 pod spec lint 时出现一堆 - ERROR | xcodebuild:。仔细分析下发现，出错的地方依旧是是老版本的代码导致，所以确定是由 pod 缓存引起的。执行 pod cache clean 清除缓存，就可以了。 一个特别奇怪的 error，error: cannot synthesize weak property in file using manual reference counting. 这到底是什么鬼？分析了半天，终于找到原因，s.requires_arc = true这句话，我把 true写成了&#39;true&#39;,记得这里一定不要加单引号，否则 cocoapods 认为你的 pod 库是非 ARC 的。 刚才说到，pod lib lint 和 pod spec lint 的区别： The difference between them is that pod lib lint does not access the network, whereas pod spec lint checks the external repo and associated tag. 上面使用的是 pod lib lint 验证本地pod，其实只要保证本地和远端服务器的代码是一致的，使用 pod spec lint 肯定可以验证通过。只不过有一点需要注意，在使用 pod spec lint 时，验证的是远端,也许你会遇到这种 error：123456- ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone git@*********/WYAVTencentSDK.git /var/folders/8v/jks4fgp55897h3tpp65jp9680000gn/T/d20180808-84364-vuvr0v --template= --single-branch --depth 1 --branch 0.1.0Cloning into &apos;/var/folders/8v/jks4fgp55897h3tpp65jp9680000gn/T/d20180808-84364-vuvr0v&apos;...warning: Could not find remote branch 0.1.0 to clone.fatal: Remote branch 0.1.0 not found in upstream originfatal: The remote end hung up unexpectedly 它提示你找不到 0.1.0 这个分支（因为在 podspec 文件中我们指定了 s.version = ‘0.1.0’），当然找不到了，因为确实没有这个分支。因为我们暂时还没有打 0.1.0 这个tag。当我打了 0.1.0 tag 后，再次使用 pod spec lint 验证，就顺利通过了。 到现在为止，我们完成了对 pod 库的配置，并且打了tag。接下来就开始打包静态库！ 打包静态库需要安装一个 CocoaPods 打包插件 cocoapods-packager。终端执行安装命令：sudo gem install cocoapods-packager，等待安装完成。 cocoapods-packager allows you to generate a framework or static library from a podspec. 执行以下命令，开始打包静态库 12345pod package YJDemoSDK.podspec --library --force --no-mangle --spec-sources=http://*******/yangjie2/snowRepo.git,https://github.com/CocoaPods/Specs.git# --library 表示打包成.a文件。--force 表示强制覆盖之前存在的文件pod package YJDemoSDK.podspec --force --no-mangle --spec-sources=http:*****/yangjie2/snowRepo.git,https://github.com/CocoaPods/Specs.git# 没有--library，则打包成.framework文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546--force# 强制覆盖之前已经生成过的二进制库 --embedded# 生成静态.framework --library# 生成静态.a --dynamic# 生成动态.framework --bundle-identifier# 动态.framework是需要签名的，所以只有生成动态库的时候需要这个BundleId --exclude-deps# 不包含依赖的pod库的符号表/依赖的pod库不打包进去。生成动态库的时候不能使用这个命令，动态库一定需要包含依赖的符号表。 --configuration# 表示生成的库是debug还是release，默认是release 。例如：--configuration=Debug,ONLY_ACTIVE_ARCH=NO--no-mangle# 表示 Do not mangle symbols of depedendant Pods，当你的项目依赖包含静态库时，不加上这句，就会打包失败：[!] podspec has binary-only depedencies,mangling not possible.--subspecs# 如果你的pod库有subspec，那么加上这个命名表示只给某个或几个subspec生成二进制库，# --subspecs=subspec1,subspec2。生成的库的名字就是你podspec的名字，# 如果你想生成的库的名字跟subspec的名字一样，那么就需要修改podspec的名字。 # 这个脚本就是批量生成subspec的二进制库，每一个subspec的库名就是podspecName+subspecName。--spec-sources# 一些依赖的source，如果你有依赖是来自于私有库的，# 那就需要加上那个私有库的source，默认是cocoapods的Specs仓库。# --spec-sources=private,https://github.com/CocoaPods/Specs.git。 打包完成，生成的静态库放在 pod 库路径下 PODNAME-0.1.0 文件夹中。若是 .a 类型的静态库，是没有头文件的，需要手动将头文件拷贝过来才能正常使用。而 framework 则可以直接放在项目中使用。 使用含有category的静态库时, selector not recognized的解决方案 在 iOS/Mac 平台下，包含 Category 的静态库无法被正常加载，原因在于 Category 是 Objective-C 语言的特性，编译器并不会为它生成链接符号，在链接过程中便无法找到该对象文件的引用关系，链接器将会直接忽略掉 Category 对应的对象文件，从而在运行时无法找到相应的 selector。解决该问题的目标就是让链接器加载 Category 对应的对象文件，一种方法是添加编译参数让编译器加载所有的对象文件或是加载指定的对象文件；另一种方法是在 Category 的对象文件中添加 Fake symbol ，当 Fake symbol 被加载时 Category 的对象文件便一同被加载。 解决方法： 在编译选项 Other Linker Flags 中添加 -all_load，用于会告诉编译器 对于所有静态库中的所有对象文件，不管里面的符号有没有被用到，全部都载入，这种方法可以解决问题，但是会产生比较大的二进制文件。在编译选项 Other Linker Flags 中添加 -force_load 并指定路径：1-force_load $(BUILT_PRODUCTS_DIR)/&lt;library_name.a&gt;` 这种方法和 -all_load 类似，不同的是它只载入指定的静态库。 在编译选项 Other Linker Flags 中添加 -ObjC，这个标识告诉编译器 如果在静态库的对象文件中发现了 Objective-C 代码，就把它载入，Category 中肯定会存在 Objective-C 代码。该方法与前两张类似，只是将加载的范围减少了。另一种解决方法是新版本 Xcode 里 build setting 中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件 master object file）被添加到静态库中。现在如果主对象文件中的任何符号被认为是在使用，整个主对象文件都会被认为在使用，这样它里面的 Objective-C 部分就会被载入了，当然也包括 Category 对应的对象文件。最后一种解决方法是在 Category 的源文件里添加 Fake symbol，并确保以某种方法在编译时引用了该 Fake symbol，这会使得 Fake symbol 对象文件被加载时它里面 Category 代码也会被载入。该方法可以控制哪些 Category 可以被正常加载，同时也不需要添加编译参数做特殊处理。建议使用第五种方法解决问题，因为前 4 种都会增加二进制文件的体积，在第三方集成你的 SDK 时需要手动设置编译参数，会给第三方带来不好的使用体验。为了使用方便可定义一下宏：1234567891011#define FIX_CATEGORY_BUG_H(name) \@interface FIX_CATEGORY_BUG_##name : NSObject \+(void)print; \@end#define FIX_CATEGORY_BUG_M(name) \@implementation FIX_CATEGORY_BUG_##name \+ (void)print &#123;&#125; \@end#define ENABLE_CATEGORY(name) [FIX_CATEGORY_BUG_##name print] 在 Category 的头文件中使用 FIX_CATEGORY_BUG_H() 宏来声明一个 Fake symbol ，在 Category 的实现文件中使用 FIX_CATEGORY_BUG_M() 宏来实现该 Fake symbol。最后在找一处运行 ENABLE_CATEGORY() 宏，可以是初始化方法中，也可以是其他任何地方，只要确保它能被正常调用，目的在于该 Fake symbol 确保编译器能正常加载它。 在 64 位的 Mac 系统或者 iOS 系统下，链接器有一个 bug，会导致只包含有 Category 的静态库无法使用 -ObjC 标志来加载 Objective-C 对象文件。 以上就是使用 cocoapods 打包静态库的所有内容了，也许你跟着这个步骤一步步做的时候，会出现意外的错误，不要灰心，用好 google 比什么都重要。 需要注意的是，使用 cocoapods-packager 打包静态库时，podspec 文件中依赖的其他库，会单独编译打包成对应的静态库，所以依赖的库不会打包进主静态库中。想要使用 cocoapods-packager 打包一个完整的静态库，也就是它所有依赖的库也都打包进去，是需要自己去实现的（使用 lipo、ar 等命令）。 Mac 下 lipo、ar、nm 命令的使用（1） lipo 的使用 lipo 是创建和操作“通用文件”（多种CPU架构混合的二进制文件）的命令。它仅生成一个输出文件，并且不改变原始输入文件。 通俗的讲，lipo 的作用是，将多架构类型的文件拆分成单独某个架构类型的文件，或者将多个不同架构类型的文件合成为一个 fat 的通用文件（多架构类型文件）。所以 lipo 进行各种操作的本质是处理 “架构类型”，而不是操作文件内容。 12345lipo [-info] [-detailed_info] [-arch arch_type input_file] ... [ input_file] ... [-arch_blank arch_type] [-create] [-thin arch_type] [-replace arch_type filename] ... [-remove arch_type] ... [-extract arch_type] ... [-extract_family arch_type] ... [-verify_arch arch_type ...] [-output out- put_file] [-segalign arch_type value] ... 它能做的事情包括： 列出通用文件所支持的全部架构类型 从多个/单个输入文件创建一个通用架构的fat文件 从一个通用fat文件，thin 分离出一个指定架构的文件 从输入文件抽取、替换、移除某个架构类型，从而创建出一个单独的新的通用输出文件。 除了 -arch, -arch_blank, -output, 以及 -segalign 这四个 option 可以与其他 option 结合使用以外，剩下的 option 都仅能使用一个。参数 input_file (输入文件) 是必选的，并且仅仅 -create 这个 option 允许有多个输入文件。除了 -info 和 -detailed_info-output 之外，-output 是必选的。 OPTIONS: 123456789101112131415161718192021222324-info # lipo File.a -info-detailed_info# lipo File.a -detailed_info-output [output_file]-create [input_file] [input_file] -output [output_file]# lipo -create InputFileOne.a InputFileTwo.a -output File.a# 注: 输入文件不能包含同样的架构类型-thin [arch_type] # lipo InputFile.a -thin armv7 -output File_armv7.a-replace [arch_type] [file_name]-remove [arch_type]-extract [arch_type]-extract_family [arch_type]-verify_arch [arch_type] [...] （2）ar 创建/维护 library 归档 12345678910111213# ar -t File.a //显示所有.o文件清单# ar -s //更新库的符号索引表 __.SYMDEF# ar -x //从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。 # ar -r -c -s libFileName.a *.o //将当前文件夹中的所有 .o 文件归档为 libFileName.a 文件，并且更新符号表实际应用：将 libFile1.a (arm64) 和 libFile2.a (arm64) 合并为一个 libFile.a (arm64) 文件。假定 libFile1.a 和 libFile2.a 位于 /Users/yangjie/localLib 路径下mkdir ./temp/libFilecd ./temp/libFilear -x /Users/yangjie/localLib/libFile1.aar -x /Users/yangjie/localLib/libFile2.aar -r -c -s libFile.a *.o （3）nm 查看文件符号表nm用来列出目标文件的符号清单 参考文献cocoapods Pod Authors Guide to CocoaPods Frameworks CocoaPods 1.5.0 — Swift Static Libraries Pod二进制化 组件化-动态库实战 组件化-动态库实战续 动态库和静态库的区别 Pod二进制化]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>静态库</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++]虚函数,纯虚函数]]></title>
    <url>%2F2018%2F08%2F04%2FC-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参考来源：知乎 虚函数定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。举个栗子： 假设我们有下面的类层次： 12345678910111213141516171819202122class Animal&#123; public: virtual void eat() &#123; cout&lt;&lt;&quot;i eat like animals.&quot;&lt;&lt;endl; &#125; &#125;; class Dog:public Animal &#123; public: void eat() &#123; cout&lt;&lt;&quot;i eat like a dog.&quot;&lt;&lt;endl; &#125; &#125;; int main(void) &#123; Animal *a = new Dog(); a-&gt;eat(); // 在这里，a虽然是指向Animal的指针，但是被调函数`eat()`却是`Dog`的! 。 return 0; &#125; 这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。 它虚就虚在所谓“推迟联编”或者“动态联编”上，函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。虚函数只能借助于指针或者引用来达到多态的效果。 纯虚函数定义: 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。将函数定义为纯虚函数的方式如下（后面多了个 ＝0 ）： 1virtual ReturnType Function() = 0; 引入原因 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 为了解决上述问题，引入了纯虚函数的概念，只要在基类中定义了纯虚函数，则编译器要求在其派生类中必须予以重写以实现多态性。含有纯虚函数的类称为抽象类，抽象类它不能生成对象。 这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。纯虚函数最显著的特征是：它们必须在子类中重新声明（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中没有定义。 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。 抽象类抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的定义： 称带有纯虚函数的类为抽象类。抽象类的作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。 使用抽象类时注意：• 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。• 抽象类是不能定义对象的。 总结：1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。 2、虚函数声明如下：virtual ReturnType FunctionName(Parameter)； 虚函数必须实现，如果不实现，编译器将报错，错误提示为：error LNK****: unresolved external symbol &quot;public: virtual void __thiscall ClassName::virtualFunctionName(void)&quot; 3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。 4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。 5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。 6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。 7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。 8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。定义纯虚函数就是为了让基类不可实例化化因为实例化这样的抽象数据结构本身并没有意义。或者给出实现也没有意义。实际上我个人认为纯虚函数的引入，是出于两个目的1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。2、为了效率，不是程序执行的效率，而是为了编码的效率。 最后引用别人的一段生动形象的解释： 上帝是一个程序员，创造了动物(基类)，给予了动物吃饭，睡觉，叫唤等通用功能。(封装)只指定了平均睡觉八小时(虚函数)，其中没有指定具体的吃饭，叫唤的行为。(纯虚函数)然后细分一下，动物有猫狗羊和人。(继承)人类明确它们物种的时候(明确类型的派生类指针)猫吃鱼 狗吃肉 羊吃草猫喵喵 狗汪汪 羊咩咩(多态 同名覆盖)一切都如此顺理成章。突然人发现一只动物！这只是什么呢？诶？这货不知道是啥！只能用”动物”来称呼他！(基类指针指向子类对象)当没有虚函数的时候，人类发现这只动物不会叫也不会吃！因为他根本没有这样的实现！(注意 真正编程上如果派生类不对纯虚函数进行实现将无法通过编译)有了虚函数，让那只动物”吃”，发现他吃草！于是捅一下这只动物，发现它会 哞哞叫！于是得知这是一头牛！可以吃！于是人类就把它吃掉了。总结:虚函数目的是在用基类指针指向派生类的时候还能正确调用派生的实现。]]></content>
      <categories>
        <category>C++ dev</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从MVVM到ReactiveCocoa]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%BB%8EMVVM%E5%88%B0ReactiveCocoa%2F</url>
    <content type="text"><![CDATA[翻译自 Bob Spryn 的 ReactiveCocoa and MVVM, an Introduction这是一篇很好的文章，从头到尾通读一遍会对MVVM模式以及ReactiveCocoa的使用有种豁然开朗的感觉。现有的译文中存在许多翻译不准确的地方，这里根据原文内容加上自己的理解重新翻译如下。 MVC任何有经验的软件开发者都会熟悉 MVC 这个概念。它表示 Model View Controller ，是在复杂应用设计中一种久经考验的代码组织方式。在IOS开发中，MVC也被证实具有第二种含义：Massive View Controller (笨重的视图控制器) ，这让许多开发者困惑于如何优雅地对代码进行组织和解耦。IOS开发者需要给 view controller 瘦身，这是他们的共识。然而，怎么做呢？ MVVM为了解决上面的问题，MVVM 应运而生。它表示 Model View View-Model ，它帮助我们创建更易管理、具有良好设计的代码。某些情况下违背Apple建议的编码方式没有多大意义，我不是说不赞成这么做，而是觉得这么做弊大于利。比如我不建议你去实现一个 View Controller 基类并试图自己处理VIew的生命周期。带着这种思想，我不禁提出这样一个问题：使用Apple推荐的MVC之外的设计模式是不明智的吗？不！原因有两点：Apple 没有真正给出解决 Massive View Controller 问题的任何指导，他们将更多空间留给我们。MVVM 就是一种很酷的解决方式。 MVVM 能够与 MVC 很好的兼容，并将 MVC 延展到另一个层次。 关于 MVC/MVVM 的历史这里不做介绍了，我会更关注它在 iOS 开发中的应用。 Defining MVVMModel - 在 MVVM 中，model 的作用并没有什么特别变化，我们仅把它当做存放数据-模型对象信息的结构体，而在单独的管理类中保留创建/管理model的统一逻辑。 View - view中包含真正的UI本身(不管是 UIView 代码，还是 storyboard 和 Xib )、任何与视图有关的特定逻辑以及对用户输入的响应。这包括了许多由 UIViewController 负责处理的工作，不仅仅是UIView代码和文件。 View-Model - 这个术语本身就会给我们带来困惑，它由两个我们熟悉的术语组合而成，但完全是不同的东西。它不是传统意义上 data-model 结构中 model 的作用。它的职责之一是作为一个静态模型，为视图展示自身提供必要的数据，但它也有收集、解释、转换这些数据的责任。这留给 View(Controller) 一个更加清晰明确的任务：将 View-Model 提供的数据呈现出来。 More about the view-modelview-model 这个术语不足以描述我们的意图，一个更合适的名字可能是 “View Coordinator (视图协调器)”。它从资源(database，web service calls，etc)中收集原始数据，应用某种逻辑去处理修改造这些数据，加工成供 view(controller) 界面展示所需的数据。view-model (通常通过属性)仅仅暴露出来 view(controller) 显示所需的信息 (理想情况下不要暴露你的 data-model 对象)。它还负责处理上游数据的修改，比如更新模型/数据库, API POST 调用。 MVVM in a MVC world在iOS开发中，我觉得 MVVM 这个首字母缩写像 view-model 一样词不达意，让我们再看下它是怎么适应MVC模式的。 Here is a simple mapping of how these two patterns fit together in iOS: 说明： 使用图形块的大小粗略的表示它负责的工作量的多少 注意看 view controller 部分有多大？ 巨大的 view controller 和 view-model 之间有大块工作上的重合 view controller 和 MVVM 中的 view 也有一大部分的工作是重合的 我们并不是要去除 view controller 这个概念，或者丢掉 “controller” 去匹配 MVVM，我们仅仅是将这部分重合的任务划分到 view-model 中，让 view controller 变得更加简单清晰。 最终得到的结果用图表示如下： 现在，view controller 仅涉及配置和管理各种视图，这些视图的数据都来自 view-model，view controller 也负责在用户有输入动作发生时通知 view-model ，让 view-model 去修改上游数据。view controller 不需要知道有关web service calls, Core Data, model objects 等的一些东西。 view-model 也是一个对象，它会以一个属性的方式存在于 view controller 中，视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知。你或许已经感觉到这种设计好多了，因为在这里我们对相关工作做了很好的分离。 下图展示了这种 MVVM 模式下新的应用设计结构： 这张图或许能更好的帮助你理解。 View-Model and View Controller, together but separate举个栗子：为了情节简单, 让我们构建一个简化的twitter客户端，任何使用推特的用户，只要输入用户名，就可以查阅最近的回复。 我们的例子交互和界面如下: 有一个 UITextField，让用户可以输入名字，一个 “Go” UIbutton 有一个 UIImageView和一个 UILabel ，用于显示当前被查看的用户的头像和姓名 下面有一个 UITableView，显示最近的推文回复。 允许无限滚动 The Example View-Modelview-model 的头文件如下所示：123456789101112@interface MYTwitterLookupViewModel: NSObject@property (nonatomic, assign, readonly, getter=isUsernameValid) BOOL usernameValid;@property (nonatomic, strong, readonly) NSString *userFullName;@property (nonatomic, strong, readonly) UIImage *userAvatarImage;@property (nonatomic, strong, readonly) NSArray *tweets;@property (nonatomic, assign, readonly) BOOL allTweetsLoaded;@property (nonatomic, strong, readwrite) NSString *username;- (void) getTweetsForCurrentUsername;- (void) loadMoreTweets; 头文件很简单。注意到所有这些壮观的 readonly属性了吗？view-model 仅暴露我们的 view controller 需要的最少的信息，而且 view conreoller 不关心 view-model 是怎么得到这些信息的。 view-model 不做的事情 通过任何形式直接作用于 view controller，或者直接通知控制器关于自己的一些变化。 The Example View Controller视图控制器使用从 view-model 获取的数据去做: 当usernameValid值变化时，触发“Go”按钮的enabled属性 当 usernameValid 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为1.0) 使用 userFullName更新 UILabel 的文本内容 使用 userAvatarImage更新 UIImageView 的 image 使用数组 tweets配置 table view 的 cells 当滑动到 table view 的底部时，如果 allTweetsLoaded为 NO，提供一个显示“loading”的 cell View Controller将通过如下方式作用于 view-model ： 每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username 当 “Go” 按钮被按下时，调用 view-model 上的 getTweetsForCurrentUsername 方法 当到达表格中的 “loading” cell 时，调用 view-model 上的 loadMoreTweets 方法 view controller 不做的事情 发起网络服务调用 管理 tweets 数组 判定 username 内容是否有效 将用户的姓和名格式化为全名 下载用户头像并转成 UIImage 挥洒汗水 再次注意，视图控制器的总责任是如何处理 view-model 中的变化 #####Child View-Models上面提到，我们使用 view-model 的 tweets 数组配置表格中的cell。通常你期望用来展示 tweets 的是这些 data-model 对象。但是上面提到，MVVM 模式下，不会暴露 data-model 对象，这时候你正感受到深深的恶意。。。 不需要仅使用一个 view-model 代表屏幕上展示的所有东西！ 你可以使用 child view-model 表示更小的、潜在的更具封装性的部分：如果某一小块视图(比如 cell)在你的app中可以复用，或者它表示多个 data-model 对象，这么做将会十分有益。 你并不总是需要 child view-models。比如，我可以使用一个 table header view 来渲染我们的app “tweetboat plus”顶部部分，它不是一个可复用组件，所以我仅需要传入 view controller 使用的那个相同的 view-model 给这个自定义 header view 就可以了。它从那个 veiw-model 中获取自己需要的信息而忽略其他的。这是一个让你的子视图保持同步的特别棒的方法，因为它们都可以有效地使用相同的信息上下文，并观察与更新相同的属性。 在我们示例app中，tweets数组内放置的是 子view-model，大概长这样：1234567@interface MYTweetCellViewModel: NSObject @property (nonatomic, strong, readonly) NSString *tweetAuthorFullName;@property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage;@property (nonatomic, strong, readonly) NSString *tweetContent;@end 你可能会觉得，这个子view-model也太像通常意义的 data-mode 对象了吧？为什么要把它转换成 view-model ？ 尽管很相似，但是 view-model 让我们能够限制信息，仅暴露出我们需要的部分；提供可能转换数据的其他属性；或者为特定视图计算数据 (再说下，一种很好的设计方式是尽可能不要暴露可变的 data-model 对象，因为我们希望 view-model 自己负责修改更新他们，而不是 view 或者 view controler)。 View-Model 从哪来?那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么? View-Model 产生 View-Model严格来讲，你应该在 app delegate 中为顶级视图控制器创建一个 view-model。当展示一个新的 view controller 或者一个很小的视图(这个小的视图使用 view-model 表示)时，要让当前的这个 view-model 为你创建需要的 child view-model 。 假如我们想要在用户点击应用顶部的头像时，添加一个资料视图控制器，我们可以为当前主 view-model 添加一个方法： 1- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser; 在我们的主控制器中，可以像这样使用它：12345678- (IBAction) didTapPrimaryUserAvatar&#123; MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser]; MYTwitterUserProfileViewController *profileViewController = [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; [self.navigationController pushViewController: profileViewController animated:YES];&#125; 在这个例子中，我想弹出一个用户资料视图控制器，但是这个控制器需要一个 view-model。我的主控制器并不知道关于这个用户的数据信息，无法创建这个view-model(也不应该要它创建)，所以，我的主控制器让它的 view-model 去做这项苦差事。 view-model 列表回到推特例子中 table view 的 cell，当数据通过网络请求被拿到后，我会特意提前将对应cell的所有view-model创建好。所以在我们这里，主view-model的tweets数组内是MYTweetCellViewModel对象。在 table view 的 cellForRowAtIndexPath方法中，我会简单地在正确的索引位置从tweets数组中抓取子view-model，将它赋值给 cell 的 view-model 属性。 Functional Core, Imperative Shell (函数式内核，命令式外壳)Functional Core(函数式内核)view-model 就是我们的函数式内核 “functional core””，尽管实际上在 iOS/Objective-C 中达到纯函数级别是很棘手的(Swift 提供了一些附加的函数性, 这会让我们更接近)。一般的想法是让 view-model 尽可能少地依赖和影响应用程序的其它部分。这是什么意思？回想一下你刚开始学编程时遇到的简单的函数，它们接受一两个输入参数，并输出一个结果值。Data in, data out。也许这个函数做了一些数学计算或者字符串拼接。不管应用程序中发生了什么，相同的输入，就会得到相同的输出。这就是 函数式 。 我们使用 view-model ，就是想得到函数式结果。view-model 内部包含逻辑与功能，将数据转换并存储在它的属性中。理想情况下，相同的输入将导致相同的输出结果。这意味着可以尽可能多的消除应用程序的其它部分对输出结果的影响，比如使用大量的状态值。我们要做的第一步就是在你的view-model的头文件中不要包含UIKit.h（这是一个很好的原则，但也有一些灰色区域：比如，你可能会将UIImage看作数据，而不是视图（我喜欢这样）。在这种情况下，你需要UIKit.h来获得UIImage类）。UIKit 的性质就决定了它会严重影响应用程序的许多地方，它含有很多副作用，更改一个值或调用一个方法将触发许多间接(甚至不可知)的更改。 update： 需要理解你的 view-model 仍然是一个 object，并且的确需要维持一些状态(否则它对你的视图来说就不是一个非常有用的模型了)。但你仍然应该努力将尽可能多的逻辑转移到无状态函数的“值”中(swift 在这方面比 Objective-C 更可行)。 Imperative (Declarative?) Shell（命令式（声明式？）外壳）我们将 view-model 数据转换成屏幕所显示的东西，需要做一系列工作，比如所有的状态改变，应用内其它部分的改变，命令式外壳就是我们做这些脏活儿累活儿的地方。这就是我们的 view (controller)，我们处理 UIKit 的地方。我依然特别注意尽可能的减少状态变量，将这一系列工作用声明式的方式完成，例如使用ReactiveCocoa。但本质上，iOS和UIKit是命令式的。 Testable CoreiOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注: mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法) 这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是变得非常能够进行单元测试. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 现在我们将数据的获取/逻辑/转换从 view controller 中提取出来, 避免了视图控制器的复杂性. 那意味着测试时不需要用疯狂的 mock 对象, method swizzling, 或其他疯癫的变通方法(希望能有)了。 Connecting Everything那么，当 view-model 上的公开属性值变化时，我们怎么更新视图呢？ 大多时候，我们使用相应的 view-model 去初始化 view controller，类似在上文见到的，比如：12MYTwitterUserProfileViewController *profileViewController =[[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; 有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在该 view (controller) 中暴露一个公有可写的 view-model 属性.1234MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath];// grab the cell view-model from the vc view-model and assign itcell.viewModel = self.viewModel.tweets[indexPath.row]; 有时候可以在钩子程序执行前传入 view-model，比如 init或者 viewDidLoad，这样，我们可以使用 view-model 提供的属性值初始化所有UI部件的状态：123456789101112- (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel &#123; self = [super init]; if (!self) return nil; _viewModel = viewModel; return self;&#125;- (void) viewDidLoad &#123; [super viewDidLoad]; _goButton.enabled = viewModel.isUsernameValid; _goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5; // etc&#125; 很棒！我们已经配置好了初始值。当 view-model 中的数据变化时，怎么更新UI部件的状态？怎么将按钮变为不可用？我们的用户名label和头像将如何被网络请求的结果所填充? 将 viewcontroller 设置为 view-model 的代理？数据变化时，view-model 发送通知？ 不不不。。 我们的视图控制器能够知道一些变化的发生。可以使用 UITextfield 的代理方法，通过每次有输入字符变动时检查 view-model ，来更新button的状态。1234567- (void)textFieldDidChange:(UITextField *)sender &#123; // update the view-model self.viewModel.username = sender.text; // check if things are now valid self.goButton.enabled = self.viewModel.isUsernameValid; self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5;&#125; 这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 isUsernameValid 值. 假使还有其他变量/动作改变 isUsernameValid 的状态将会怎么样? 对于 view-model 中的网络请求又如何呢?或许我们该为 view-model 中的方法加一个完成后回调处理, 这样我们在那个节点就可以更新 有关UI 的一切东西了?使用古老而笨重的KVO方法？ 最终，我们可以使用我们所熟悉的各种机制来连接 view-model 和 view (controller) 中的所有接触点，但是你知道标题上可不是这么写的。这种方式在代码中创建了大量的入口点，就算是简单的UI更新，也必须完全重新创建应用程序状态的上下文。 Enter ReactiveCocoaReactiveCocoa (RAC) 是来拯救我们的。让我们看看它是怎么做的。 考虑通过一个新的用户界面来控制信息的流动：该界面在表单有效时更新提交按钮的状态。以下是你目前的工作方式: 最终，通过使用状态，谨小慎微地将自己简单的逻辑穿插在众多不同且无关的代码上下文中。看一下信息流中所有不同的入口点，是不是感觉乱糟糟的？(这还仅仅是一个UI元素的逻辑线) 。 我们在编程中使用的这些抽象还不够聪明，不能追踪所有这些事情的联系，所以最终还得自己做这些事儿。 让我们看下“陈述式”的版本： 这张图谱记录了我们应用程序的流程。通过这种陈述式编程，我们使用了一种更高级别的抽象，它让我们在实际的编程中，能够更接近我们自己脑海中的思维流。我们让电脑做更多的工作。现在实际的代码与这张图谱显得很接近了。 RACSignalReactiveCocoa核心就是 RACSignal。RACSignal (信号)对于 RAC 来说是构造单元。它是一个我们最终将会接收到的承载着信息的对象。当你有了一个在某个时间点将会收到的信息的具体表示形式时，那就开干吧！运用必要逻辑并预先构建你的信息流(声明式)，而不是必须等到事件发生时才这么做(响应式)。 信号会捕获所有的异步方法(委托, 回调 block, 通知, KVO, target/action事件观察者，etc)来控制通过应用程序的信息流，并将他们统一在一个接口下。不仅如此，它还能够让你轻松的转换/分解/合并/过滤 流经你app的信息。 那么什么是信号呢，这就是一个信号： 信号是一个发送一连串值的物体。但我们这里的信号什么都没做，因为它还没有任何订阅者。一个RAC信号仅当有订阅者去监听它时，它才会发出信息。它将向订阅者发送0或者载有数值的“next”事件，后面紧跟着一个 “complete” 事件或者一个 “error” 事件。信号不仅限于一次只向它的订阅者发送一个返回值。 就像我前面提到的，如果需要的话你可以过滤, 转换, 分解，合并那些值。不同的订阅者可能需要由信号发出的这些数值的不同形式。 信号从哪里得到它们发送的值？Signals 是一些等待事件发生的异步代码，当事件发生时就向它们的订阅者发送结果值。你可以使用 RACSignal 类中的类方法 createSignal: 手动创建这些信号：12345678RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;]; [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123; [subscriber sendNext:result]; [subscriber sendCompleted]; &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123; [subscriber sendError:error]; &#125;]; 上面我创建了一个信号，我使用 RACSignal 提供的 subscriber 对象调用 sendNext: 和 sendCompleted: 方法(请求成功时)，或者调用 sendError:(请求失败时)。现在我可以订阅这个信号并在网络请求返回时接收到 json 值或是 error。 RAC 为我们提供了丰富的机制来从我们常用的现有异步模式中提取信号。如果你有一个异步任务没有覆盖在内置的信号中，你可以很容易地用 createSignal: 或类似方法来创建信号。 RAC提供的一个机制就是使用宏 RACObserve()，这个宏是对 KVO 中那些糟透的 API 的替代。你只需要传入一个对象以及在这个对象中你想要监听的属性的名称。给出这些参数后，RACObserve ()会生成一个信号，并立即向它的监听者发送这个属性的当前值，以及未来关于这个属性的任何变化。 1RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid); 上面仅是创建信号的一种方式，下面有几种现成的从控制流机制中获得信号的方式：123456789101112131415161718RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside]; // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc) // subscribeNext:^(UIButton *button) &#123; NSLog(@&quot;%@&quot;, button); // UIButton instance &#125;RACSignal *textChange = [myTextField rac_textSignal]; // some special methods are provided for commonly needed control event values off certain controls // subscribeNext:^(UITextField *textfield) &#123; NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; &#125;RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal]; // signals for some delegate methods send the delegate params as the value // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc // (limited to methods that return void) // subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; &#125;RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)]; // signals for arbitrary selectors that return void, send the method params as the value // works for built in or your own methods // subscribeNext:^(NSNumber *animated) &#123; NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear 1&quot; &#125; 你也能轻松创建自己的信号, 包括替代那些没有内置支持的其他委托。我们现在可以将所有这些断了联系的异步/控制流工具中获得信号，将也可以将它们组合在一起，想想这是多么酷的事情！这些信号会成为上面看到的陈述式图谱中的nodes节点，开心吧。 什么是订阅者？简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了(它也可以作用于 “complete” 和 “error” 事件)。再次注意，订阅者就是一段代码，而不是一个具体的对象。 下面是一个简单的 subscriber，通过向信号的实例方法 subscribeNext : 传入一个 block 创建的。这里我们正在通过 RACObserve() 宏创建的这个信号，观察一个对象的某个属性的当前值, 并把这个属性值赋给一个内部属性。123456789- (void) viewDidLoad &#123; // ... // create and get a reference to the signal RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid); // update the local property when this value changes [usernameValidSignal subscribeNext:^(NSNumber *isValidNumber) &#123; self.usernameIsValid = isValidNumber.boolValue &#125;];&#125; 注意 ：RAC 只处理对象, 而不处理像 BOOL 这样的原始值。 不过不用担心, RAC 通常会帮你处理这些转换。 RAC 作者也意识到这种绑定行为的普遍必要性。所以他们提供了另一个宏定义：RAC()。与 RACObserve() 类似，你提供一个对象和这个对象的属性名参数，传入的值就会绑定到这个对象的这个参数上。这个宏定义在内部就是做了上面 viewDidLoad 方法中的工作：创建订阅者，更新属性值。1234- (void) viewDidLoad &#123; //... RAC(self, usernameIsValid) = RACObserve(self.viewModel, isUsernameValid);&#125; 但考虑到我们的目的，这样做有点傻冒。我们并不真的需要将信号中的值存储到一个属性中(也会因此创建状态)，我们真正想做的是用从这个值中收集的信息来更新UI。 转换数据流现在我们开始看 RAC 为我们提供的转换数据流的值的方法。我们会用到 RACSignal 类提供的 map 实例方法。123456789- (void) viewDidLoad &#123; //... RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid); RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid) &#123; return usernameIsValid.boolValue ? @1.0 : @0.5; &#125;];&#125; 现在，我们将 view-model 上的 isUsernameValid 属性所发生的更改直接绑定到 goButton 上的 enabled属性上。绑定 goButton 按钮的 alpha 属性显得更让人兴奋，因为我们使用 map 方法将信号的值转换成 alpha 属性的值。 多个订阅者, 副作用, 昂贵的操作在订阅信号链时，你应当认识到这样一件非常重要的事，每当一个新值通过该信号链发送时，它实际上是每一个订阅者都会发送一次。 比如新增了一个订阅者去监听一个信号，那么信号会立即向订阅者发送信息，注意是所有订阅者！而不仅仅是你刚才新增的那个。信号发送出的信息(值)不会存储在任何地方(除了RAC的内部实现部分)，认识到这一点对我们来说是有意义的。当信号需要发送一个新的值时，它会遍历所有的订阅者，并给每个订阅者发送那个值。 这就意味着在你信号链的某处产生的任何副作用，任何影响应用程序世界的转换，都会多次发生。对于刚开始使用RAC的用户来说，这是意料之外的(这也违背了“函数式”思想—相同的输入，产生相同的输出)。 举个蹩脚的例子：有一个按钮点击事件信号，它会在信号链的某个地方更新一个计数属性，如果有多个订阅者监听了这个信号链，这个计数属性的增长比你想象的还要多。你需要从信号链中尽可能的剔除副作用，当副作用不可避免时, 你可以使用一些恰当的预防机制，我将会在另一篇文章中讨论。 除了副作用以外，你需要特别注意带有代价昂贵的操作和可变数据的信号链。网络请求是一个兼有以下三点的例子： 网络请求影响你的 app 的网络层(副作用). 网络请求给信号链带来了可变数据. (两个完全一样请求可能返回了不同的数据) 网络请求反应慢 例如，你有一个信号，每次点击按钮，信号就会发送一个值，你想转换这个值，并用转换结果进行网络请求从而得到请求结果。如果有多个订阅者要处理这个信号链返回的值，你将会发起多次网络请求。 显然网络请求是经常需要的，如你所想，RAC 为这种情况提供了解决方案：RACCommand 和多点广播。我将在下一篇文章中深入讨论。 Tweetboat Plus简短的介绍之后，现在我们着手怎么将 view-model 和 view controller 使用 ReactiveCocoa 联系起来。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// View Controller//- (void) viewDidLoad &#123; [super viewDidLoad]; RAC(self.viewModel, username) = [myTextfield rac_textSignal]; RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid); RAC(self.goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) &#123; return valid.boolValue ? @1 : @0.5; &#125;]; RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName); @weakify(self); [[[RACSignal merge:@[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id value) &#123; @strongify(self); [self.tableView reloadData]; &#125;]; [[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext: ^(id value) &#123; @strongify(self); [self.viewModel getTweetsForCurrentUsername]; &#125;];&#125;-(UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // if table section is the tweets section if (indexPath.section == 0) &#123; MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYTwitterUserCell&quot; forIndexPath:indexPath]; // grab the cell view model from the vc view model and assign it cell.viewModel = self.viewModel.tweets[indexPath.row]; return cell; &#125; else &#123; // else if the section is our loading cell MYLoadingCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath]; [self.viewModel loadMoreTweets]; return cell; &#125;&#125;//// MYTwitterUserCell//// this could also be in cell init- (void) awakeFromNib &#123; [super awakeFromNib]; RAC(self.avatarImageView, image) = RACObserve(self, viewModel.tweetAuthorAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName); RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);&#125; 让我们来分析下上面的这个例子： 1RAC(self.viewModel, username) = [myTextfield rac_textSignal]; 这里使用RAC提供的方法，从 UITextField 中得到一个信号。上面这行代码将 view-model 的可读写属性 username 绑定到 textfield 的任何更新。 12345678RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid);RAC(self.goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) &#123; return valid.boolValue ? @1 : @0.5; &#125;];RAC(self.goButton, enabled) = usernameIsValidSignal; 这里我们使用宏 RACObserve() 在 view-model 的 usernameValid 属性上创建一个信号 usernameIsValidSignal，不管什么时候只要这个属性值有变化，这个信号就会沿着管道(pipe)发送一个新的 @YES 或 @NO 值。我们将这个值绑定到 goButton 的两个属性上。 接着，通过使用宏 RACObserve 在对应的 view-model 属性上创建信号，为 table view 表头的 image view 和 user label 创建绑定：123RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage);RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName); 下面这段代码看起来有点棘手，所以让我们多花点时间在这里。12345678@weakify(self);[[[RACSignal merge:@[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id value) &#123; @strongify(self); [self.tableView reloadData]; &#125;]; 我们希望在 view-model 里的 tweets 数组和 allTweetsLoaded 属性发生变化时就能立刻更新 table view。所以我们将观察这两个属性的信号两个信号合并成一个“大信号”，这样，当这两个属性有任何一个变化时，这个合并后的大信号就会发送一个值 (通常你希望信号的值是同类型的，而不是像这个信号那样混合着其他类型值。这可能会在 RAC swift 强制执行，但这里我们不关心发送的实际值，我们只是用它来触发 table view 的重新加载)。 所以这里有点吓人的部分可能是 bufferWithTime:onScheduler: 方法，这么做是为了解决 UIKit 中的一个问题。我们需要同时追踪 tweets 和 allTweetsLoaded 这两个属性，目的是为了防止其中一个发生变化而另一个没有变(有一个属性变化，就需要更新 table view)。问题是，有时这两个属性碰巧会在同一时间点发生变化，这意味着，合并产生的大信号中的两个小信号都将发送一个值，那么reloadData 将在同一个 run loop 中被连续调用两次。UIKit 不喜欢这样。bufferWithTime: 捕获任何在给定时间内发送过来的下一个值，当这段时间过去以后，再将这些值一并发送给订阅者。通过传入参数 0 ，bufferWithTime:方法将捕获在一个 run-loop 时间内由“大信号”发出的所有值，然后再将这些值一起发出去。别担心，就把它当做需要将这些值必须在主线程上传递。现在我们能够确保 reloadData 方法在每个run-loop 内只执行一次。注意：我们用到了 @weakify/@strongify 宏，这对打破循block引起的环引用非常重要。 下面这段代码展示出 RACCommand 将会发挥作用的地方，将在下一篇文章中介绍。就目前来说，当按钮被点击时，我们只是手动调用 view-model 的 getTweetsForCurrentUsername 方法：12345[[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext: ^(id value) &#123; @strongify(self); [self.viewModel getTweetsForCurrentUsername]; &#125;]; 我们已经介绍了cellForRowAtIndexPath 的第一部分，所以这里只说下 loading cell：1234MYLoadingCell *cell =[self.tableView dequeueReusableCellWithIdentifier:@&quot;MYLoadingCell&quot; forIndexPath:indexPath];[self.tableView loadMoreTweets];return cell; 这是将来我们使用 RACCommand 的另一个领域。现在我们只是调用 view-model 中的 loadMoreTweets方法。我们相信，如果 cell 隐藏并显示了多次，view-model 可以在内部避免多次调用。 1234567- (void) awakeFromNib &#123; [super awakeFromNib]; RAC(self.avatarImageView, image) = RACObserve(self, viewModel.userAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName); RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);&#125; This should be fairly straightforward now, aside from one thing I want to point out. We are binding an image and strings to the appropriate properties on our UI, but note that viewModel is on the right side of the comma in the RACObserve macro. These cells will end up getting reused and new view-models will be assigned. Instead of listening for the viewModel property to change and then re-setting up our bindings everytime, if we put viewModel on the right side of the comma, RACObserve is going to take care of that for us. So we only set up this binding ONCE and let Reactive Cocoa do the rest. This is a good thing to keep in mind for performance with bindings on table cells. In practice I’ve had no issues even with lots of table cells screaming around. 额外的好处——消除更多的状态有时候你在 view-model 中暴露出 RACSignal 而不是一些属性值会帮你消除 view-model 上更多的状态。这样，你的 view (controller) 就可以直接使用这些信号，而不必使用 RACObserve创建它自己的信号了。注意：如果在 UI 订阅/绑定这个信号之前，它就已经发送了一个值，那么你就会错过这个“初始”的值。 结论这是一种不同的编程风格，它为你提供了另一种与“命令式”完全不同的思路。即使你一开始并不会经常使用这种方式，但它仍然告诉你，有这样一位姑娘(RAC) 可以用她特有的方式为你解决困惑。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM消息的可靠投递]]></title>
    <url>%2F2018%2F07%2F06%2FIM%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92%2F</url>
    <content type="text"><![CDATA[报文类型im的客户端与服务器通过发送报文（也就是网络包）来完成消息的传递，报文分为三种：请求报文（request，后简称为为R）应答报文（acknowledge，后简称为A）通知报文（notify，后简称为N），这三种报文的解释如下： R：客户端主动发送给服务器的报文A：服务器被动应答客户端的报文，一个A对应一个RN：服务器主动发送给客户端的报文 普通消息投递流程用户A给用户B发送一个“你好”，流程如下： 1）client-A向im-server发送一个消息请求包，即msg:R2）im-server在成功处理后，回复client-A一个消息响应包，即msg:A3）如果此时client-B在线，则im-server主动向client-B发送一个消息通知包，即msg:N（当然，如果client-B不在线，则消息会存储离线） 上述消息投递流程出现的问题从流程图中容易看到，发送方client-A收到msg:A后，只能说明im-server成功接收到了消息，并不能说明client-B接收到了消息。在若干场景下，可能出现msg:N包丢失，且发送方client-A完全不知道，例如：1）服务器崩溃，msg:N包未发出2）网络抖动，msg:N包被网络设备丢弃3）client-B崩溃，msg:N包未接收结论是悲观的：接收方client-B是否有收到msg:N，发送方client-A完全不可控，那怎么办呢？ 应用层确认+im消息可靠投递的六个报文upd是一种不可靠的传输层协议，tcp是一种可靠的传输层协议，tcp是如何做到可靠的？答案是：超时、重传、确认要想实现应用层的消息可靠投递，必须加入应用层的确认机制，即：要想让发送方client-A确保接收方client-B收到了消息，必须让接收方client-B给一个消息的确认，这个应用层的确认的流程，与消息的发送流程类似： 4）client-B向im-server发送一个ack请求包，即ack:R5）im-server在成功处理后，回复client-B一个ack响应包，即ack:A6）则im-server主动向client-A发送一个ack通知包，即ack:N至此，发送“你好”的client-A，在收到了ack:N报文后，才能确认client-B真正接收到了“你好”。 会发现，一条消息的发送，分别包含（上）（下）两个半场，即msg的R/A/N三个报文，ack的R/A/N三个报文，一个应用层即时通讯消息的可靠投递，共涉及6个报文，这就是im系统中消息投递的最核心技术。 可靠消息投递存在什么问题期望六个报文完成消息的可靠投递，但实际情况，msg:N，ack:N这两个报文都可能丢失（原因如第二章所述，可能是服务器奔溃、网络抖动、或者客户端奔溃），此时client-A都收不到期待的ack:N报文，即client-A不能确认client-B是否收到“你好”，但这两个报文的丢失对应的业务影响又大有不同：1）msg:N包丢失，业务结果是client-B没有收到消息2）ack:N包丢失，业务结果是client-B收到了消息，只是client-A不知道而已那怎么办呢？ 消息的超时与重传client-A发出了msg:R，收到了msg:A之后，在一个期待的时间内，如果没有收到ack:N，client-A会尝试将msg:R重发。可能client-A同时发出了很多消息，故client-A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到ack:N，以定时重发。 一旦收到了ack:N，说明client-B收到了“你好”消息，对应的消息将从“等待ack队列”中移除。 消息的重传存在什么问题上面第五部分提到过，msg:N，ack:N都有可能丢失：1）msg:N报文丢失，说明client-B之前压根没有收到“你好”报文，超时与重传机制十分有效2）ack:N报文丢失，说明client-B之前已经收到了“你好”报文（只是client-A不知道而已），超时与重传机制将导致client-B收到重复的消息，那就需要进行消息的去重。 消息去重解决方法也很简单，由发送方client-A生成一个消息去重的msgid，保存在“等待ack队列”里，同一条消息使用相同的msgid来重传，供client-B去重，而不影响用户体验。 其他1）上述设计理念，由客户端重传，可以保证服务端无状态性（架构设计基本准则）2）如果client-B不在线，im-server保存了离线消息后，要伪造ack:N发送给client-A 总结1）im系统是通过超时、重传、确认、去重的机制来保证消息的可靠投递，不丢不重2）一个“你好”的发送，包含上半场 msg:R/A/N 与下半场 ack:R/A/N 的6个报文3）im系统难以做到系统层面的不丢不重，只能做到业务层面的不丢不重]]></content>
      <categories>
        <category>IM</category>
      </categories>
      <tags>
        <tag>IM</tag>
        <tag>消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry布局控件frame为0的问题]]></title>
    <url>%2F2018%2F07%2F06%2FMasonry%E5%B8%83%E5%B1%80%E6%8E%A7%E4%BB%B6frame%E4%B8%BA0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Masonry 是对 autolayout 的封装，优雅的链式语法和简洁易用的接口让我们在做UI开发时节省了不少时间。然而在初次使用它时，由于还对 autolayout 理解不够深，就遇到了一些问题，比如使用 Masonry 对控件添加约束后，并不会立即生效，frame 仍然是 0。如果此时我们需要这个 frame，应该怎么做呢？ 1234567891011UIView *parent = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];UIImageView *child = [UIView alloc] init];[parent addSubview:child];[child mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(20,20)); make.top.left.mas_equalTo(50); &#125;];NSLog(@&quot;%@&quot;,redView);打印结果：** &lt;UIImageView: 0x7fb222605550; frame = (0 0; 0 0); layer = &lt;CALayer: 0x7fb22260b3a0&gt;&gt;** 使用 Masonry 添加约束后，如果有要设置 child 的形状为圆形，就得知道它的 frame，像下面这样写肯定不会设置成功的： 123456[child mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(20,20)); make.top.left.mas_equalTo(50); &#125;]; child.layer.cornerRadius = child.bounds.size.width/2; child.layer.masksToBounds = YES; //设置头像为圆形 因为这时候的 frame 还是 0。曾天真的想，会不会是因为 block 中的处理是在异步线程进行的，不会等待 block 执行完就已经走到了下面使用frame的代码，(一阵狂喜，好聪明。。。)，所以马上把代码改写： 123456[child mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(20,20)); make.top.left.mas_equalTo(50); child.layer.cornerRadius = child.bounds.size.width/2; child.layer.masksToBounds = YES; //设置头像为圆形 &#125;]; 然而并没有什么卵用。 想不通的时候，就只能请教 goole 了，然后找到了 Masonry 约束下获取 frame 的方法 masonry 本就是对 autolayout 的封装，使用 Masonry 就等于使用了苹果的 autolayout。使用 masonry 布局完之后，系统会在某个时间点调用各个 view 的 layoutSubViews 方法，从而更新各个控件的frame。遗憾的是，frame 的更新并不会在刚执行完 Masonry 布局代码时立即进行，在布局代码的下一行，你所获取到的 frame 仍然是0。 想要在布局代码结束就立即获取当前某个控件正确的 frame，需要调用layoutIfNeeded函数立即刷新布局，各个控件才会按照约束条件，生成当前布局相应的frame和bounds。而调用layoutIfNeeded的目的是让系统调用layoutSubviews方法，我们也可以直接在这个方法里获取frame，因为这时候开始layout subviews，Masonry已经计算出了真实的frame。 下面附上关于autolayout更新几个方法的区别： setNeedsLayout：标记页面需要更新，但是什么时候才会调用layoutSubviews 去刷新布局，就不一定了。 layoutIfNeeded：告知页面如果需要，就立刻更新布局。这里的“如果需要”什么意思呢？有什么条件吗？是的，只有满足如下某一个或几个条件，调用 layoutIfNeeded 才会立即刷新frame： 有 addSubview 操作 设置了view的 frame，当然前提是设置前后 frame 的值发生了变化 滚动一个UIScrollView 旋转 Screen 改变一个UIView大小的时候 如果不满足，就算是调用了 layoutIfNeeded 也不会立刻执行 layoutSubViews 进行 frame 更新。 如果我们想不管什么情况，都强制执行 layoutSubViews 进行 frame 更新怎么办呢？那就是同时调用下面这两个方法：12[self setNeedsLayout];[self layoutIfNeeded]; 这样必然会调用 layoutSubViews 。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Masonry</tag>
        <tag>auto layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发琐碎知识点]]></title>
    <url>%2F2018%2F07%2F06%2FiOS%E5%BC%80%E5%8F%91%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[作为一个半路出家的小白、一个为了生活不断积累技术知识的俗人，本着急功近利的的精神把工作中遇到的小问题、琐碎知识点总结下来留给我闺女。…… 1. bringSubViewToFront 不起作用的问题 bringSubViewToFront方法只对该view的childView起作用，而对grandView不起作用，可以用上面的方法，把grandView前置。 最近项目中遇到一个坑，有一个父view，该父view中添加了第三方SDK中的view，所以没有准确判断view的层级关系，导致我添加的一个label无论怎样调用bringSubViewToFront都无法显示在最前面。后来发现原因是，我的label添加后，调用bringSubViewToFront过早，因为这个时候第三方view还没加载上去，所以调用bringSubViewToFront也不会将label显示在第三方veiw的前面。要在第三方view加载完成后，才会起作用。 总结：bringSubViewToFront方法只会将某个view放在其父view的所有已存在的子view的前面。后来添加的view依然有可能遮挡住这个view. 2. 强制某个 viewController 横屏竖屏1234567891011121314151617181920/*方法*/- (void)interfaceOrientation:(UIInterfaceOrientation)orientation&#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = orientation; [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125; 举个栗子：123456789// 横屏- (IBAction)landscapAction:(id)sender &#123; [self interfaceOrientation:UIInterfaceOrientationLandscapeRight];&#125;// 竖屏- (IBAction)portraitAction:(id)sender &#123; [self interfaceOrientation:UIInterfaceOrientationPortrait];&#125; 3. nib 文件加载过程 Outlets are set after -init and before -awakeFromNib. If you want to access outlets, you need to do that in -awakeFromNib or another method that’s executed after the outlets are set (e.g. -[NSWindowController windowDidLoad]). When a nib file is loaded: Objects in the nib file are allocated/initialised, receiving either -init, -initWithFrame:, or -initWithCoder: All connections are reestablished. This includes actions, outlets, and bindings. -awakeFromNib is sent to interface objects, file’s owner, and proxy objects. 4. table view 优化123456789101. cell 复用2. view 的opaque属性尽可能设置为 YES3. 避免渐变、图像伸缩、离屏渲染4. 如果cell高度不变，缓存计算出的高度5. 如果cell展示的内容包含网络请求的内容，缓存并且异步加载6. 阴影用shadow path7. 尽可能减少cell的subviews数量8. 在cellForRowAtIndexPath回调中尽可能少做事，如果必须，尽可能缓存耗时操作的结果9. 抽象出合理的数据结构来展示信息10.直接设置rowHeight、sectionFooterHeight、sectionHeaderHeight的值，不要在相应的代理中设置 5. xib 中使用 autolayout 布局关于 xib 中使用 autolayout 布局的问题，下面两张图应该说明的很明白了。 6. 使用 setValue:forKey:设置对象属性值在使用 setValue:forKey: 设置对象属性值时，不管该属性是否为只读的、不管在 .h 或者 .m 文件中，都能够成功设置！ 果如你重写了这个属性的 setter 方法，那么也会走该属性的 setter 方法。 7. Class / id / objc_objectObjective-C类是由 Class 类型来表示的，它实际上是一个指向objc_class 结构体的指针。Class 的定义如下：1typedef struct objc_class *Class; 查看 objc/runtime.h 中 objc_class 结构体的定义如下： 12345678910111213141516struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 由 objc_class 结构体可知，在 objective-C 中，所有的类自身也是一个对象，里面有一个 Class 类型的 isa 指针，指向 metaClass(元类)。 super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。 cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，提高了调用效率。 objc_object 是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：1234567/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; id 类型是一个指向 objc_object 结构体类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。 在 Objective-C，一个对象的类由它的 isa 指针决定。isa 指针指向这个对象的 Class。在 Objective-C 中，对象的一个重要的特性是，你可以向它们发送消息： 当你向一个对象发送消息，就在那个对象的方法列表中查找那个消息。 当你想一个类发送消息，就再那个类的 meta-class 中查找那个消息。 meta-class 是一个类对象的类 当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。 meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class ，因为每个类的类方法基本不可能完全相同。 meta-class 是必须的，因为它为一个 Class 存储类方法。每个类都必须有一个唯一的 meta-class，因为每个 Class 都有一个可能不一样的类方法。 meta-class，如之前的 Class，同样是个对象。这就意味着你也可以在它上面调用方法。自然的，这就意味着它也必须有一个类 所有的 meta-class 使用它们基类的 meta-class （继承层次中最顶层的 Class 的 meta-class）作为它们自己的类。这就是说所有继承自 NSObject 的类（大部分的类），以 NSObject 的 meta-class 作为自己的 meta-class 的类。 遵循这个规则，所有的 meta-class 使用基类的 meta-class 作为他们的类，任何基类的 meta-class 将会是他们自己（它们的 isa 指向他们自己）。这就是说 NSObject 的 meta-class 的 isa 指针指向它们自己（是自己的一个实例）。 8. nullable、__nullable、_Nullable 究竟有什么区别 对于属性、方法返回值、方法参数的修饰，使用： nonnull/nullable 对于 C 函数的参数、Block 的参数、Block 返回值的修饰，使用： _Nonnull/_Nullable ， 建议弃用 nonnull/nullable 如果需要每个属性或每个方法都去指定 nonnull 和 nullable ，将是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END 。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull ，因此我们只需要去指定那些 nullable 指针对象即可。 疑问：为什么已经有了 nonnull/nullable ，为什么还要增加 _Nonnull/_Nullable ？ 9. 使用pathForResource获取不到 bundle 里的资源，返回nil的问题通过 右键-&gt;add files to 的方式将 Bundle 添加到工程里面，但是使用[[NSBundle mainBundle] pathForResource:@”name” ofType:@”type”]时，无论如何都找不到文件，经过了重启工程 、clear工程以及重启电脑等方式都无法解决问题。经过思考和测试，感觉这可能是xcode的一个bug。 解决办法及原理是这样的，[NSBundle mainBundle]其获取的路径是你程序的安装路径下的资源文件位置。 在xcode中采用add file to 方式添加文件时，一般情况下xcode会自动将文件添加到你的资源文件，而且，这些文件在你工程的 build Phases 中的 copy Bundle Resources 中可以查看到。但是有时候，由于xcode的问题，采用add files to 不能自动添加到你的资源文件中，这时，可以采用copy Bundle Resources下面的“+”号，手动将文件添加到你的资源文件中，这样就可以解决问题了。 10. 新建 window 并设置它的 rootViewController 遇到的状态栏问题新建 window 并设置它的 rootViewController ，在 rootViewController 中想要自定义状态栏样式或者隐藏状态栏，遇到的问题是，如果该 window 的 frame 不等于 [UIScreen mainScreen].bounds ，那么在 rootViewController 中想要使用下面两个方法设置状态栏时，是无效的，因为此时这两个方法不会调用： 12- (UIStatusBarStyle)preferredStatusBarStyle;- (BOOL)prefersStatusBarHidden Apple 这样做是有理由的，比如新建 window 不能覆盖整个屏幕，只是一个很小的悬浮框，此时的 rootViewController 不需要控制状态栏样式。 当不设置 window 的 frame 或者设置 window 的 frame 为 [UIScreen mainScreen].bounds 时，在 rootViewController 中才能够设置状态栏样式。 12345678910111213//能够正确设置状态栏的代码：UIWindow *delegateWindow = [UIApplication sharedApplication].delegate.window;CGRect rect = [UIScreen mainScreen].bounds;self.window = [[UIWindow alloc] init];self.window.rootViewController = self.rootVC;[self.window makeKeyAndVisible];self.window.frame = CGRectMake(0, -rect.size.height, rect.size.width, rect.size.height);// 保持原先的keyWindow，避免一些奇怪的bug[delegateWindow makeKeyWindow];[UIView animateWithDuration:0.3 animations:^&#123; self.window.frame = rect;&#125; completion:NULL]; 11. 当 present 一个viewController并且设置这个viewController背景透明度时，背景色变黑的问题想模态展示一个VC窗口，设置它的背景透明度为0.5，却发觉prsent后的背景色变为黑色。 原因是： NavigationController and the View Controllers are designed in such a way that only one view controller may show at a time. When a new view controller is pushed/presented the previous view controller will be hidden by the system. So when you reduce the modal view’s alpha you will possibly see the window’s backgroundColor (the black color you see now). If you want a translucent view to slide-in over the main view, you can add the view as the subView of main view and animate it using UIView Animations. 解决方法可以是 ：直接动画添加view或者 设置模态VC的属性 modalPresentationStyle 为UIModalPresentationCustom 12. App支持从4种来源去打开一个VC页面 Push推送 App外部网页打开 App内部网页打开 应用内点击打开 这四种方式均跳转到 DetailViewController 界面。普通的跳转依然可以满足该场景, 最简单的解决方案是在四个不同的地方都写一个独立的界面打开逻辑。作为一名有追求的开发者, 这么冗余的四份入口代码显然不合适。 一种解决方案是采用 URL 协议统一跳转。每个 viewController 页面定义与之对应的 URL，在各个入口只需要调用打开该URL的方法即可完成页面的创建以及跳转。 基于URL的路由方案： SNMediator 是用于 iOS 应用进行模块化拆分的中间件框架，它不依赖任何第三方库，基于 URL 协议实现三端(iOS, Android, H5)统一的页面跳转方式。 例如：你的 APP DetailViewController 界面对应URL定义为：myapp://businessModule/goodsdetails/?id=100其中，scheme为 myapp，host为 businessModule，path为 goodsdetails，携带参数 id=100. 使用 SNMediator 跳转页面方法如下： 123+ (BOOL)routeURL:(nonnull NSURL *)URL withParams:(nullable NSDictionary *)params completion:(void(^ _Nullable)(id _Nullable result))completion;[SNMediator routeURL:@&quot;myapp://businessModule/goodsdetails/?id=100&quot; params:nil completion:NULL]; SNMediator 支持通过字典传递额外的自定义复杂对象，也支持URL自身携带参数。所以4种入口都可以通过这一句代码调用完成页面跳转，保持了不同入口跳转同一界面的代码一致性。 13. iOS 中一个viewController只能 present 出来唯一一个其他viewController如果你要在同一个 viewController 中上同时 present 两个viewController，比如：12345SNViewControllerOne *oneVC = [[SNViewControllerOne alloc] init]; [self presentViewController:oneVC animated:YES completion:^&#123; SNViewControllerTwo *twoVC = [[SNViewControllerTwo alloc] init]; [self presentViewController:twoVC animated:YES completion:NULL]; &#125;]; 此时界面上只会显示 oneVC 的视图，不会显示 twoVC 并且 twoVC 也不存在于视图栈中。这是因为当一个新的 viewController 被 push/present 时，先前的那个 viewController 就会被系统隐藏，所以不会出现在视图栈中。 When a new view controller is pushed/presented the previous view controller will be hidden by the system. 并且在控制台还会给出警告： Warning: Attempt to present &lt; SNViewControllerTwo: 0x7ff813c5c760&gt; on &lt;SNRootViewController: 0x7ff813e307c0&gt; whose view is not in the window hierarchy! 告诉你当 SNRootViewController present 出来 SNViewControllerOne 后，再试图 present SNViewControllerTwo 时，SNRootViewController 已经被隐藏，不再存在于 window 的视图层级中，所以也就无法在 SNRootViewController 基础上继续 present 另一个视图。 14. UIGestureRecognizerState 各个状态的变化UIGestureRecognizerState的定义如下: 123456789typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; UIGestureRecognizerStatePossible, UIGestureRecognizerStateBegan, UIGestureRecognizerStateChanged, UIGestureRecognizerStateEnded, UIGestureRecognizerStateCancelled, UIGestureRecognizerStateFailed, UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded &#125;; Remarks:This describes the state of a UIGestureRecognizer. All of UIGestureRecognizers start in the Possible state. Once one or more touches has been received, the recognizers transition to the Began state. For one-shot patterns (like Tap), this will either transition into the Recognized state or the Failed state. For continuous gestures (like panning, pinching, rotating) the recognizer will transition to the Changed state and emit multiple calls back to the action and finally transition to either the Ended or Cancelled states. 15. NULL / nil / Nil / NSNullC 用 0 来作为不存在的原始值，而NULL作为指针，这在指针环境中相当于 0。 Objective-C 在 C 的表达不存在的基础上增加了nil。nil 是一个指向不存在的对象指针。虽然它在语义上与NULL 不同，但它们在技术上是相等的。 在框架层面，Foundation 定义了 NSNull，即一个类方法 +null，它返回一个单独的 NSNull 对象。NSNull 与 nil 以及 NULL 不同，因为它是一个实际的对象，而不是一个零值。、 在 Foundation/NSObjCRuntime.h 中，Nil 被定义为指向零的类指针。它并不常常出现，但至少值得注意。 16. CGGeometryGRect 用于表示屏幕上绘制的所有视图的 frame，一个程序员操作矩形几何体的能力决定着他在图形编程上的成功。 变换几何变换，这些函数返回在传入的矩形中做某些特定操作后的 CGRect CGRectOffset: 返回一个原点在源矩形基础上进行了偏移的矩形 12345CGRect CGRectOffset( CGRect rect, CGFloat dx, CGFloat dy) 注意，用这个你只改变了矩形的原点。它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。 CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形 12345CGRect CGRectOffset( CGRect rect, CGFloat dx, CGFloat dy) 注意，用这个你只改变了矩形的原点。它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。 CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形 12345CGRect CGRectInset( CGRect rect, CGFloat dx, CGFloat dy) 想一个视图中的视图更好看吗？用CGRectInset给它设置一个 10pt 的边距吧。需要记住的是，矩形将围绕它的中心点进行缩放，左右分别增减dx（总共2 x dx），上下分别增减 dy（总共 2 x dy）。 如果你用 CGRectInset 作为缩放矩形的快捷方法，一般通用的做法是嵌套调用CGRectOffset，把CGRectInset的返回值作为CGRectOffset的参数。 CGRectIntegral: 返回包围源矩形的最小整数矩形 123CGRect CGRectIntegral ( CGRect rect) 将CGRect 取整到最近的完整点是非常重要的。小数值会让边框画在像素边界处。因为像素已经是最小单元（不能再细分），小数值会使绘制时取周围几个像素的平均值，这样看起来就模糊了。 CGRectIntegral 将表示原点的值向下取整，表示大小的值向上取整，这样就保证了你的绘制代码平整地对齐到像素边界。 作为一个经验性的原则，如果你在执行任何一个可能产生小数值的操作（例如除法，CGGetMid[X|Y]，或是 CGRectDivide），在把一矩形作为视图的边框之前应该用CGRectIntegral正则化它。 从技术上讲，坐标系讲的是点，而视网膜屏一个点中有四个像素，所以它在奇数像素± 0.5f处绘制也不会产生模糊。 取值辅助函数CGRectGet[Min|Mid|Max][X|Y] 123456CGRectGetMinXCGRectGetMinYCGRectGetMidXCGRectGetMidYCGRectGetMaxXCGRectGetMaxY 这六个函数返回矩形x或y的最小、中间或最大值，原型如下： 123CGFloat CGRectGet[Min|Mid|Max][X|Y] ( CGRect rect) 用这些函数代替诸如frame.origin.x + frame.size.width之类的代码将更加清晰、语义上更为生动的（特别是用取中间和取最大函数）。 CGRectGet[Width|Height] CGRectGetHeight: 返回矩形的高度。 123CGFloat CGRectGetHeight ( CGRect rect) CGRectGetWidth: 返回矩形的宽度。 123CGFloat CGRectGetWidth ( CGRect rect) 跟之前的函数一样，用CGRectGetWidth 和 CGRectGetHeight返回CGRect的size成员更可取。这绝不只是节省了几个字符，语义上的清晰胜过简洁。 常量这里列出了三个我们必须了解的特殊矩形值，它们都有一些独一无二的属性： CGRectZero， CGRectNull，和 CGRectInfinite const CGRect CGRectZero: 一个原点在(0, 0)，且长宽均为 0 的常数矩形。这个零矩形与 CGRectMake(0.0f, 0.0f, 0.0f, 0.0f) 是等价的。 const CGRect CGRectNull: 空矩形。这个会在，比如说，求两个不相交的矩形的相交部分时返回。注意，空矩形不是零矩形。 const CGRect CGRectInfinite: 无穷大矩形。 CGRectZero 可能是所有这些特殊矩形中最有用的了。当初始化一个视图时，它们的边框通常设置为CGRectZero，把布局放到 -layoutSubviews中。 CGRectNull 跟 CGRectZero 是两回事，尽管它隐隐约约让你感觉到NULL == 0。这个值在概念上与NSNotFound相近，所以它表示预期值的缺失。请注意函数可能返回 CGRectNull，同时也应让它能正确处理传入的CGRectIsNull。 CGRectInfinite 是以上所有当中最有异国风情的，并且有一些最有趣的属性。它与所有的点或矩形相交，包含所有矩形，且它与任何矩形的并集等于它自身。用 CGRectIsInfinite 来检查一矩形是否为无限大。 最复杂、最容易误解、也最有用的CGGeometry 函数：CGRectDivide。 CGRectDivide: 将源矩形分为两个子矩形。 1234567void CGRectDivide( CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge) CGRectDivide 用以下方式将矩形分割为两部分： (1). 传入一个矩形并选择一条edge（上，下，左，右）(2). 平行那个边在矩形里量出amount的长度(3). 从edge 到量出的amount区域都保存到slice 参数中(4). 剩余的部分保存到remainder 参数中 其中 edge 参数是一个CGRectEdge 枚举类型： 123456enum CGRectEdge &#123; CGRectMinXEdge, CGRectMinYEdge, CGRectMaxXEdge, CGRectMaxYEdge&#125; CGRectDivide 用于在几个视图之间分割可用空间真是太完美了（把它在随后的remainder容纳多于两个的视图）。下次当你需要手机布局一个UITableViewCell时试试吧。CGRectDivide is perfect for dividing up available space among several views (call it on subsequent remainder amounts to accommodate more than two views). Give it a try next time you’re manually laying-out a UITableViewCell. 17. layoutSubViews 的使用当我们熟练使用 autolayout 时，或许会忽略了 layoutSubViews 的存在，但是不管是使用 autoLayout 还是直接 frame 布局，只要重写了 layoutSubViews，视图都会在布局它的子视图时调用 layoutSubViews（使用 autolayout 布局的话，不能在 layoutSubViews 再更改 frame 的值了）。那么我们一般什么时候需要重写它？既然 layoutSubViews 不能直接调用，那么系统在什么时候会调用它？触发的条件是什么呢？ 很显然，当你需要使用纯frame布局一个视图myView的子视图(view1 view2 view3等…)时，就需要重写 myView 的layoutSubViews 方法，计算并设置它的子视图的frame从而完成布局。 先看一段官方文档： The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method. 主要意思是，对于子视图的布局，如果 autoresizing 以及基于约束的布局方式不能满足你实际的需求时，才应该重写该方法。不要直接调用此方法。如果你想强制更新布局，你可以调用setNeedsLayout方法；如果你想立即数显你的views，你需要调用layoutIfNeeded方法。 layoutSubviews 以下情况会被调用 苹果官方文档已经强调，不能直接调用layoutSubviews对子视图进行重新布局。以下几种情况layoutSubviews会被调用。 直接调用setLayoutSubviews（这个在上面苹果官方文档里有说明） addSubview的时候。 当视图的的frame发生改变的时候。 滑动UIScrollView的时候。 旋转Screen会触发父UIView上的layoutSubviews事件。 改变一个子视图大小的时候，也会触发父视图上的 layoutSubviews 事件。 注意: 当view的frame的值为0的时候，addSubview也不会调用layoutSubviews的。layoutSubviews方法在对子视图进行布局的时候非常方便。]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>知识点总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS并发编程及陷阱]]></title>
    <url>%2F2018%2F07%2F06%2FiOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8F%8A%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[在iOS开发中，当使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘并发编程中隐藏的问题和陷阱，而且这种问题很难被调试。我们能做的就是遵循某些“规则”，理解一段代码到底不安全在哪里，才能在工作中尽可能规避并发编程的陷阱。 几个基本概念进程（Process） 简单来说，进程是指系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 线程（thread） 是操作系统能够进行运算调度的最小单，是组成进程的子单元。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。说得再具体一些，线程就是“一个CPU执行的一条无分叉的命令序列”。所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。 同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间、文件描述符等。但每个线程都拥有自己的栈，寄存器，本地存储（thread-local storage）。一个进程可以有很多线程，每条线程并行执行不同的任务，称为多线程。 多个线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么多个线程就可以真正的并行处理，从而减少了完成某项操作所需要的总时间。 并发(Concurrent)/并行(Parallel) 很多人对并发/并行的概念感到困惑，按照我的理解，并发所描述的概念是“同时”运行多个线程，多个线程“同时”被处理。这里对同时加了引号，因为这些线程可能是在单核 CPU 上以分时（时间共享）的形式，在极短的时间片段间不停的切换运行(类似通信中的时分复用(TDM))，也可能是在多核 CPU 上以真正的并行方式同时运行。 关于并发和并行，可以用下面这张有趣的图解释： 如果还是不能理解，或许应该看下这段准确的英文解释： Concurrency and parallelism are often mentioned together, so it’s worth a short explanation to distinguish them from each other. Separate parts of concurrent code can be executed “simultaneously”. However, it’s up to the system to decide how this happens — or if it happens at all. Multi-core devices execute multiple threads at the same time via parallelism; however, in order for single-cored devices to achieve this, they must run a thread, perform a context switch, then run another thread or process. This usually happens quickly enough as to give the illusion of parallel execution Although you may write your code to use concurrent execution under GCD, it’s up to GCD to decide how much parallelism is required. Parallelism requires concurrency, but concurrency does not guarantee parallelism. The deeper point here is that concurrency is actually about structure. When you code with GCD in mind, you structure your code to expose the pieces of work that can run simultaneously, as well as the ones that must not be run simulataneously. If you want to delve more deeply into this subject, check out this excellent talk by Rob Pike. 临界区(Critical Section) 不能被两个线程同时执行的一段代码叫做临界区。因为这段代码通常操控着一个共享的临界资源(一次仅允许一个线程使用的共享资源)，多个线程必须互斥的访问该临界资源。只能被单一线程/进程访问的共享资源，比如打印机等。 竞态条件(Race Condition) 软件系统的正确行为依赖于多个线程交替执行的时序时，就会发生竞态条件。常见的竟态条件为： 先检测后执行。执行依赖于检测的结果，而检测结果取决于多线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现问题。 对于 main 线程，如果文件a不存在，则创建文件a，但是在判断文件a不存在之后，Task线程创建了文件a，这时候先前的判断结果已经失效（main线程的执行依赖了一个错误的判断结果），此时文件a已经存在了，但是 main 线程还是会继续创建文件a，导致 Task 线程创建的文件a被覆盖、文件中的内容丢失等等问题。多线程环境中对同一个文件的操作要加锁。 延迟初始化（最典型即为单例） 12345678static MyObject *instance = nil;+ (instancetype)shareInstance&#123; if (instance == nil) &#123; instance = [[MyObject alloc] init]; &#125; return instance;&#125; 假如线程thread1和线程thread2同时执行 shareInstance，thread1 看到 instance 为空，创建了一个新的 Obj 对象，此时 thread2 也需要判断 instance 是否为空，此时的 instance 是否为空取决于不可预测的时序：包括 thread1 创建 Obj 对象需要多长时间以及线程的调度方式，如果 thread2 检测时，instance为空，那么 thread2 也会创建一个 instance 对象 死锁(Deadlock) Two (or sometimes more) threads are said to be deadlocked if they all get stuck waiting for each other to complete or perform another action. The first can’t finish because it’s waiting for the second to finish. But the second can’t finish because it’s waiting for the first to finish. 线程安全(Thread Safe) 是指代码在多线程或者并发任务下能够被安全调用，而不会引起任何问题(data corruption, crashing, etc)。非线程安全代码必须只能运行在单线程环境下。 上下文切换(Context Switch) A context switch is the process of storing and restoring execution state when you switch between executing different threads on a single process(进程). iOS 和 OS X 中的并发编程苹果的移动和桌面操作系统中提供了相同的并发编程API。 这里会介绍 pthread 、 NSThread 、GCD 、NSOperationQueue。 需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，也无法控制执行多长时间后将被暂停，以便轮换执行别的任务。开发者可以使用 POSIX 线程 API，或者 Objective-C 中提供的对该 API 的封装 NSThread，来创建自己的线程。下面这个小Demo利用 pthread 在一百万个数字中查找最小值和最大值，其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct inputInfo &#123; uint32_t *intputValues; size_t count;&#125;;struct resultInfo &#123; uint32_t min; uint32_t max;&#125;;void * findMinAndMax(void *arg)&#123; struct inputInfo const * const info = (struct inputInfo *)arg; uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i &lt; info-&gt;count; i++) &#123; uint32_t temp = info-&gt;intputValues[0]; min = MIN(temp, min); max = MAX(temp, max); &#125; free(arg); struct resultInfo *const result = (struct resultInfo *)malloc(sizeof(*result)); result-&gt;max = max; result-&gt;min = min; return result;&#125;int main(int argc, const char * argv[])&#123; // 使用随机数字填充 inputValues size_t const count = 1000000; uint32_t inputValues[count]; // 使用随机数字填充 inputValues for (size_t i = 0; i &lt; count; ++i) &#123; inputValues[i] = (uint32_t)i; &#125; // 开始4个寻找最小值和最大值的线程 size_t const threadCount = 5; pthread_t tid[threadCount]; for (size_t i = 0; i &lt; threadCount; ++i) &#123; struct inputInfo * const info = (struct inputInfo *) malloc(sizeof(*info)); size_t offset = (count / threadCount) * i; info-&gt;intputValues = inputValues + offset; info-&gt;count = MIN(count - offset, count / threadCount); int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info); NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err); &#125; // 等待线程退出 struct resultInfo * results[threadCount]; for (size_t i = 0; i &lt; threadCount; ++i) &#123; int err = pthread_join(tid[i], (void **) &amp;(results[i])); NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err); &#125; // 寻找 min 和 max uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i &lt; threadCount; ++i) &#123; min = MIN(min, results[i]-&gt;min); max = MAX(max, results[i]-&gt;max); free(results[i]); results[i] = NULL; &#125; NSLog(@&quot;min = %u&quot;, min); NSLog(@&quot;max = %u&quot;, max);&#125; return 0; NSThread 是 Objective-C 对 pthread 的封装，比直接使用 pthread 更方便些。但是不论使用 pthread 还是 NSThread 直接对线程操作，都是相对糟糕的编程体验。 直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。 下面介绍两种基于队列的并发编程API：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的线程池，来解决创建过多线程导致的问题。 Grand Central Dispatch为了让开发者更加容易的充分利用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。 通过GCD，开发者不必再直接跟线程打交道。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。 GCD中的两个核心概念是“任务”和“队列”，开发者只需专注于想要执行的“任务” block，然后添加到适当的“队列”中，这种形象的抽象方式更容易被人理解和使用。 GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 任务最终都将被放入到系统的全局队列和线程池中，如下图所示： 我们强烈建议，在大多数情况下使用默认优先级的队列就可以了，如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。 虽然 GCD 是一个低层级的 C 语言 API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱，这些将在后面并发编程带来的问题中进行讨论。 串行队列(Serial Queues) 串行队列中的任务，每次只执行一个，先前的任务执行完毕后，才会执行下一个。当然，你不会知道一个block结束与下一个block开始之间的时间间隔是多少，如下图所示： 这些任务的执行时间是在GCD的控制之下，你唯一能够确定的是：GCD每次只执行一个任务，任务执行顺序就是它们被加入队列的顺序。 因为在串行队列中两个任务不可能并发运行，所以就没有可能会同时访问同一个临界区的风险。所以仅对于这些任务而言，这种运行机制能够保护临界区避免发生竟态条件。所以，如果访问临界区的唯一方式是通过被提交到那个串行队列中的任务，那么你可以确保临界区是安全的。 并发队列(Concurrent Queues) 在并发队列中，你能够保证的仅有一件事：任务的执行顺序就是它们被添加到队列中的顺序。对于每个任务的完成顺序、下一个任务什么时候开始以及在任意给定时间内正在运行的 blocks 数量都是不清楚的，这些完全取决去 GCD。下图展示了在GCD下4个并发任务的执行： 上图表达的意思是，一个 block 什么时候开始执行完全取决于 GCD，如果一个 blcok 的执行时间与另一个重叠，由 GCD 决定这个 block 是需要运行在另一个核心上，还是在同一个核心上通过上下文切换(context switch)的方式执行。 系统提供了一个特殊的串行队列叫主队列(main queue)，像其他串行队列一样，主队列中的任务每次执行一个，但是能够确定的是，主队列中的所有任务都在主线程执行，主线程是唯一允许更新UI的线程。主队列用来向 UIViews 对象发送消息或者发送通知。 系统还提供了4种不同优先级的全局并发队列(Global Dispatch Queues)：background、low、default、high，优先级由低到高。需要注意的是，苹果的 API 也使用了这些队列，所以这些队列中并非只有你自己添加的任务。 最后，你还可以创建自定义串行/并发队列。也就是说，至少有五种队列可供选择：主队列、4个全局并发队列、自定义队列。 And that’s the big picture of dispatch queues! 队列派发函数GCD 的“艺术”归根结底在于选择合适的队列派发函数(dispatch function)将任务提交到特定队列中。下面举例说明几种常用的 dispatch function。 1. dispatch_async 12345678- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;First Log&quot;); // 1 &#125;); NSLog(@&quot;Second Log&quot;); // 2&#125; 下面这个动态图生动的呈现出究竟发生了什么，左侧是代码中的断点，右侧是相关队列的状态： 主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内； viewDidLoad 在主线程执行 现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_async dispatch_async 的 block 被添加到一个全局队列并且稍后将会执行它 在 dispatch_async 添加 block 到全局队列之后，viewDidLoad继续向下走，主线程把注意力放在剩余的任务上。与此同时，全局队列也正在并发的处理它的任务。再次提醒，全局队列中的任务将以 “FIFO” 的顺序出队(分发下去)，但是这些任务会被并发执行。 现在，被 dispatch_async 添加的 block 正在执行了 dispatch_async 的 block 执行完毕，所有的 NSLog 语句都已经将输出打印到了控制台。尽管在这个小例子中先执行了第二条打印任务，随后才执行第一条，不过 First Log 和 Second Log 打印顺序不定 —— 取决于在那个特定时间硬件正在处理的事情，你没有办法控制或者知晓哪条语句先执行。 类似如下代码片段，分析 line A 和 line B 的执行顺序。1234dispatch_async(myQueue, ^&#123; // line A&#125;);// line B 很显然，line A 和 line B 之间，或者说，在正在返回的 dispatch_async 方法和正在当前队列运行的block任务之间，存在竟态条件。所以执行顺序有以下多种情况： 如果队列 myQueue (假定是串行队列)繁忙，A 就必须等待，此时 B 先于 A 执行。 如果队列 myQueue 是空闲的，但是没有空闲的CUP资源，并且 myQueue 的优先级高于当前调用 dispatch_async 的线程的优先级，这个时候，系统会把CPU资源分给 myQueue 从而 A 先被执行。 The thread that called dispatch_async could run out of its time quantum after scheduling A on myQueue but before returning from dispatch_async, which again results in A running before B. 如果 myQueue 和CPU都是空闲状态，那么 A 和 B 将会同时执行完毕。 什么时候以及怎样使用 dispatch_async 和各种队列 自定义串行队列：当你想在后台串行的执行任务并跟踪这个任务的执行状态时，使用自定义串行队列是一个好的选择。这样能消除资源竞争，因为在同一时刻仅有一个任务正在执行。 主队列(Serial)：通常，在并发队列中的一项任务处理完成后，就需要更新UI。此时你需要嵌套 block 把UI更新任务提交到主队列。如果你现在已经处于主队列，并调用 dispatch_async 将任务添加到主队列，此时你唯一能确保的是，这个新添加的任务将在当前方法执行完毕后的某个时间才被执行。 并发队列：通常使用并发队列在后台处理非UI操作。 2. dispatch_sync 12345678- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;First Log&quot;); // 1 &#125;); NSLog(@&quot;Second Log&quot;); // 2&#125; 上图中各个步骤的说明如下： 主队列按顺序向前执行任务，下一个任务就是实例化一个 UIViewController，走到 viewDidLoad 方法内 viewDidLoad 在主线程执行 现在主线程运行到了 viewDidLoad 内部，即将到达 dispatch_sync dispatch_sync 的 block 被添加到一个 global queue 并且稍后将会执行它。主线程会被阻塞，直到 block 执行完毕。与此同时，global queue 正在并发的处理任务；在这个 global q ueue 中，所有 block 任务将按照 “FIFO” 的顺序出队，但是会被并发执行。 global queue 处理先前已经加入队列的任务(在 dispatch_sync block 之前添加到该全局队列中的任务) 开始执行 dispatch_sync 的 block block 执行完毕，dispatch_sync 函数返回，主线程恢复 viewDidLoad 方法执行完毕，主队列继续处理其他任务 dispatch_sync 函数将一个任务添加到一个队列中，会阻塞当前线程，直到该任务执行完毕。dispatch_async 不会等待任务执行完，当前线程会继续往下走，不会阻塞当前线程。使用 dispatch_sync 时应注意避免死锁(deadlock)！ Here’s a quick overview of when and where to use dispatch_sync: Custom Serial Queue: Be VERY careful in this situation; if you’re running in a queue and call dispatch_sync targeting the same queue, you will definitely create a deadlock. Main Queue (Serial): Be VERY careful for the same reasons as above; this situation also has potential for a deadlock condition. Concurrent Queue: This is a good candidate to sync work through dispatch barriers or when waiting for a task to complete so you can perform further processing. 3. dispatch_after 使用 dispatch_after 延迟执行某个任务。比如在1秒后执行某个block。代码如下：12345double delayInSeconds = 1.0; dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123; // 2 // your task delay to execute &#125;); dispatch_after works just like a delayed dispatch_async!! dispatch_after 在功能上就像延迟了的 dispatch_async，你没有办法掌控任务的实际执行时间，并且一旦 dispatch_after 函数返回，就没有办法取消任务。 怎样使用 dispatch_after: 自定义串行队列：在自定义串行队列中谨慎使用 dispatch_after 主队列(Serial)：主队列中使用 dispatch_after 是一个好的选择 并发队列：谨慎使用，一般你很少在自定义并发队列中使用 dispatch_after 4. Dispatch Group dispatch_group_create：创建 diapatch group1dispatch_group_t group = dispatch_group_create(); dispatch_group_async：提交 block 到 dispatch queue 中，并将 block 和 group 关联起来123dispatch_group_async(group, queue, ^&#123; // block&#125;); dispatch_group_wait：阻塞当前线程，等待 group 关联的所有 block 执行完毕或者到达指定时间。如果到达指定时间后，所有任务并没有全部完成，那么 dispatch_group_wait 返回一个非 0 的数，可以根据这个返回值，判断是否等待超时。如果设置为 DISPATCH_TIME_FOREVER ，意思是永远等待，直到所有 block 执行完毕。1dispatch_group_wait(group, DISPATCH_TIME_FOREVER); dispatch_group_notify：不阻塞当前线程，当 group 关联的所有 block 执行完毕后，回调通知123dispatch_group_notify(group, queue, ^&#123; // 所有 block 执行完毕的回调&#125;); 注意:123dispatch_group_async(group, queue, ^&#123; // block&#125;); 等价于12345dispatch_group_enter(group);dispatch_async(queue, ^&#123; // block dispatch_group_leave(group);&#125;); when and how to use dispatch groups with the various queue types: Custom Serial Queue: This is a good candidate for notifications when a group of tasks completes. Main Queue (Serial): This is a good candidate as well in this scenario. You should be wary of using this on the main queue if you are waiting synchronously for the completion of all work since you don’t want to hold up the main thread. However, the asynchronous model is an attractive way to update the UI once several long-running tasks finish such as network calls. Concurrent Queue: This as well is a good candidate for dispatch groups and completion notifications. 5. dispatch_apply 提交 block 到 dispatch queue，并重复调用多次 (Submits a block to a dispatch queue for multiple invocations.) dispatch_apply 就像 for 循环一样，并发执行每次的迭代任务。dispatch_apply 函数是同步的，直到所有任务执行完毕，才会返回。如果有大量迭代次数，并且每次迭代都仅处理少量工作，那么并不适合使用 dispatch_apply。 When is it appropriate to use dispatch_apply? Custom Serial Queue: A serial queue would completely negate the use of dispatch_apply; you might as well just use a normal for loop. Main Queue (Serial): Just as above, using this on a serial queue is a bad idea. Just use a normal for loop. Concurrent Queue: This is a good choice for concurrent looping, especially if you need to track the progress of your tasks. 6. 信号量 信号量是持有计数的信号，使用它控制对有限资源的使用和访问。假设有一间房子，它对应一个进程，房子里的两个人就对应两个线程。这个房子(进程)有很多资源，比如花园、客厅、卫生间等，是所有人(线程)共享的。但是有些地方，比卫生间，最多只能有1个人能进去。怎么办呢，在卫生间门口挂1把钥匙。进去的人(线程)拿着钥匙进去(信号量 -1)，外面的人(线程)没有钥匙就在门口等待，直到里面的人出来并把钥匙重新放回门口(信号量+1)，此时外面等待的人再拿着这个钥匙进去，所有人(线程)就按照这种方式依次访问卫生间这个有限的资源。门口的钥匙数量就称为信号量(Semaphore)。信号量为0时需要等待，信号量不为零时，减去1而且不等待。 可以像下面这样去使用 信号量: When you create the semaphore using the dispatch_semaphore_create function, you can specify a positive integer indicating the number of resources available. In each task, call dispatch_semaphore_wait to wait on the semaphore. When the wait call returns, acquire the resource and do your work. When you are done with the resource, release it and signal the semaphore by calling the dispatch_semaphore_signal function. 举个栗子：12345678910111213141516171819202122232425dispatch_group_t group = dispatch_group_create(); dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); NSMutableArray *mutableArr = [NSMutableArray array]; for (NSInteger i = 0; i &lt; 10000; i++) &#123; dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; /* 某个线程执行到这,如果信号量值为1，执行了wait方法后，信号量的值变成了0。并开始执行下面的代码。 */ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /* 这时候信号量的值为0，其它线程都处于等待状态。这样对 mutableArr 进行修改的线程， 在任意时刻都只有一个，能够保证多线程下读写 mutableArr 的安全性 */ [mutableArr addObject:@(i)]; /* 执行结束，要调用signal方法，把信号量的值加1。 这样，其他等待的线程按照等待的先后顺序继续访问 mutableArr */ dispatch_semaphore_signal(semaphore); &#125;); &#125; dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;%@&quot;,mutableArr.lastObject); 信号量与互斥锁的区别： 信号量，关注的是信号，信号！可以使用在线程间和进程间。只要信号是允许的，线程就可以访问某个资源。 互斥锁，只能用于线程间。使用时会锁住某个资源，只允许当前一个线程访问，其他线程无法访问，处于等待状态。解锁后其他处于等待状态的线程被唤醒，然后按照等待排队顺序继续访问。 7. dispatch_barrier 栅栏函数 dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用，它等待所有位于 barrier 函数之前的队列中的任务执行完毕后，再执行barrier block 中的任务，并且等待 barrier block中的任务执行完毕之后，barrier函数后续的任务才会得到执行，该函数需要同dispatch_queue_create 函数生成的并发队列(concurrent queue) 一起使用。 举个栗子：12345678910111213141516171819202122232425- (void)barrier&#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;1&quot;); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;2&quot;); &#125;); dispatch_barrier_async(concurrentQueue, ^&#123; NSLog(@&quot;barrier&quot;); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;3&quot;); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;4&quot;); &#125;);&#125;输出：1 2 barrier 4 3 其中1 2 与 3 4 由于异步执行先后顺序可能有变，但是 barrier 一定位于他们中间。 看一段官方文档能够更好的理解： 调用 dispatch_barrier_async 函数总会在 block 任务提交后立即返回，而不等待 block 被调用。 When the barrier block reaches the front of a private concurrent queue, it is not executed immediately. Instead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes. The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_createfunction. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_asyncfunction. 多线程并发带来的陷阱使用并发编程会带来许多陷阱。一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。 关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务戛然而止，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为优先级反转，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。 并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性，一个对象，通用的内存、网络设备或者一个文件等等。在多线程中，任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计，以防止这种冲突的发生。 为了演示这类问题，我们举一个关于资源的简单示例：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。问题来了，你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。 我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。 这个问题被叫做竞态条件，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。 在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序。 互斥锁 互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的互斥锁，只有当某个线程对资源完成了操作，释放掉这个互斥锁，这样别的线程才有机会访问该共享资源。 除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入内存屏障(Memory barrier)。通过设置 Memory barrier，来确保没有无序执行的指令能跨过屏障而执行。 当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：底层并发技术。 从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。 在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。 锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(锁的竞争是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。 在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出临界区段（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。 我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 CPU strategy view 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。 死锁 互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。 看看下面的代码，它交换两个变量的值：1234567891011void swap(A, B)&#123; lock(lockA); lock(lockB); int a = A; int b = B; A = b; B = a; unlock(lockB); unlock(lockA);&#125; 大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：12swap(X, Y); // 线程 1swap(Y, X); // 线程 2 此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。 再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。 资源饥饿（Starvation) 当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起读写问题。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。 为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 writer preference，或者使用 read-copy-update 算法。Daniel 在底层并发编程 API 中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。 优先级反转 本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题。 优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。 高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。 在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。 解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。 从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。 几个问题1. BOOL 属性存在多线程安全问题吗？ 属性为值类型（int，bool，long，CGFloat，NSInteger等）和对象类型，值类型存直接储在栈中，地址连续。而对象类型存储在堆中，通过指针访问，在64位系统中，指针占用8个字节，存储在栈中。比如，下面两个属性： 123@property (nonautomic, strong) NSString *data;@property (nonatomic, assgin) int count; 他们在内存中的布局如下图所示： 上图是属性在内存中的布局，当我们访问属性时，本质上是在访问以上内存区域。 self.data = @&quot;dkadfdjfjkasjdkf&quot;修改了指针的指向，访问的是栈内存；self.count = 10修改值类型，访问的是栈内存；[self.data rangeOfString:@&quot;kadfd&quot;]读取数据，访问的是堆内存。内存通过地址总线单向串行访问，即使在多线程下，也不会有出现两个线程同时经过地址总线去访问内存地址。也就是说，内存访问是通过地址总线排队串行访问的。总线位宽，是指同一时刻能够传输的二进制数据的位数，总线的位宽越宽，总线带宽就越大，总线的带宽指的是单位时间内总线上传送的数据量。64位总线可以同一时刻传输8个字节。也就是说，如果一段代码转化为二进制后的总比特数，不大于8个字节，那么就能在总线的一次访问中全部执行完毕，这段代码就是“原子”的。 ARC下属性的修饰符有： assign 此时 setter 方法仅仅是一个简单的赋值操作，没有内存管理代码，通常用于基本的数值类型，例如 CGFloat 和 NSInteger。 strong setter 方法包含内存管理代码，当给属性设定一个新值的时候，首先对新值进行 retain ，旧值进行 release ，然后进行赋值操作。 weak 当给属性设定一个新值的时候，这个值不会进行 retain，旧值也不会进行 release， 而是进行类似 assign 的操作。不过当属性指向的对象被销毁时，该属性会被置为nil。 unsafe_unretained 的语义和 assign 类似，不过是用于对象类型的，表示一个非拥有(unretained)的，同时也不会在对象被销毁时置为nil的(unsafe)关系。 copy 类似于 strong，不过在赋值时进行 copy 操作而不是 retain 操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用。 所以，BOOL 值大小只有一个字节，对 BOOL 属性的访问没有内存管理代码，仅仅是简单的读取/写入，所以64位系统的地址总线可一次访问完成，布尔属性的读写是原子的，不存在线程安全问题。 2. 以下代码会出现什么问题？ 123456789@property (nonatomic, strong) NSString *str;//....dispatch_queue_t queue = dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);for (int i = 0; i &lt; 1000000 ; i++) &#123; dispatch_async(queue, ^&#123; self.str = [NSString stringWithFormat:@&quot;ksddkjalkjd%d&quot;,i]; &#125;);&#125; crash! 1EXC_BAD_ACCESS 访问已经释放的内存导致。从 setter 方法以及 strong 源码来分析下原因： 123456789101112131415161718192021222324252627282930313233343536/* objc-class.mm*/void _object_setIvar(id obj, Ivar ivar, id value, bool assumeStrong)&#123; if (!obj || !ivar || obj-&gt;isTaggedPointer()) return; ptrdiff_t offset; objc_ivar_memory_management_t memoryManagement; _class_lookUpIvar(obj-&gt;ISA(), ivar, offset, memoryManagement); if (memoryManagement == objc_ivar_memoryUnknown) &#123; if (assumeStrong) memoryManagement = objc_ivar_memoryStrong; else memoryManagement = objc_ivar_memoryUnretained; &#125; id *location = (id *)((char *)obj + offset); switch (memoryManagement) &#123; case objc_ivar_memoryWeak: objc_storeWeak(location, value); break; case objc_ivar_memoryStrong: objc_storeStrong(location, value); break; case objc_ivar_memoryUnretained: *location = value; break; case objc_ivar_memoryUnknown: _objc_fatal(&quot;impossible&quot;); &#125;&#125;void object_setIvar(id obj, Ivar ivar, id value)&#123; return _object_setIvar(obj, ivar, value, false /*not strong default*/);&#125;void object_setIvarWithStrongDefault(id obj, Ivar ivar, id value)&#123; return _object_setIvar(obj, ivar, value, true /*strong default*/);&#125; 123456789101112131415/* NSObject.mm*///更改指针 *location 的内存指向objc_storeStrong(id *location, id obj)&#123; id prev = *location; //指针prev指向原始堆内存中的数据 if (obj == prev) &#123; return; &#125; objc_retain(obj); //对新对象 retain *location = obj; //更改指针 *location 的内存指向，使它指向新的堆内存 objc_release(prev); //释放原始的堆内存 &#125; 由于是非原子操作，当两个线程同时进入 objc_storeStrong ，就会引起 prev 对象的重复释放。 如果将 self.str = [NSString stringWithFormat:@&quot;ksddkjalkjd%d&quot;,i];中的字符串改短一些，比如改为:1self.str = [NSString stringWithFormat:@&quot;ksd%d&quot;,i]; 就不会crash了。这就需要了解下苹果在64位系统引入的一种内存技术：Tagged Pointer。 比如我们定义一个字符串变量：1NSString *name = [NSString stringWithFormat:@&quot;Dog&quot;]; 64位系统中，首先在堆中开辟8个字节存储@”Dog”，然后在栈中分配8字节空间存放指针变量。这样存储三个字符，就占用了16字节的空间，而且为了维护该对象的引用计数还需要额外的内存开销，这造成了内存的浪费。Tagged Pointer 技术，充分利用指针的8个字节空间，直接存储小于8字节的 NSNumber/NSString 数据。 比如定义两个字符串： 12NSString *str1 = [NSString stringWithFormat:@&quot;%@&quot;, @&quot;123&quot;];NSString *str2 = [NSString stringWithFormat:@&quot;%@&quot;, @&quot;1234567890123456&quot;]; 打印出来他们的类型、内存地址：1234(lldb) p str1(NSTaggedPointerString *) $0 = 0xa000000003332313 @&quot;123&quot;(lldb) p str2(__NSCFString *) $1 = 0x00000001d004b250 @&quot;1234567890123456&quot; str1 是一个 Tagged Pointer，它的一部分用来存储数据 @”123”,另一部分用作标记位。 Tagged Pointer特点： Tagged Pointer 专门用来存储小的对象，例如NSNumber和NSDate Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。 在内存读取上有着3倍的效率，创建时比以前快106倍。 由此可见，苹果引入Tagged Pointer，不但减少了64位机器下程序的内存占用，还提高了运行效率。完美地解决了小内存对象在存储和访问效率上的问题。但是 Tagged Pointer 并不是一个真正的对象，没有 isa 指针。所以要避免在代码中直接访问对象的 isa 变量。 3. 线程间通信方式有哪些？ 全局变量/常量、静态变量、文件等。 总结我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。 但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。 我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。 参考文献线程安全类的设计 Grand Central Dispatch In-Depth:Part 1/2 Grand Central Dispatch In-Depth:Part 2/2 iOS多线程到底不安全在哪里 Guides and Sample Code]]></content>
      <categories>
        <category>iOS dev</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
